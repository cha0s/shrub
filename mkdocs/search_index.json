{
    "docs": [
        {
            "location": "/",
            "text": "Welcome!\n\n\nShrub is a full-stack JavaScript application framework. It is\norganized into \npackages\n which implement\n\nhooks\n, as a means of communicating between each other and\ninfluencing the way the entire application behaves.\n\n\nThe intention of Shrub is to allow you to build rich, powerful applications in\nan elegant and structured way -- without needing to hack on or change Shrub's\ncore codebase. Everything you need should be doable by creating a new package.\nIf you find the opposite to be true, feel free to\n\nopen an issue\n!\n\n\nTutorials in general are a bit lacking at the moment, this will be soon be\nremedied!",
            "title": "Home"
        },
        {
            "location": "/#welcome",
            "text": "Shrub is a full-stack JavaScript application framework. It is\norganized into  packages  which implement hooks , as a means of communicating between each other and\ninfluencing the way the entire application behaves.  The intention of Shrub is to allow you to build rich, powerful applications in\nan elegant and structured way -- without needing to hack on or change Shrub's\ncore codebase. Everything you need should be doable by creating a new package.\nIf you find the opposite to be true, feel free to open an issue !  Tutorials in general are a bit lacking at the moment, this will be soon be\nremedied!",
            "title": "Welcome!"
        },
        {
            "location": "/guide/getting-started/",
            "text": "Getting started\n\n\n\nWelcome to Shrub, an opinionated full stack JavaScript web application\nframework. In this guide, we'll go over how to set up a working Shrub instance\nand outline some of the steps forward to build your application.\n\n\nNOTE:\n Shrub uses a database abstraction layer and presently it defaults\nto using Redis as the backend. This is completely configurable, but if you\njust punch in the defaults as this guide suggests, you will run into issues if\nyou don't have a redis server installed on the machine.\n\n\nInstalling Shrub\n\n\nFirst off, you'll need to clone Shrub itself. Fire up your trusty terminal:\n\n\ngit clone git://github.com/cha0s/shrub.git\n\n\n(obviously you can use a git management tool if you fancy that sort of thing,\nnot that there's anything wrong with that...)\n\n\nHead into the directory you just cloned and issue:\n\n\nnpm install\n\n\nThe next step is to create a configuration file. Look in the \nconfig\n directory\nand you will see a file called \ndefault.settings.yml\n. Create a copy of that\nfile called \nsettings.yml\n. Shrub \nrequires\n a configuration file at this\ntime, so this is not an optional step.\n\n\nFinally, to build and run the code you can do this:\n\n\nDEBUG=shrub:* grunt execute\n\n\nYou don't strictly need the \nDEBUG=shrub:*\n part, but we do that so it's easy\nto see when the server is up and ready for connections (and preserving the\nability to skip using that and have the server output be silent for\nproduction).\n\n\nWhen you see \nshrub:http Shrub HTTP server up and running on port 4201!\n, that\nmeans you can visit your site in the browser. Go ahead and visit\nhttp://localhost:4201 and see your Shrub instance chugging along!\n\n\nCreating your first package\n\n\nSo great, we have Shrub running, but we want to build our own application!\n\n\nDeveloping for Shrub means creating packages that implement hooks. Let's create\na simple package to get our hands dirty. You'll see that there is a \ncustom\n\ndirectory in your Shrub installation. This is where we'll put all of the\npackages we create.\n\n\nCreate the package\n\n\nHead into that directory and create a directory called \nmy-package\n. Head into\nthat directory and create a file called \nindex.js\n. \nNOTE:\n you can create\n\nindex.coffee\n if you prefer CoffeeScript (as the author does). Open that file\nand put in the following code:\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubCorePreBootstrap', function() {\n    console.log('I hooked into shrub!');\n  });\n};\n\n\n\n\n(Obviously you will use the equivalent in CoffeeScript if using it, however I\nwill stick to JavaScript for the examples so we don't scare anyone)\n\n\nAdd the package to the settings file\n\n\nCurrently to enable a package for shrub, you must add it by hand to the\nsettings file. We'll open up the \nconfig/settings.yml\n file we created earlier\nand add our package to the \npackageList\n array:\n\n\npackageList: [\n  \"my-package\",\n  \"shrub-angular\",\n  \"shrub-assets\",\n  \"shrub-config\",\n...\n\n\n\n\nGo go go\n\n\nIf your Shrub server is still running, kill it and run the following:\n\n\nDEBUG=shrub:* grunt execute\n\n\nYou'll see a bunch of stuff fly by, but you should also notice this:\n\n\nI hooked into shrub!\n\n\nThis means that our package was hooked into Shrub and the\n\nshrubCorePreBootstrap\n hook was invoked! Hurray, we have our first Shrub\npackage.",
            "title": "Getting started"
        },
        {
            "location": "/guide/getting-started/#installing-shrub",
            "text": "First off, you'll need to clone Shrub itself. Fire up your trusty terminal:  git clone git://github.com/cha0s/shrub.git  (obviously you can use a git management tool if you fancy that sort of thing,\nnot that there's anything wrong with that...)  Head into the directory you just cloned and issue:  npm install  The next step is to create a configuration file. Look in the  config  directory\nand you will see a file called  default.settings.yml . Create a copy of that\nfile called  settings.yml . Shrub  requires  a configuration file at this\ntime, so this is not an optional step.  Finally, to build and run the code you can do this:  DEBUG=shrub:* grunt execute  You don't strictly need the  DEBUG=shrub:*  part, but we do that so it's easy\nto see when the server is up and ready for connections (and preserving the\nability to skip using that and have the server output be silent for\nproduction).  When you see  shrub:http Shrub HTTP server up and running on port 4201! , that\nmeans you can visit your site in the browser. Go ahead and visit\nhttp://localhost:4201 and see your Shrub instance chugging along!",
            "title": "Installing Shrub"
        },
        {
            "location": "/guide/getting-started/#creating-your-first-package",
            "text": "So great, we have Shrub running, but we want to build our own application!  Developing for Shrub means creating packages that implement hooks. Let's create\na simple package to get our hands dirty. You'll see that there is a  custom \ndirectory in your Shrub installation. This is where we'll put all of the\npackages we create.  Create the package  Head into that directory and create a directory called  my-package . Head into\nthat directory and create a file called  index.js .  NOTE:  you can create index.coffee  if you prefer CoffeeScript (as the author does). Open that file\nand put in the following code:  exports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubCorePreBootstrap', function() {\n    console.log('I hooked into shrub!');\n  });\n};  (Obviously you will use the equivalent in CoffeeScript if using it, however I\nwill stick to JavaScript for the examples so we don't scare anyone)  Add the package to the settings file  Currently to enable a package for shrub, you must add it by hand to the\nsettings file. We'll open up the  config/settings.yml  file we created earlier\nand add our package to the  packageList  array:  packageList: [\n  \"my-package\",\n  \"shrub-angular\",\n  \"shrub-assets\",\n  \"shrub-config\",\n...",
            "title": "Creating your first package"
        },
        {
            "location": "/guide/getting-started/#go-go-go",
            "text": "If your Shrub server is still running, kill it and run the following:  DEBUG=shrub:* grunt execute  You'll see a bunch of stuff fly by, but you should also notice this:  I hooked into shrub!  This means that our package was hooked into Shrub and the shrubCorePreBootstrap  hook was invoked! Hurray, we have our first Shrub\npackage.",
            "title": "Go go go"
        },
        {
            "location": "/guide/errors/",
            "text": "Error handling\n\n\n\nShrub provides a mechanism to define errors that can be transmitted over the\nwire.\n\n\nThis is accomplished by subclassing\n\nTransmittableError\n.\nLet's look at an example.\n\n\nDefine an error\n\n\nSay we'd like to implement an error saying that one user can't add another\nuser as a friend. We might implement that like so:\n\n\nvar TransmittableError = require('errors').TransmittableError;\n\nfunction FriendRequestError(message, addingUserName, addedUserName) {\n  TransmittableError.apply(this, arguments);\n\n  this.addingUserName = addingUserName;\n  this.addedUserName = addedUserName;\n}\n\nFriendRequestError.prototype = new TransmittableError();\nFriendRequestError.prototype.key = 'friendRequest';\nFriendRequestError.prototype.template = ':message :addingUserName cannot add :addedUserName as a friend!';\nFriendRequestError.prototype.toJSON = function() {\n  return {\n    key: this.key,\n    message: this.message,\n    addingUserName: this.addingUserName,\n    addedUserName: this.addedUserName\n  };\n};\n\n\n\n\nWe now have our friend request error! You'll want to return it (in an array)\nfrom your package's implementation of\n\nshrubTransmittableErrors\n.\n\n\nInstantiate an error\n\n\nYou can instantiate one of these errors:\n\n\nvar errors = require('errors');\nvar error = errors.instantiate('friendRequest', 'Friend request error!', 'Alice', 'Bob');\n\n\n\n\nNotice the arguments to \nerrors.instantiate\n are first the key, followed by\nthe arguments defined by your subclass constructor.\n\n\nRender a formatted error\n\n\nTo see the error output you could do something like:\n\n\nvar errors = require('errors');\nconsole.error(errors.message(error));\n\n\n\n\nwhich would output:\n\n\nFriend request error! Alice cannot add Bob as a friend!\n\n\n\n\nYou might be wondering, why is the 'message' formatting function on \nerrors\n\ninstead of a method on \nTransmittableError\n? The reason is because\n\nerrors.message\n is designed to work not only if you pass it an instance of\n\nTransmittableError\n, but also instances of \nError\n, as well as primitive\ntypes.\n\n\nRender an error stack\n\n\nYou can view the stack of any error in a similar way:\n\n\nvar errors = require('errors');\nconsole.error(errors.stack(error));\n\n\n\n\nThe beauty of subclassing \nTransmittableError\n\n\nThe real joy of \nTransmittableError\n subclasses comes from the fact that you\ncan throw or return them from an implementation of\n\nshrubRpcRoutes\n and they will be automatically\nserialized, sent over the wire, and reified on the client side so they can be\npresented to the user in a meaningful way.",
            "title": "Error handling"
        },
        {
            "location": "/guide/errors/#define-an-error",
            "text": "Say we'd like to implement an error saying that one user can't add another\nuser as a friend. We might implement that like so:  var TransmittableError = require('errors').TransmittableError;\n\nfunction FriendRequestError(message, addingUserName, addedUserName) {\n  TransmittableError.apply(this, arguments);\n\n  this.addingUserName = addingUserName;\n  this.addedUserName = addedUserName;\n}\n\nFriendRequestError.prototype = new TransmittableError();\nFriendRequestError.prototype.key = 'friendRequest';\nFriendRequestError.prototype.template = ':message :addingUserName cannot add :addedUserName as a friend!';\nFriendRequestError.prototype.toJSON = function() {\n  return {\n    key: this.key,\n    message: this.message,\n    addingUserName: this.addingUserName,\n    addedUserName: this.addedUserName\n  };\n};  We now have our friend request error! You'll want to return it (in an array)\nfrom your package's implementation of shrubTransmittableErrors .",
            "title": "Define an error"
        },
        {
            "location": "/guide/errors/#instantiate-an-error",
            "text": "You can instantiate one of these errors:  var errors = require('errors');\nvar error = errors.instantiate('friendRequest', 'Friend request error!', 'Alice', 'Bob');  Notice the arguments to  errors.instantiate  are first the key, followed by\nthe arguments defined by your subclass constructor.",
            "title": "Instantiate an error"
        },
        {
            "location": "/guide/errors/#render-a-formatted-error",
            "text": "To see the error output you could do something like:  var errors = require('errors');\nconsole.error(errors.message(error));  which would output:  Friend request error! Alice cannot add Bob as a friend!  You might be wondering, why is the 'message' formatting function on  errors \ninstead of a method on  TransmittableError ? The reason is because errors.message  is designed to work not only if you pass it an instance of TransmittableError , but also instances of  Error , as well as primitive\ntypes.",
            "title": "Render a formatted error"
        },
        {
            "location": "/guide/errors/#render-an-error-stack",
            "text": "You can view the stack of any error in a similar way:  var errors = require('errors');\nconsole.error(errors.stack(error));",
            "title": "Render an error stack"
        },
        {
            "location": "/guide/errors/#the-beauty-of-subclassing-transmittableerror",
            "text": "The real joy of  TransmittableError  subclasses comes from the fact that you\ncan throw or return them from an implementation of shrubRpcRoutes  and they will be automatically\nserialized, sent over the wire, and reified on the client side so they can be\npresented to the user in a meaningful way.",
            "title": "The beauty of subclassing TransmittableError"
        },
        {
            "location": "/guide/forms/",
            "text": "Form handling\n\n\n\nForms are created by passing a form definition object to the\n\nshrub-form\n directive\n.\n\n\nA form definition object is defined like:\n\n\n\n\n(Optional String) \nkey\n - The form hey included on the form as a hidden\n  value, also used to generate an HTML class. Defaults to the scope key (See\n  below).\n\n\n(Function Array) \nsubmits\n - An array of functions to be invoked when the\n  form is submitted. The functions take a single \nvalues\n parameter containing\n  a keyed object of all field values in the form.\n\n\n(Object) \nfields\n - A keyed object of all form fields. Each field is defined\n  like:\n\n\n(String) \ntype\n - The \nwidget\n type.\n\n\n(Optional String) \nlabel\n - The human-readable label. Defaults to no\n  label.\n\n\n(Optional Boolean) \nrequired\n - Whether this field is required for\n  submission. Defaults to \nfalse\n.\n\n\n(Optional Any) \nvalue\n - The default value of this field.\n\n\nWidgets can define arbitrary parameters, see the documentation for the\n  specific widget to learn any extra parameters.\n\n\n\n\n\n\n\n\nThe following builtin widgets and their extra parameters are:\n\n\ncheckboxes\n:\n\n\n\n\n(Array) \ncheckboxes\n - An array of checkbox field definitions.\n\n\n\n\nradio\n:\n\n\n\n\n(Any) \nselectedValue\n - What \nvalue\n will be populated with when this\n    radio is selected.\n\n\n\n\nradios\n:\n\n\n\n\n(Array) \nradios\n - An array of radio field definitions.\n\n\n\n\nselect\n:\n\n\n\n\n(String) \noptions\n - An options expression. See\n    \nthe Angular documentation\n\n    for more information.\n\n\n\n\ntext\n:\n\n\n\n\n(Number) \nminlength\n - The minimum length of the text field.\n\n\n(Number) \nmaxlength\n - The maximum length of the text field.\n\n\n(String) \npattern\n - An expression that evaluates to a RegExp to test\n    for validity. See\n    \nthe Angular documentation\n\n    for more information.\n\n\n(Boolean) \ntrim\n - Whether to trim the input.\n\n\n\n\nIf you define a form definition object like:\n\n\n  $scope.someFormThing =\n    submits: [\n      ->\n    ]\n    fields:\n      foo:\n        type: 'text'\n\n\n\n\nYou can include it into a directive under the scope like:\n\n\n<div\n  data-shrub-form\n  data-form=\"someFormThing\"\n></div>\n\n\n\n\nIn this case, the form key will default to \nsomeFormThing\n.",
            "title": "Form handling"
        },
        {
            "location": "/guide/packages/",
            "text": "Package system\n\n\n\nShrub is organized into packages which implement hooks.\n\n\nA package is essentially a node.js module. Exporting a \npkgmanRegister\n\nfunction allows shrub to register your package in its package manager. This is\nhow you can implement hooks, allowing you to augment, modify, and even define\nShrub's behavior.\n\n\nThe simplest example of a package would be something like:\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubCorePreBootstrap', function() {\n    console.log('I hooked into shrub!');\n  });\n};\n\n\n\n\nThis package simply hooks into the\n\nshrubCorePreBootstrap\n hook and logs\na message to the console when that hook is invoked. Obviously this particular\npackage isn't super useful!\n\n\nHooks are how Shrub allows packages to implement (or invoke) dynamic behavior.\nHooks can also serve as a form of message passing between packages.\n\n\nYou can do anything from\n\ndefining an Angular directive\n\nto \nspecifying model collections\n. See the\n\nhook reference\n to learn more about the hooks that come\nincluded with shrub's core packages.\n\n\nTo implement a hook, export a \npkgmanRegister\n method which takes a \nregistrar\n\nargument, and use the registrar to register your hook:\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('someHook', function() {\n    doStuff();\n  });\n\n  registrar.registerHook('someOtherHook', function(arg) {\n    doOtherStuffWith(arg);\n  });\n};\n\n\n\n\nTo invoke a hook, require \npkgman\n and use the \ninvoke\n method:\n\n\nvar pkgman = require('pkgman');\n\nvar results = pkgman.invoke('someOtherHook', arg);\n\n\n\n\nAny arguments following the hook name will be passed along to the\nimplementations. Hooks are invoked synchronously. For more information about\n\npkgman\n, see \nthe pkgman documentation\n.",
            "title": "Package system"
        },
        {
            "location": "/guide/concepts/",
            "text": "This page explains various concepts and conventions used in Shrub.\n\n\nMiddleware hook specification\n\n\nShrub invokes various hooks\n(\nshrubHttpMiddleware\n,\n\nshrubBootstrapMiddleware\n, and more...)\nwhich allow packages to define middleware to be dispatched during various\nprocesses.\n\n\nMiddleware hooks return a specification that looks like:\n\n\n{\n  label: 'What the middleware functions do',\n  middleware: [\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    },\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    }\n  ]\n}\n\n\n\n\nThe \nlabel\n exists only to provide debugging information so you can see if any\nof your middleware are having problems by checking the debug console logs.\n\n\nThe \nmiddleware\n are applied serially, meaning the first function in the array\nis dispatched first, followed by the second, etc.\n\n\nSee the\n\nmiddleware module\n\nfor even more information about defining middleware.\n\n\nAnnotated functions\n\n\nAnnotated functions are an Angular convention, but are used widely throughout\nShrub on the client-side. Annotated functions allow dependency injection. You\ncan read more about annotated functions in\n\nthe Angular documentation\n.",
            "title": "Concepts and conventions"
        },
        {
            "location": "/guide/concepts/#middleware-hook-specification",
            "text": "Shrub invokes various hooks\n( shrubHttpMiddleware , shrubBootstrapMiddleware , and more...)\nwhich allow packages to define middleware to be dispatched during various\nprocesses.  Middleware hooks return a specification that looks like:  {\n  label: 'What the middleware functions do',\n  middleware: [\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    },\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    }\n  ]\n}  The  label  exists only to provide debugging information so you can see if any\nof your middleware are having problems by checking the debug console logs.  The  middleware  are applied serially, meaning the first function in the array\nis dispatched first, followed by the second, etc.  See the middleware module \nfor even more information about defining middleware.",
            "title": "Middleware hook specification"
        },
        {
            "location": "/guide/concepts/#annotated-functions",
            "text": "Annotated functions are an Angular convention, but are used widely throughout\nShrub on the client-side. Annotated functions allow dependency injection. You\ncan read more about annotated functions in the Angular documentation .",
            "title": "Annotated functions"
        },
        {
            "location": "/examples/todo-list/",
            "text": "How could Shrub be complete without an implementation of a simple TODO list? It\nwould be unthinkable! So that's exactly what this document is going to\ndescribe.\n\n\nIf you haven't yet, read the \ngetting started guide\n\nand get yourself a working copy of Shrub. I'll wait.\n\n\n\n\nCan't contain your excitement?\n\n\nIf you would like to skip all this and just get to trying out a fully\nformed TODO list,\n\ncheck out the executive summary\n\n\n\n\nCreate the package\n\n\nThe TODO list will be implemented as a Shrub package. This means we're going to\ncreate a package and enable it.\n\n\nYour Shrub installation includes a \ncustom\n directory. Within it we will create\nour TODO package. Create a directory and file structure like this:\n\n\nYOUR_SHRUB_DIRECTORY/custom/todo-list/index.js\nYOUR_SHRUB_DIRECTORY/custom/todo-list/client/index.js\nYOUR_SHRUB_DIRECTORY/custom/todo-list/client/item.js\nYOUR_SHRUB_DIRECTORY/custom/todo-list/client/list.js\nYOUR_SHRUB_DIRECTORY/custom/todo-list/client/new.js\n\n\n\n\nWe'll go through one at a time and talk about what goes in these files. I will\nMostly show the source code, punctuated by commentary when necessary.\n\n\nThe source\n\n\n\nindex.js\n\n\nLets start with the top-level index.js file. This is the code that will run on\nthe server. In fact, everything except files in the \nclient\n directory are only\navailable on the server. The \nclient\n directory is available to the server as\nwell, but the reverse doesn't apply: \nthe client has no access to anything\noutside the \nclient\n directory.\n\n\nFirst off, we'll start with the package manager's entry point. This is defined\nfor every package file which implements hooks.\n\n\n\n// Entry point for package management. Every package defining hooks does so\n// through the registrar passed to `exports.pkgmanRegister`.\nexports.pkgmanRegister = function(registrar) {\n\n\n\n\n\npkgman\n will pass in a registrar which is used to register hooks and point to\nsubpackage files. More on the latter to come.\n\n\nLet's implement a model that will represent our TODO list items. See\n\nthe documentation for \nshrubOrmCollections\n\nfor details.\n\n\n\n  // Implements hook `shrubOrmCollections`.\n  registrar.registerHook('shrubOrmCollections', function() {\n\n    // Return an object whose keys determine the name of the collection in the\n    // system, and whose values are Waterline configuration.\n    return {\n\n      // We're only defining a TODO list item model since we only have one\n      // global list in this example. It'd be possible to create a `todo-list`\n      // model and associate the `todo-list-item`s with it, but we opt for\n      // simplicity.\n      'todo-list-item': {\n\n        attributes: {\n\n          // Whether the item is marked as completed.\n          isCompleted: {\n            type: 'boolean',\n            defaultsTo: false\n          },\n\n          // The item text, e.g. \"Make a TODO example for Shrub\".\n          text: {\n            type: 'string'\n          }\n        }\n      }\n    };\n  });\n\n\n\n\n\nThis registers a model named \ntodo-list-item\n in the ORM so we can create,\nread, update, and delete instances.\n\n\nFinally, we'll create some RPC routes. These are the endpoints that the client\ncommunicates with. We'll create RPC routes for retrieving all TODO items,\ncreating an item, updating an item, and deleting an item.\n\n\n\n  // Implements hook `shrubRpcRoutes`.\n  registrar.registerHook('shrubRpcRoutes', function() {\n\n    var routes = [];\n\n    // Get our collection.\n    var TodoListItem = require('shrub-orm').collection('todo-list-item');\n\n\n\n\n\nFirst, the route to retrieve all items.\n\n\n\n    // This route will be hit when a client first connects, to give them a\n    // snapshot of the current TODO list.\n    routes.push({\n      path: 'todo-list',\n\n      // Route middleware can be a single function. It will be normalized into\n      // array form internally by the time shrubRpcRoutesAlter is invoked.\n      middleware: function(req, res, next) {\n\n        // Get the TODO list items, sorted by when they were created.\n        TodoListItem.find().sort('createdAt DESC').then(function(items) {\n\n          // Send the client the items.\n          res.end(items);\n        });\n      }\n    });\n\n\n\n\n\nNext, the route when an item is to be created.\n\n\n\n    // This route will be hit when a client wants to create a new item.\n    routes.push({\n      path: 'todo-list-item/create',\n\n      // Route middleware can also be defined as an array. In this route, we\n      // will handle validation before the main creation function is invoked.\n      middleware: [\n\n        // Validator. If next(error) is called here, the main creation function\n        // will never be invoked.\n        function(req, res, next) {\n\n          // Text must not be empty.\n          if (!req.body.text) {\n\n            // Passing an error to next will return it to the client.\n            return next(new Error(\"Item text must not be empty!\"));\n          }\n\n          // Continue on normally to the next middleware function.\n          next();\n        },\n\n        // Create an item.\n        function(req, res, next) {\n\n          var item = {text: req.body.text};\n\n          TodoListItem.create(item).then(function(item) {\n\n\n\n\n\nHere we work around a quirk in Waterline: when sending any models over the wire\nto the client, the \ntoJSON\n method must be stripped out of the model, or else\nthe message won't be sent and a nasty exception will be raised.\n\n\n\n            // Work around waterline weirdness. You must remove the toJSON\n            // method from all models returned from Waterline before sending\n            // over a socket to prevent a stack overflow, because\n            // model.toJSON() returns an object that also has a toJSON method,\n            // and msgpack (used by socket.io) will recur until stack space\n            // is exhausted.\n            item.toJSON = undefined;\n\n            // Send the client the new item.\n            res.end(item);\n\n            // Notify other clients of the creation.\n            req.socket.broadcast.to('$global').emit(\n              'todo-list-item/create', item\n            );\n          }).catch(next);\n        }\n      ]\n    });\n\n\n\n\n\nWhen an item is to be updated.\n\n\n\n    // This route will be hit when a client wants to update an item.\n    routes.push({\n      path: 'todo-list-item/update',\n      middleware: [\n\n        // Validator.\n        function(req, res, next) {\n\n          // ID must be set.\n          if (!req.body.id) {\n            return next(new Error(\"ID must be supplied when updating a TODO item!\"));\n          }\n\n          // Either text or isCompleted must be set.\n          if (!req.body.text && !req.body.isCompleted) {\n            return next(new Error(\"Item text or isCompleted must be set when updating a TODO item!\"));\n          }\n\n          next();\n        },\n\n        // Update an item.\n        function(req, res, next) {\n\n          // Update the item with the values in the request body.\n          TodoListItem.update({id: req.body.id}, req.body).then(function(items) {\n            items[0].toJSON = undefined;\n\n            // Send the client the updated item.\n            res.end(items[0]);\n\n            // Notify other clients of the update.\n            req.socket.broadcast.to('$global').emit(\n              'todo-list-item/update', items[0]\n            );\n          }).catch(next);\n        }\n      ]\n    });\n\n\n\n\n\nFinally, when an item is to be deleted.\n\n\n\n    // This route will be hit when a client wants to delete an item.\n    routes.push({\n      path: 'todo-list-item/delete',\n      middleware: [\n\n        // Validator.\n        function(req, res, next) {\n\n          // ID must be set.\n          if (!req.body.id) {\n            return next(new Error(\"ID must be supplied when deleting a TODO item!\"));\n          }\n\n          next();\n        },\n\n        // Delete an item.\n        function(req, res, next) {\n\n          // Destroy by ID.\n          TodoListItem.destroy({id: req.body.id}).then(function() {\n\n            // Finish the request.\n            res.end();\n\n            // Notify other clients of the deletion.\n            req.socket.broadcast.to('$global').emit(\n              'todo-list-item/delete', {id: req.body.id}\n            );\n          }).catch(next);\n        }\n      ]\n    });\n\n    return routes;\n  });\n};\n\n\n\n\nThat's it for the server code.\n\n\nclient/index.js\n\n\nNext, we'll go over the client code. Let's start with client/index.js.\n\n\nAs before, we register with the package manager.\n\n\n\nexports.pkgmanRegister = function(registrar) {\n\n\n\n\n\nSimilar to the server, we define routes on the client. These are called\nAngular routes and they represent the paths that a user can visit in their\nbrowser. We create a path for /todo and specify the template HTML to render.\n\n\n\n  // Define a route in our Angular app for the TODO list.\n  registrar.registerHook('shrubAngularRoutes', function() {\n    var routes = [];\n\n    // This is our main /todo path.\n    routes.push({\n      path: 'todo',\n\n      // The window title shown for this path.\n      title: 'TODO',\n\n      // Show our top-level directives. Directive names default to reflect the\n      // package structure, with the 'client' path removed and all non-word\n      // characters converted to dashes. So the directive defined at\n      // todo-list/client/list.js will default to todo-list-list, and the\n      // directive defined at todo-list/client/new.js will default to\n      // todo-list-new.\n      //\n      // We prepend the data- prefix to all custom attributes as a best\n      // practice -- though it isn't strictly necessary, it ensures the HTML\n      // is valid.\n      template: '                       \\\n        <div data-todo-list-list></div> \\\n        <div data-todo-list-new></div>  \\\n      '\n    });\n\n    return routes;\n  });\n\n\n\n\n\nShrub lets us write code for angular without having to worry about boilerplate.\nWe're now going to implement an Angular service to manage our TODO list.\n\n\n\n  // Define a service to manage our TODO list. Service names are derived from\n  // the path, similar to directives  (explained above). The difference is,\n  // slashes are not removed from the service name. In other words, a package\n  // with a structure like some-package/client/system/things.js would provide\n  // a service named some-package/system/things\n  registrar.registerHook('shrubAngularService', function() {\n\n    // We return an annotated function, just like if we were using Angular\n    // directly. In this case we are using array notation.\n    return [\n\n      // We communicate with the server over RPC.\n      'shrub-rpc',\n\n      function(rpc) {\n\n        var service = {\n\n          // The array of TODO items.\n          items: []\n        };\n\n\n\n\n\nImplement the service's methods.\n\n\n\n        // Create a TODO item.\n        service.create = function(text) {\n\n          // RPC calls return a promise.\n          rpc.call('todo-list-item/create', {text: text}).then(function(item) {\n            service.items.push(item);\n          });\n        };\n\n        // Update a TODO item.\n        service.update = function(item) {\n          rpc.call('todo-list-item/update', item).then(function(updated) {\n            item.text = updated.text;\n            item.isCompleted = updated.isCompleted;\n          });\n        };\n\n        // Delete a TODO item.\n        service.delete = function(item) {\n          rpc.call('todo-list-item/delete', {id: item.id}).then(function() {\n            var index = service.items.indexOf(item);\n            if (~index) service.items.splice(index, 1);\n          });\n        };\n\n\n\n\n\nSet up event listeners. The server will communicate with us to let us know when\nother clients have created, updated, or deleted TODO items.\n\n\n\n        // Server told us to create an item.\n        rpc.on('todo-list-item/create', function(item) {\n          service.items.push(item);\n        });\n\n        // Server told us to update an item.\n        rpc.on('todo-list-item/update', function(item) {\n          for (var i in service.items) {\n            if (item.id === service.items[i].id) {\n              service.items[i].text = item.text;\n              service.items[i].isCompleted = item.isCompleted;\n            }\n          }\n        });\n\n        // Server told us to delete an item.\n        rpc.on('todo-list-item/delete', function(item) {\n          for (var i in service.items) {\n            if (item.id === service.items[i].id) {\n              return service.items.splice(i, 1);\n            }\n          }\n        });\n\n\n\n\n\nFinally, we will load all the TODO items from the server when the service is\nfirst instantiated. In other words, when the user visits /todo for the first\ntime.\n\n\n\n        // Immediately retrieve the TODO items and populate the list.\n        rpc.call('todo-list').then(function(items) {\n          items.forEach(function(item) {\n            service.items.push(item);\n          });\n        });\n\n        return service;\n      }\n    ];\n  });\n\n\n\n\n\nThe following is not ideal, however Shrub has yet to implement a menu API. This\nis a temporary situation where we need to hook directly into the skin's\nnavigation directive link function and add our route to the navigation menu.\n\n\nI know it's ugly and there will be a menu API that is skin-agnostic eventually.\n\n\n\n  // Hook into the main navigation and add our path. This is admittedly not\n  // ideal, in lieu of a proper menu API.\n  registrar.registerHook('shrubSkinLink--shrubSkinStrappedMainNav', function() {\n    return [\n      '$scope', function($scope) {\n        $scope.menu.items.push({path: 'todo', label: 'TODO'})\n      }\n    ];\n  });\n\n\n\n\n\nOur first encounter with \nregistrar.recur\n. By default, Shrub does not\ntraverse all files in your package for inclusion as this is inefficient and\nremoves your decision whether some files should be included and some not.\n\n\nTo notify the package manager which other files should be included, use\n\nregistrar.recur\n. In this case we will be including all other files in the\nclient directory.\n\n\n\n  // Recur into subpackages.\n  registrar.recur([\n    'item', 'list', 'new'\n  ]);\n};\n\n\n\n\nclient/item.js\n\n\nMoving on to client/item.js, the file that manages the display of an individual\nTODO item. This is where the meat of the user interaction occurs.\n\n\n\nexports.pkgmanRegister = function(registrar) {\n\n\n\n\n\nJust as with services, we can define Angular directives. We define one to show\na TODO item.\n\n\n\n  // Define a directive to display a TODO item. This is where most of the user\n  // interaction occurs.\n  registrar.registerHook('shrubAngularDirective', function() {\n\n    return [\n\n      // Inject the window object so we can focus the input when editing.\n      '$window',\n\n      // Inject our TODO list service.\n      'todo-list',\n\n      function ($window, todoList) {\n\n        var directive = {};\n\n\n\n\n\nAlthough Shrub augments directives with additional functionality, the\ndefinition object is the same one you know and love. Here we set the scope\nand link function just as in Angular directly.\n\n\n\n        // Require an item to be passed in.\n        directive.scope = {\n          item: '='\n        };\n\n        // Define link function just how you would in Angular directly.\n        directive.link = function(scope) {\n\n          // Keep track of the original text value when editing, to check\n          // whether we need to update the server or not.\n          var originalText = '';\n\n\n\n\n\nHere we use the form API to create the form for viewing an item.\n\n\n\n          // The form displayed when the user is viewing a TODO item.\n          scope.viewingForm = {\n\n            // Store the item in the form so fields can access it.\n            item: scope.item,\n\n            // The fields object defines all the form fields for this form.\n            // By default, the fields' names are derived from the key, unless\n            // explicitly overridden.\n            fields: {\n\n              // The TODO item text. This is a markup field, its value is\n              // markup which goes through Angular's $compile and is linked\n              // against the field scope.\n              text: {\n                type: 'markup',\n\n                // Keep a style object in the field for applying dynamic CSS.\n                style: {},\n\n                // Bind the markup to the TODO item's text field, and apply\n                // styles based on our style object (above).\n                value: '                          \\\n                  <span                           \\\n                    data-ng-bind=\"form.item.text\" \\\n                    data-ng-style=\"field.style\"   \\\n                  ></span>                        \\\n                ',\n              },\n\n              // Below each TODO item text are actions to manipulate the item.\n              // This is a group field, meaning all fields under this field\n              // will be displayed inline.\n              actions: {\n                type: 'group',\n                fields: {\n\n                  // Submit button to edit the TODO item.\n                  edit: {\n                    type: 'submit',\n                    value: 'Edit'\n                  },\n\n                  // Submit button to delete the TODO item.\n                  'delete': {\n                    type: 'submit',\n                    value: 'Delete'\n                  },\n\n                  // A checkbox displaying and controlling whether the TODO\n                  // item has been completed.\n                  isCompleted: {\n                    type: 'checkbox',\n                    label: 'Completed',\n\n                    // Link its value directly to the TODO item's isCompleted\n                    // property.\n                    model: 'form.item.isCompleted',\n\n                    // This function is invoked when the field's value changes.\n                    // By the time change() is called, the scope digest is\n                    // completed, so the value will be propagated to the model.\n                    change: function(isCompleted) {\n                      todoList.update(scope.item);\n                    }\n                  }\n                }\n              }\n            },\n\n            // Form submission function. submits can be an array as well, with\n            // each function being invoked upon form submission. Internally\n            // it will always be normalized to an array before invoking\n            // shrubFormAlter.\n            submits: function(values, form) {\n\n              // The special value form.$submitted will be populated with the\n              // field that stimulated the submission. In other words, if you\n              // click 'edit', form.$submitted will be the edit button's field\n              // instance.\n              switch (form.$submitted.name) {\n\n                // User wants to edit the item. Change the editing state.\n                case 'edit':\n                  scope.isEditing = true;\n                  break;\n\n                // User wants to delete the TODO item. Just do it.\n                case 'delete':\n                  todoList.delete(scope.item);\n                  break;\n              }\n            }\n          };\n\n\n\n\n\nWe create a form for editing an item.\n\n\n\n          // The form displayed when the user is editing a TODO item.\n          scope.editingForm = {\n            item: scope.item,\n            fields: {\n\n              // A textfield where the user will type in the updated item text.\n              text: {\n                type: 'text',\n                label: 'Update',\n\n                // Link its value directly to the item text.\n                model: 'form.item.text',\n\n                // You can specify arbitrary HTML attributes. In this case, we\n                // will set a unique ID for each item's text field, so we can\n                // target it for focus when initiating the edit process for an\n                // item.\n                attributes: {\n                  id: 'edit-text-' + scope.item.id\n                }\n              },\n\n              // Submit button for updating the item once editing is complete.\n              update: {\n                type: 'submit',\n                value: 'Update'\n              },\n            },\n\n            // Here we use the array form for submits just to prove that it can\n            // be done.\n            submits: [\n\n              // Values is an object which has field names as keys and field\n              // values as values.\n              function(values) {\n\n                // Check the new item text against the original text. If it\n                // changed, update the item.\n                if (values.text !== originalText) {\n                  todoList.update(scope.item);\n                }\n\n                // Change the editing state.\n                scope.isEditing = false;\n              }\n            ]\n          };\n\n\n\n\n\nEverything inside the link function is as you would expect, the scope is\nAngular's scope object, so we can do everything we're used to, like watching\nfor changes.\n\n\n\n          // Watch the editing state for changes.\n          scope.$watch('isEditing', function (isEditing) {\n\n            // We only care if we're editing.\n            if (!isEditing) return;\n\n            // Remember the item's original text.\n            originalText = scope.item.text;\n\n            // The moment isEditing updates, the DOM won't be fully\n            // transformed, meaning the edit form will not be visible yet.\n            //\n            // scope.$$postDigest is a little Angular hack that lets you\n            // register a function to run after the scope digest cycle is\n            // completed. This is exactly what we have to wait for to ensure\n            // that the DOM is mutated and the edit form is visible.\n            scope.$$postDigest(function() {\n\n              // Look up our edit control and focus/select the text\n              // automatically.\n              $window.document.getElementById(\n                'edit-text-' + scope.item.id\n              ).select();\n            });\n          });\n\n          // Watch the item's isCompleted property.\n          scope.$watch('item.isCompleted', function (isCompleted) {\n\n            // Make the text really big. We could of course use CSS to do this\n            // and should, but this is just a demo and I'm lazy.\n            var style = {'font-size': '30px'};\n\n            // If the item was completed, strike a line through the text.\n            if (isCompleted) {\n              style['text-decoration'] = 'line-through';\n            }\n\n            // Set the style into the form field's style object.\n            scope.viewingForm.fields.text.style = style;\n          });\n        };\n\n\n\n\n\nWe define the output HTML for our directive, switching between the two forms\nbased on the state of \nisEditing\n.\n\n\n\n        // We control which form is showing by using the ngIf directive. Forms\n        // are displayed with the shrub-form directive, and the form definition\n        // object is passed in through the form attribute on each directive.\n        directive.template = '        \\\n          <div                        \\\n            data-ng-if=\"!isEditing\"   \\\n          >                           \\\n            <div                      \\\n              data-shrub-form         \\\n              data-form=\"viewingForm\" \\\n            ></div>                   \\\n          </div>                      \\\n          <div                        \\\n            data-ng-if=\"isEditing\"    \\\n          >                           \\\n            <div                      \\\n              data-shrub-form         \\\n              data-form=\"editingForm\" \\\n            ></div>                   \\\n          </div>                      \\\n        ';\n\n        return directive;\n      }\n    ];\n  });\n};\n\n\n\n\nclient/list.js\n\n\nNext we will look at client/list.js, where we will define a directive that\nwraps the TODO list and renders a list of items. This one is pretty simple.\n\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubAngularDirective', function() {\n\n    return [\n\n      'todo-list',\n\n      function(todoList) {\n\n        var directive = {};\n\n        directive.scope = {};\n\n        // Make the TODO list accessible to our directive.\n        directive.link = function(scope) {\n          scope.todoList = todoList;\n        };\n\n        // Use the TODO list items to build an unordered list. Each list item\n        // receives the corresponding TODO item.\n        directive.template = '                                       \\\n          <ul                                                        \\\n            data-ng-repeat=\"item in todoList.items track by item.id\" \\\n          >                                                          \\\n            <li                                                      \\\n              data-todo-list-item                                    \\\n              data-item=\"item\"                                       \\\n            ></li>                                                   \\\n          </ul>                                                      \\\n        ';\n\n        return directive;\n      }\n\n    ];\n  });\n};\n\n\n\n\nclient/new.js\n\n\nFinally, we'll define the directive for creating a new TODO item. Everything\nhere is rehashing concepts we have reviewed earlier, so it should be easy to\nfollow.\n\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubAngularDirective', function() {\n\n    return [\n\n      'todo-list',\n\n      function(todoList) {\n\n        var directive = {};\n\n        directive.scope = {};\n\n        directive.link = function(scope) {\n\n          // The form to add a new item.\n          scope.form = {\n            fields: {\n              group: {\n                type: 'group',\n                fields: {\n\n                  // The textfield for the new item's text.\n                  text: {\n                    type: 'text',\n                    label: 'Create a new TODO item'\n                  },\n\n                  // Submit button to create the item.\n                  submit: {\n                    type: 'submit',\n                    value: 'Create new item'\n                  }\n                }\n              }\n            },\n            submits: function (values, form) {\n\n              // Create the TODO item.\n              todoList.create(values.text);\n\n              // Blank out the text field.\n              form.fields.group.fields.text.value = '';\n            }\n          };\n        };\n\n        directive.template = ' \\\n          <div                 \\\n            data-shrub-form    \\\n            data-form=\"form\"   \\\n          ></div>              \\\n        '\n\n        return directive;\n      }\n\n    ];\n  });\n};\n\n\n\n\nExecutive summary\n\n\nIf you'd rather not type or copy/paste all the code here manually, a repository\ncontaining the TODO list package can be found at\n\nhttps://github.com/cha0s/shrub-todo-list\n.\n\n\nClone the repository\n\n\nYou may clone it into the \ncustom\n directory like so:\n\n\ncd YOUR_SHRUB_DIRECTORY/custom\ngit clone https://github.com/cha0s/shrub-todo-list.git todo-list\n\n\n\n\nAdd the package to the configuration settings.\n\n\nAfter you do so, edit config/settings.json like so:\n\n\n...\n    \"shrub-user\",\n    \"shrub-villiany\",\n    \"todo-list\"\n  ],\n  \"packageSettings\": {\n...\n\n\n\n\nSpin it up\n\n\nYou're good to go now, just the usual rigamarole for running in development\nmode:\n\n\nDEBUG=shrub:* grunt execute\n\n\n\n\nEnjoy!",
            "title": "TODO list app"
        },
        {
            "location": "/examples/todo-list/#create-the-package",
            "text": "The TODO list will be implemented as a Shrub package. This means we're going to\ncreate a package and enable it.  Your Shrub installation includes a  custom  directory. Within it we will create\nour TODO package. Create a directory and file structure like this:  YOUR_SHRUB_DIRECTORY/custom/todo-list/index.js\nYOUR_SHRUB_DIRECTORY/custom/todo-list/client/index.js\nYOUR_SHRUB_DIRECTORY/custom/todo-list/client/item.js\nYOUR_SHRUB_DIRECTORY/custom/todo-list/client/list.js\nYOUR_SHRUB_DIRECTORY/custom/todo-list/client/new.js  We'll go through one at a time and talk about what goes in these files. I will\nMostly show the source code, punctuated by commentary when necessary.",
            "title": "Create the package"
        },
        {
            "location": "/examples/todo-list/#indexjs",
            "text": "Lets start with the top-level index.js file. This is the code that will run on\nthe server. In fact, everything except files in the  client  directory are only\navailable on the server. The  client  directory is available to the server as\nwell, but the reverse doesn't apply:  the client has no access to anything\noutside the  client  directory.  First off, we'll start with the package manager's entry point. This is defined\nfor every package file which implements hooks.  \n// Entry point for package management. Every package defining hooks does so\n// through the registrar passed to `exports.pkgmanRegister`.\nexports.pkgmanRegister = function(registrar) {  pkgman  will pass in a registrar which is used to register hooks and point to\nsubpackage files. More on the latter to come.  Let's implement a model that will represent our TODO list items. See the documentation for  shrubOrmCollections \nfor details.  \n  // Implements hook `shrubOrmCollections`.\n  registrar.registerHook('shrubOrmCollections', function() {\n\n    // Return an object whose keys determine the name of the collection in the\n    // system, and whose values are Waterline configuration.\n    return {\n\n      // We're only defining a TODO list item model since we only have one\n      // global list in this example. It'd be possible to create a `todo-list`\n      // model and associate the `todo-list-item`s with it, but we opt for\n      // simplicity.\n      'todo-list-item': {\n\n        attributes: {\n\n          // Whether the item is marked as completed.\n          isCompleted: {\n            type: 'boolean',\n            defaultsTo: false\n          },\n\n          // The item text, e.g. \"Make a TODO example for Shrub\".\n          text: {\n            type: 'string'\n          }\n        }\n      }\n    };\n  });  This registers a model named  todo-list-item  in the ORM so we can create,\nread, update, and delete instances.  Finally, we'll create some RPC routes. These are the endpoints that the client\ncommunicates with. We'll create RPC routes for retrieving all TODO items,\ncreating an item, updating an item, and deleting an item.  \n  // Implements hook `shrubRpcRoutes`.\n  registrar.registerHook('shrubRpcRoutes', function() {\n\n    var routes = [];\n\n    // Get our collection.\n    var TodoListItem = require('shrub-orm').collection('todo-list-item');  First, the route to retrieve all items.  \n    // This route will be hit when a client first connects, to give them a\n    // snapshot of the current TODO list.\n    routes.push({\n      path: 'todo-list',\n\n      // Route middleware can be a single function. It will be normalized into\n      // array form internally by the time shrubRpcRoutesAlter is invoked.\n      middleware: function(req, res, next) {\n\n        // Get the TODO list items, sorted by when they were created.\n        TodoListItem.find().sort('createdAt DESC').then(function(items) {\n\n          // Send the client the items.\n          res.end(items);\n        });\n      }\n    });  Next, the route when an item is to be created.  \n    // This route will be hit when a client wants to create a new item.\n    routes.push({\n      path: 'todo-list-item/create',\n\n      // Route middleware can also be defined as an array. In this route, we\n      // will handle validation before the main creation function is invoked.\n      middleware: [\n\n        // Validator. If next(error) is called here, the main creation function\n        // will never be invoked.\n        function(req, res, next) {\n\n          // Text must not be empty.\n          if (!req.body.text) {\n\n            // Passing an error to next will return it to the client.\n            return next(new Error(\"Item text must not be empty!\"));\n          }\n\n          // Continue on normally to the next middleware function.\n          next();\n        },\n\n        // Create an item.\n        function(req, res, next) {\n\n          var item = {text: req.body.text};\n\n          TodoListItem.create(item).then(function(item) {  Here we work around a quirk in Waterline: when sending any models over the wire\nto the client, the  toJSON  method must be stripped out of the model, or else\nthe message won't be sent and a nasty exception will be raised.  \n            // Work around waterline weirdness. You must remove the toJSON\n            // method from all models returned from Waterline before sending\n            // over a socket to prevent a stack overflow, because\n            // model.toJSON() returns an object that also has a toJSON method,\n            // and msgpack (used by socket.io) will recur until stack space\n            // is exhausted.\n            item.toJSON = undefined;\n\n            // Send the client the new item.\n            res.end(item);\n\n            // Notify other clients of the creation.\n            req.socket.broadcast.to('$global').emit(\n              'todo-list-item/create', item\n            );\n          }).catch(next);\n        }\n      ]\n    });  When an item is to be updated.  \n    // This route will be hit when a client wants to update an item.\n    routes.push({\n      path: 'todo-list-item/update',\n      middleware: [\n\n        // Validator.\n        function(req, res, next) {\n\n          // ID must be set.\n          if (!req.body.id) {\n            return next(new Error(\"ID must be supplied when updating a TODO item!\"));\n          }\n\n          // Either text or isCompleted must be set.\n          if (!req.body.text && !req.body.isCompleted) {\n            return next(new Error(\"Item text or isCompleted must be set when updating a TODO item!\"));\n          }\n\n          next();\n        },\n\n        // Update an item.\n        function(req, res, next) {\n\n          // Update the item with the values in the request body.\n          TodoListItem.update({id: req.body.id}, req.body).then(function(items) {\n            items[0].toJSON = undefined;\n\n            // Send the client the updated item.\n            res.end(items[0]);\n\n            // Notify other clients of the update.\n            req.socket.broadcast.to('$global').emit(\n              'todo-list-item/update', items[0]\n            );\n          }).catch(next);\n        }\n      ]\n    });  Finally, when an item is to be deleted.  \n    // This route will be hit when a client wants to delete an item.\n    routes.push({\n      path: 'todo-list-item/delete',\n      middleware: [\n\n        // Validator.\n        function(req, res, next) {\n\n          // ID must be set.\n          if (!req.body.id) {\n            return next(new Error(\"ID must be supplied when deleting a TODO item!\"));\n          }\n\n          next();\n        },\n\n        // Delete an item.\n        function(req, res, next) {\n\n          // Destroy by ID.\n          TodoListItem.destroy({id: req.body.id}).then(function() {\n\n            // Finish the request.\n            res.end();\n\n            // Notify other clients of the deletion.\n            req.socket.broadcast.to('$global').emit(\n              'todo-list-item/delete', {id: req.body.id}\n            );\n          }).catch(next);\n        }\n      ]\n    });\n\n    return routes;\n  });\n};  That's it for the server code.",
            "title": "index.js"
        },
        {
            "location": "/examples/todo-list/#clientindexjs",
            "text": "Next, we'll go over the client code. Let's start with client/index.js.  As before, we register with the package manager.  \nexports.pkgmanRegister = function(registrar) {  Similar to the server, we define routes on the client. These are called\nAngular routes and they represent the paths that a user can visit in their\nbrowser. We create a path for /todo and specify the template HTML to render.  \n  // Define a route in our Angular app for the TODO list.\n  registrar.registerHook('shrubAngularRoutes', function() {\n    var routes = [];\n\n    // This is our main /todo path.\n    routes.push({\n      path: 'todo',\n\n      // The window title shown for this path.\n      title: 'TODO',\n\n      // Show our top-level directives. Directive names default to reflect the\n      // package structure, with the 'client' path removed and all non-word\n      // characters converted to dashes. So the directive defined at\n      // todo-list/client/list.js will default to todo-list-list, and the\n      // directive defined at todo-list/client/new.js will default to\n      // todo-list-new.\n      //\n      // We prepend the data- prefix to all custom attributes as a best\n      // practice -- though it isn't strictly necessary, it ensures the HTML\n      // is valid.\n      template: '                       \\\n        <div data-todo-list-list></div> \\\n        <div data-todo-list-new></div>  \\\n      '\n    });\n\n    return routes;\n  });  Shrub lets us write code for angular without having to worry about boilerplate.\nWe're now going to implement an Angular service to manage our TODO list.  \n  // Define a service to manage our TODO list. Service names are derived from\n  // the path, similar to directives  (explained above). The difference is,\n  // slashes are not removed from the service name. In other words, a package\n  // with a structure like some-package/client/system/things.js would provide\n  // a service named some-package/system/things\n  registrar.registerHook('shrubAngularService', function() {\n\n    // We return an annotated function, just like if we were using Angular\n    // directly. In this case we are using array notation.\n    return [\n\n      // We communicate with the server over RPC.\n      'shrub-rpc',\n\n      function(rpc) {\n\n        var service = {\n\n          // The array of TODO items.\n          items: []\n        };  Implement the service's methods.  \n        // Create a TODO item.\n        service.create = function(text) {\n\n          // RPC calls return a promise.\n          rpc.call('todo-list-item/create', {text: text}).then(function(item) {\n            service.items.push(item);\n          });\n        };\n\n        // Update a TODO item.\n        service.update = function(item) {\n          rpc.call('todo-list-item/update', item).then(function(updated) {\n            item.text = updated.text;\n            item.isCompleted = updated.isCompleted;\n          });\n        };\n\n        // Delete a TODO item.\n        service.delete = function(item) {\n          rpc.call('todo-list-item/delete', {id: item.id}).then(function() {\n            var index = service.items.indexOf(item);\n            if (~index) service.items.splice(index, 1);\n          });\n        };  Set up event listeners. The server will communicate with us to let us know when\nother clients have created, updated, or deleted TODO items.  \n        // Server told us to create an item.\n        rpc.on('todo-list-item/create', function(item) {\n          service.items.push(item);\n        });\n\n        // Server told us to update an item.\n        rpc.on('todo-list-item/update', function(item) {\n          for (var i in service.items) {\n            if (item.id === service.items[i].id) {\n              service.items[i].text = item.text;\n              service.items[i].isCompleted = item.isCompleted;\n            }\n          }\n        });\n\n        // Server told us to delete an item.\n        rpc.on('todo-list-item/delete', function(item) {\n          for (var i in service.items) {\n            if (item.id === service.items[i].id) {\n              return service.items.splice(i, 1);\n            }\n          }\n        });  Finally, we will load all the TODO items from the server when the service is\nfirst instantiated. In other words, when the user visits /todo for the first\ntime.  \n        // Immediately retrieve the TODO items and populate the list.\n        rpc.call('todo-list').then(function(items) {\n          items.forEach(function(item) {\n            service.items.push(item);\n          });\n        });\n\n        return service;\n      }\n    ];\n  });  The following is not ideal, however Shrub has yet to implement a menu API. This\nis a temporary situation where we need to hook directly into the skin's\nnavigation directive link function and add our route to the navigation menu.  I know it's ugly and there will be a menu API that is skin-agnostic eventually.  \n  // Hook into the main navigation and add our path. This is admittedly not\n  // ideal, in lieu of a proper menu API.\n  registrar.registerHook('shrubSkinLink--shrubSkinStrappedMainNav', function() {\n    return [\n      '$scope', function($scope) {\n        $scope.menu.items.push({path: 'todo', label: 'TODO'})\n      }\n    ];\n  });  Our first encounter with  registrar.recur . By default, Shrub does not\ntraverse all files in your package for inclusion as this is inefficient and\nremoves your decision whether some files should be included and some not.  To notify the package manager which other files should be included, use registrar.recur . In this case we will be including all other files in the\nclient directory.  \n  // Recur into subpackages.\n  registrar.recur([\n    'item', 'list', 'new'\n  ]);\n};",
            "title": "client/index.js"
        },
        {
            "location": "/examples/todo-list/#clientitemjs",
            "text": "Moving on to client/item.js, the file that manages the display of an individual\nTODO item. This is where the meat of the user interaction occurs.  \nexports.pkgmanRegister = function(registrar) {  Just as with services, we can define Angular directives. We define one to show\na TODO item.  \n  // Define a directive to display a TODO item. This is where most of the user\n  // interaction occurs.\n  registrar.registerHook('shrubAngularDirective', function() {\n\n    return [\n\n      // Inject the window object so we can focus the input when editing.\n      '$window',\n\n      // Inject our TODO list service.\n      'todo-list',\n\n      function ($window, todoList) {\n\n        var directive = {};  Although Shrub augments directives with additional functionality, the\ndefinition object is the same one you know and love. Here we set the scope\nand link function just as in Angular directly.  \n        // Require an item to be passed in.\n        directive.scope = {\n          item: '='\n        };\n\n        // Define link function just how you would in Angular directly.\n        directive.link = function(scope) {\n\n          // Keep track of the original text value when editing, to check\n          // whether we need to update the server or not.\n          var originalText = '';  Here we use the form API to create the form for viewing an item.  \n          // The form displayed when the user is viewing a TODO item.\n          scope.viewingForm = {\n\n            // Store the item in the form so fields can access it.\n            item: scope.item,\n\n            // The fields object defines all the form fields for this form.\n            // By default, the fields' names are derived from the key, unless\n            // explicitly overridden.\n            fields: {\n\n              // The TODO item text. This is a markup field, its value is\n              // markup which goes through Angular's $compile and is linked\n              // against the field scope.\n              text: {\n                type: 'markup',\n\n                // Keep a style object in the field for applying dynamic CSS.\n                style: {},\n\n                // Bind the markup to the TODO item's text field, and apply\n                // styles based on our style object (above).\n                value: '                          \\\n                  <span                           \\\n                    data-ng-bind=\"form.item.text\" \\\n                    data-ng-style=\"field.style\"   \\\n                  ></span>                        \\\n                ',\n              },\n\n              // Below each TODO item text are actions to manipulate the item.\n              // This is a group field, meaning all fields under this field\n              // will be displayed inline.\n              actions: {\n                type: 'group',\n                fields: {\n\n                  // Submit button to edit the TODO item.\n                  edit: {\n                    type: 'submit',\n                    value: 'Edit'\n                  },\n\n                  // Submit button to delete the TODO item.\n                  'delete': {\n                    type: 'submit',\n                    value: 'Delete'\n                  },\n\n                  // A checkbox displaying and controlling whether the TODO\n                  // item has been completed.\n                  isCompleted: {\n                    type: 'checkbox',\n                    label: 'Completed',\n\n                    // Link its value directly to the TODO item's isCompleted\n                    // property.\n                    model: 'form.item.isCompleted',\n\n                    // This function is invoked when the field's value changes.\n                    // By the time change() is called, the scope digest is\n                    // completed, so the value will be propagated to the model.\n                    change: function(isCompleted) {\n                      todoList.update(scope.item);\n                    }\n                  }\n                }\n              }\n            },\n\n            // Form submission function. submits can be an array as well, with\n            // each function being invoked upon form submission. Internally\n            // it will always be normalized to an array before invoking\n            // shrubFormAlter.\n            submits: function(values, form) {\n\n              // The special value form.$submitted will be populated with the\n              // field that stimulated the submission. In other words, if you\n              // click 'edit', form.$submitted will be the edit button's field\n              // instance.\n              switch (form.$submitted.name) {\n\n                // User wants to edit the item. Change the editing state.\n                case 'edit':\n                  scope.isEditing = true;\n                  break;\n\n                // User wants to delete the TODO item. Just do it.\n                case 'delete':\n                  todoList.delete(scope.item);\n                  break;\n              }\n            }\n          };  We create a form for editing an item.  \n          // The form displayed when the user is editing a TODO item.\n          scope.editingForm = {\n            item: scope.item,\n            fields: {\n\n              // A textfield where the user will type in the updated item text.\n              text: {\n                type: 'text',\n                label: 'Update',\n\n                // Link its value directly to the item text.\n                model: 'form.item.text',\n\n                // You can specify arbitrary HTML attributes. In this case, we\n                // will set a unique ID for each item's text field, so we can\n                // target it for focus when initiating the edit process for an\n                // item.\n                attributes: {\n                  id: 'edit-text-' + scope.item.id\n                }\n              },\n\n              // Submit button for updating the item once editing is complete.\n              update: {\n                type: 'submit',\n                value: 'Update'\n              },\n            },\n\n            // Here we use the array form for submits just to prove that it can\n            // be done.\n            submits: [\n\n              // Values is an object which has field names as keys and field\n              // values as values.\n              function(values) {\n\n                // Check the new item text against the original text. If it\n                // changed, update the item.\n                if (values.text !== originalText) {\n                  todoList.update(scope.item);\n                }\n\n                // Change the editing state.\n                scope.isEditing = false;\n              }\n            ]\n          };  Everything inside the link function is as you would expect, the scope is\nAngular's scope object, so we can do everything we're used to, like watching\nfor changes.  \n          // Watch the editing state for changes.\n          scope.$watch('isEditing', function (isEditing) {\n\n            // We only care if we're editing.\n            if (!isEditing) return;\n\n            // Remember the item's original text.\n            originalText = scope.item.text;\n\n            // The moment isEditing updates, the DOM won't be fully\n            // transformed, meaning the edit form will not be visible yet.\n            //\n            // scope.$$postDigest is a little Angular hack that lets you\n            // register a function to run after the scope digest cycle is\n            // completed. This is exactly what we have to wait for to ensure\n            // that the DOM is mutated and the edit form is visible.\n            scope.$$postDigest(function() {\n\n              // Look up our edit control and focus/select the text\n              // automatically.\n              $window.document.getElementById(\n                'edit-text-' + scope.item.id\n              ).select();\n            });\n          });\n\n          // Watch the item's isCompleted property.\n          scope.$watch('item.isCompleted', function (isCompleted) {\n\n            // Make the text really big. We could of course use CSS to do this\n            // and should, but this is just a demo and I'm lazy.\n            var style = {'font-size': '30px'};\n\n            // If the item was completed, strike a line through the text.\n            if (isCompleted) {\n              style['text-decoration'] = 'line-through';\n            }\n\n            // Set the style into the form field's style object.\n            scope.viewingForm.fields.text.style = style;\n          });\n        };  We define the output HTML for our directive, switching between the two forms\nbased on the state of  isEditing .  \n        // We control which form is showing by using the ngIf directive. Forms\n        // are displayed with the shrub-form directive, and the form definition\n        // object is passed in through the form attribute on each directive.\n        directive.template = '        \\\n          <div                        \\\n            data-ng-if=\"!isEditing\"   \\\n          >                           \\\n            <div                      \\\n              data-shrub-form         \\\n              data-form=\"viewingForm\" \\\n            ></div>                   \\\n          </div>                      \\\n          <div                        \\\n            data-ng-if=\"isEditing\"    \\\n          >                           \\\n            <div                      \\\n              data-shrub-form         \\\n              data-form=\"editingForm\" \\\n            ></div>                   \\\n          </div>                      \\\n        ';\n\n        return directive;\n      }\n    ];\n  });\n};",
            "title": "client/item.js"
        },
        {
            "location": "/examples/todo-list/#clientlistjs",
            "text": "Next we will look at client/list.js, where we will define a directive that\nwraps the TODO list and renders a list of items. This one is pretty simple.  \nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubAngularDirective', function() {\n\n    return [\n\n      'todo-list',\n\n      function(todoList) {\n\n        var directive = {};\n\n        directive.scope = {};\n\n        // Make the TODO list accessible to our directive.\n        directive.link = function(scope) {\n          scope.todoList = todoList;\n        };\n\n        // Use the TODO list items to build an unordered list. Each list item\n        // receives the corresponding TODO item.\n        directive.template = '                                       \\\n          <ul                                                        \\\n            data-ng-repeat=\"item in todoList.items track by item.id\" \\\n          >                                                          \\\n            <li                                                      \\\n              data-todo-list-item                                    \\\n              data-item=\"item\"                                       \\\n            ></li>                                                   \\\n          </ul>                                                      \\\n        ';\n\n        return directive;\n      }\n\n    ];\n  });\n};",
            "title": "client/list.js"
        },
        {
            "location": "/examples/todo-list/#clientnewjs",
            "text": "Finally, we'll define the directive for creating a new TODO item. Everything\nhere is rehashing concepts we have reviewed earlier, so it should be easy to\nfollow.  \nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubAngularDirective', function() {\n\n    return [\n\n      'todo-list',\n\n      function(todoList) {\n\n        var directive = {};\n\n        directive.scope = {};\n\n        directive.link = function(scope) {\n\n          // The form to add a new item.\n          scope.form = {\n            fields: {\n              group: {\n                type: 'group',\n                fields: {\n\n                  // The textfield for the new item's text.\n                  text: {\n                    type: 'text',\n                    label: 'Create a new TODO item'\n                  },\n\n                  // Submit button to create the item.\n                  submit: {\n                    type: 'submit',\n                    value: 'Create new item'\n                  }\n                }\n              }\n            },\n            submits: function (values, form) {\n\n              // Create the TODO item.\n              todoList.create(values.text);\n\n              // Blank out the text field.\n              form.fields.group.fields.text.value = '';\n            }\n          };\n        };\n\n        directive.template = ' \\\n          <div                 \\\n            data-shrub-form    \\\n            data-form=\"form\"   \\\n          ></div>              \\\n        '\n\n        return directive;\n      }\n\n    ];\n  });\n};",
            "title": "client/new.js"
        },
        {
            "location": "/examples/todo-list/#executive-summary",
            "text": "If you'd rather not type or copy/paste all the code here manually, a repository\ncontaining the TODO list package can be found at https://github.com/cha0s/shrub-todo-list .",
            "title": "Executive summary"
        },
        {
            "location": "/examples/todo-list/#clone-the-repository",
            "text": "You may clone it into the  custom  directory like so:  cd YOUR_SHRUB_DIRECTORY/custom\ngit clone https://github.com/cha0s/shrub-todo-list.git todo-list",
            "title": "Clone the repository"
        },
        {
            "location": "/examples/todo-list/#add-the-package-to-the-configuration-settings",
            "text": "After you do so, edit config/settings.json like so:  ...\n    \"shrub-user\",\n    \"shrub-villiany\",\n    \"todo-list\"\n  ],\n  \"packageSettings\": {\n...",
            "title": "Add the package to the configuration settings."
        },
        {
            "location": "/examples/todo-list/#spin-it-up",
            "text": "You're good to go now, just the usual rigamarole for running in development\nmode:  DEBUG=shrub:* grunt execute  Enjoy!",
            "title": "Spin it up"
        },
        {
            "location": "/hooks/",
            "text": "Hook reference\n\n\n\nshrubAngularAHrefSanitizationWhitelist\n\n\nAllow packages to define whitelisted patterns for ngHref attributes.\n\n\nBy default, Angular filters 'unsafe' URLs passed to the ngHref attribute. This\nbehavior is normally configured through\n\n$compileProvider.aHrefSanitizationWhitelist\n\nso Shrub provides this hook to make it easy to add your own whitelisted\npatterns.\n\n\nImplementations of this hook should return an array of strings. The strings\nare compiled into a regular expression which determines whether the href is\nallowed or not. For instance, \nshrub-angular\n provides two patterns by default:\n\n\n'(?:https?|ftp|mailto|tel|file):'\n\n\nwhich allows the usage of http, https, ftp mailto, tel, and file\nprotocols, and\n\n\n'javascript:void\\\\(0\\\\)'\n\n\nwhich allows the usage of \njavascript:void(0)\n as an href.\n\n\nShrub combines all patterns into a regular expression and automatically\nenforces that the pattern will occur at the beginning of the string. For\nexample, if we have two patterns, like:\n\n\n['foo', 'bar']\n\n\nthe resulting regular expression will be equivalent to:\n\n\n/^\\s*(?:foo|bar)/\n\n\nThis hook should be used sparingly, as the reason there is a whitelist in the\nfirst place is because there are security implications to allowing just any\nhref in a dynamic directive. \nUse caution\n.\n\n\nImplementations must return\n\n\n\nAn array of strings to be compiled into a regular expression.\n\n\n1 implementation\n\n  \n\n    \nshrub-angular (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-angular (client)\ninvocation\n  \n\n\n\n\n\nshrubAngularAppConfig\n\n\nAllow packages to hook into the configuration phase of the Angular\napplication.\n\n\nPackages should implement this hook when they need to run code during the\nAngular module configuration phase. See the\n\nAngular documentation\n\non \nConfiguration blocks\n for more explanation.\n\n\nImplementations must return\n\n\n\nAn \nannotated function\n.\n\n\n4 implementations\n\n  \n\n    \nshrub-angular (client)\nimplementation\n    \nshrub-example/home (client)\nimplementation\n    \nshrub-html5-local-storage (client)\nimplementation\n    \nshrub-html5-notification (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \napp (client)\ninvocation\n  \n\n\n\n\n\nshrubAngularAppRun\n\n\nAllow packages to hook into the run phase of the Angular application.\n\n\nPackages should implement this hook when they need to run code during the\nAngular module run phase. See the\n\nAngular documentation\n\non \nRun blocks\n for more explanation.\n\n\nImplementations must return\n\n\n\nAn \nannotated function\n.\n\n\n4 implementations\n\n  \n\n    \nshrub-angular-sandbox (client)\nimplementation\n    \nshrub-core (client)\nimplementation\n    \nshrub-ui/messages (client)\nimplementation\n    \nshrub-ui/window-title (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \napp (client)\ninvocation\n  \n\n\n\n\n\nshrubAngularController\n\n\nDefine Angular controllers.\n\n\nSee \nthe Angular documentation\n\nfor more information about how to define a controller.\n\n\nImplementations must return\n\n\n\nAn \nannotated function\n.\n\n\n4 implementations\n\n  \n\n    \nshrub-ui/list (client)\nimplementation\n    \nshrub-ui/list/item (client)\nimplementation\n    \nshrub-ui/menu (client)\nimplementation\n    \nshrub-ui/window-title (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \npackages (client)\ninvocation\n  \n\n\n\n\n\nshrubAngularDirective\n\n\nDefine Angular directives.\n\n\nUse this hook to define Angular directives for your application.\n\n\nShrub augments Angular directives to automate some functionality:\n\n\n\n\ndirective.link\n is proxied to automatically attempt to invoke the \nlink\n\n  method of any controllers attached to the directive. Controllers' \nlink\n\n  method is invoked \nbefore\n the directive link function.\n\n\nIf \nbindToController\n is set on the Directive Definition Object, the\n  directive defaults to including a controller of the same name. This means if\n  you define a controller and a directive in the same package (which will have\n  the same name), and you specify \nbindToController\n on the directive, that\n  controller will be automatically attached.\n\n\n\n\nSee \nthe Angular documentation\n\nfor more information about how to define a directive.\n\n\nImplementations must return\n\n\n\nAn \nannotated function\n.\n\n\n25 implementations\n\n  \n\n    \nshrub-form (client)\nimplementation\n    \nshrub-form/widget/checkbox (client)\nimplementation\n    \nshrub-form/widget/checkboxes (client)\nimplementation\n    \nshrub-form/widget/group (client)\nimplementation\n    \nshrub-form/widget/hidden (client)\nimplementation\n    \nshrub-form/widget/markup (client)\nimplementation\n    \nshrub-form/widget/radio (client)\nimplementation\n    \nshrub-form/widget/radios (client)\nimplementation\n    \nshrub-form/widget/select (client)\nimplementation\n    \nshrub-form/widget/submit (client)\nimplementation\n    \nshrub-form/widget/text (client)\nimplementation\n    \nshrub-form/widget/textarea (client)\nimplementation\n    \nshrub-skin-strapped/main-nav (client)\nimplementation\n    \nshrub-ui/attributes (client)\nimplementation\n    \nshrub-ui/list (client)\nimplementation\n    \nshrub-ui/list/item (client)\nimplementation\n    \nshrub-ui/menu (client)\nimplementation\n    \nshrub-ui/messages (client)\nimplementation\n    \nshrub-ui/notifications (client)\nimplementation\n    \nshrub-ui/notifications/item (client)\nimplementation\n    \nshrub-ui/notifications/title (client)\nimplementation\n    \nshrub-ui/window-title (client)\nimplementation\n    \nshrub-user-local/email/forgot (client)\nimplementation\n    \nshrub-user-local/email/register (client)\nimplementation\n    \nshrub-user (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \npackages (client)\ninvocation\n  \n\n\n\n\n\nshrubAngularDirectiveAlter\n\n\nAugment or modify directive definition objects.\n\n\nThis hook allows packages to make changes to\n\ndirective definition objects\n\nprovided by packages' implementations of the\n\nshrubAngularDirective\n hook.\n\n\nshrub-skin\n uses this hook to provide the\ndynamic directive recompilation necessary to implement on-the-fly skin changes.\n\n\n1 implementation\n\n  \n\n    \nshrub-skin (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \npackages (client)\ninvocation\n  \n\n\n\n\n\nshrubAngularFilter\n\n\nDefine Angular filters.\n\n\nSee\n\nthe Angular documentation\n\nfor more information about how to define and use filters.\n\n\nImplementations must return\n\n\n\nA pure function taking the (string) input as the first parameter, followed by\nany optional configuration parameters.\n\n\n1 implementation\n\n  \n\n    \nshrub-ui/markdown (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \npackages (client)\ninvocation\n  \n\n\n\n\n\nshrubAngularPackageDependencies\n\n\nDefine third-party Angular modules to include as application dependencies.\n\n\nAngular modules are defined as a dependency tree. Since we would have to edit\nthe application file to include those dependencies when defining the \nshrub\n\ntop-level application module (And we don't want to do that), we need a better\nsolution. \nangularPackageDependencies\n is that solution.\n\n\nShrub provides the\n\nshrub-html5-notification\n package, which\nuses the\n\nangular-notification\n module.\nThe name of the module is \nnotification\n, so the hook implementation looks\nlike:\n\n\nregistrar.registerHook('shrubAngularPackageDependencies', function() {\n\n  return [\n    'notification'\n  ];\n});\n\n\n\n\nThis ensures our application has the \nnotification\n module marked as a\ndependency. You will still need to use the\n\nshrubGruntConfig\n hook to provide the actual\nJavaScript assets to the client.\n\n\nImplementations must return\n\n\n\nAn array of strings naming the modules you want to include.\n\n\n2 implementations\n\n  \n\n    \nshrub-html5-local-storage (server)\nimplementation\n    \nshrub-html5-notification (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-angular (server)\ninvocation\n  \n\n\n\n\n\nshrubAngularProvider\n\n\nDefine Angular providers.\n\n\nSee\n\nthe Angular documentation\n\nfor more information about how to define and use providers.\n\n\nImplementations must return\n\n\n\nA provider constructor function.\n\n\n3 implementations\n\n  \n\n    \nshrub-html5-local-storage (client)\nimplementation\n    \nshrub-html5-notification (client)\nimplementation\n    \nshrub-skin (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \npackages (client)\ninvocation\n  \n\n\n\n\n\nshrubAngularRoutes\n\n\nDefine Angular routes.\n\n\nPackages use this hook to define Angular routes.\n\n\nImplementations must return\n\n\n\nA route object.\n\n\nSee\n\nthe Angular documentation\n\n(specifically the \nroute\n parameter) for information on defining a route object.\n\n\nAlso note that the \npath\n parameter is defined in the route object itself.\n\n\n8 implementations\n\n  \n\n    \nshrub-core (client)\nimplementation\n    \nshrub-example/about (client)\nimplementation\n    \nshrub-example/home (client)\nimplementation\n    \nshrub-user-local/forgot (client)\nimplementation\n    \nshrub-user-local/register (client)\nimplementation\n    \nshrub-user-local/reset (client)\nimplementation\n    \nshrub-user/login (client)\nimplementation\n    \nshrub-user/logout (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-angular (client)\ninvocation\n  \n\n\n\n\n\nshrubAngularSandboxNavigationMiddleware\n\n\nDefine middleware to run when Angular is navigated in its sandbox.\n\n\nAngular sandboxes retain navigation (and other) state for a client without\nJavaScript capability. When a user hits another page on the server, the\nsandbox navigates the Angular application to the new path. If the path\nchanged, the middleware collected by this hook are dispatched, allowing\npackages to react to the navigation change.\n\n\nThe \nreq\n parameter to the middleware is an instance of\n\nhttp.IncomingMessage\n\nfrom the original HTTP request, along with the following extra properties:\n\n\n\n\n(Sandbox) \nsandbox\n - The sandbox instance.\n\n\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(req, next) {\n  ...\n}\n\n\n\n\n1 implementation\n\n  \n\n    \nshrub-form (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-angular-sandbox (server)\ninvocation\n  \n\n\n\n\n\nshrubAngularService\n\n\nDefine Angular services.\n\n\nUse this hook to define Angular services for your application.\n\n\nSee \nthe Angular documentation\n\nfor more information about how to define a service.\n\n\nImplementations must return\n\n\n\nAn \nannotated function\n which returns a\nservice class/constructor function.\n\n\n8 implementations\n\n  \n\n    \nshrub-form (client)\nimplementation\n    \nshrub-orm (client)\nimplementation\n    \nshrub-rpc (client)\nimplementation\n    \nshrub-socket (client)\nimplementation\n    \nshrub-ui/messages (client)\nimplementation\n    \nshrub-ui/notifications (client)\nimplementation\n    \nshrub-ui/window-title (client)\nimplementation\n    \nshrub-user (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \npackages (client)\ninvocation\n  \n\n\n\n\n\nshrubAssetsMiddleware\n\n\nDefine assets to serve to the client application.\n\n\nPackages may come bundled with JavaScript or CSS assets. This hook is how you\ncan provide them to the client application.\n\n\nAsset middleware takes \nassets\n as its first argument. This is an object with\nthe following properties:\n\n\n\n\n(String Array) \nscripts\n - A list of script assets.\n\n\n(String Array) \nstylesheets\n - A list of sylesheet assets.\n\n\n\n\nNOTE\n: This hook lets you serve assets, but will not automatically copy\nthem from your package to the \napp\n directory where they will be served.\nYou'll need to implement the \nshrubGruntConfig\n\nhook for that.\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(assets, next) {\n  ...\n}\n\n\n\n\n8 implementations\n\n  \n\n    \nshrub-angular (server)\nimplementation\n    \nshrub-assets (server)\nimplementation\n    \nshrub-assets/jquery (server)\nimplementation\n    \nshrub-config (server)\nimplementation\n    \nshrub-grunt (server)\nimplementation\n    \nshrub-html5-local-storage (server)\nimplementation\n    \nshrub-html5-notification (server)\nimplementation\n    \nshrub-socket-socket.io (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-assets (server)\ninvocation\n  \n\n\n\n\n\nshrubAuditFingerprint\n\n\nCreate a fingerprint for a connection\n.\n\n\nEach request has a fingerprint generated which allows bad behavior to be\ntracked (like exceeding API limits).\n\n\nImplementations must return\n\n\n\nA keyed object of fingerprint values. \nnull\n or \nundefined\n values will be\nfiltered out when doing most checks.\n\n\n3 implementations\n\n  \n\n    \nshrub-core (server)\nimplementation\n    \nshrub-session (server)\nimplementation\n    \nshrub-user (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nserver/fingerprint (server)\ninvocation\n  \n\n\n\n\n\nshrubConfigClient\n\n\nDefine configuration variables to be sent to the client.\n\n\nPackages can implement this hook to pass configuration variables to the client.\nConfiguration is keyed by the name of the package.\n\n\nVariables with \nnull\n or \nundefined\n values will be filtered out and not sent\nto the client.\n\n\nImplementations must return\n\n\n\nA keyed object.\n\n\n6 implementations\n\n  \n\n    \nshrub-core (server)\nimplementation\n    \nshrub-skin (server)\nimplementation\n    \nshrub-socket (server)\nimplementation\n    \nshrub-ui (server)\nimplementation\n    \nshrub-ui/notifications (server)\nimplementation\n    \nshrub-user (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-config (server)\ninvocation\n  \n\n\n\n\n\nshrubConfigClientAlter\n\n\nAlter configuration variables defined by packages.\n\n\nPackages can implement this hook to alter configuration variables defined by\nany other (or even the same) package.\n\n\nImplementations are passed a \nConfig\n object.\n\n\nSee: \nshrubConfigClient\n.\n\n\n1 implementation\n\n  \n\n    \nshrub-grunt (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-config (server)\ninvocation\n  \n\n\n\n\n\nshrubConfigServer\n\n\nDefine server-side configuration settings.\n\n\nPackages may use this hook to define default configuration for server-side\nfunctionality. These settings can be overridden in the settings file.\n\n\nImplementations must return\n\n\n\nA recursive object which will be folded into the server configuration under\nthe package name key. For instance, say we have a package \nmy-package\n which\ndefines the hook like:\n\n\nregistrar.registerHook('shrubConfigServer', function() {\n  return {\n    one: 68,\n    two: {\n      three: 419\n    }\n  };\n});\n\n\n\n\nYou would then find those values in the configuration at:\n\n\nconfig.get('packageSettings:my-package:one');\nconfig.get('packageSettings:my-package:two:three');\n\n\n\n\nSee \nthe default configuration file\n for\nan example of how settings may be overridden. This should always be preferred\nto actually changing the code in a given package's hook.\n\n\n13 implementations\n\n  \n\n    \nshrub-angular-sandbox (server)\nimplementation\n    \nshrub-assets (server)\nimplementation\n    \nshrub-core (server)\nimplementation\n    \nshrub-http (server)\nimplementation\n    \nshrub-nodemailer (server)\nimplementation\n    \nshrub-orm (server)\nimplementation\n    \nshrub-repl (server)\nimplementation\n    \nshrub-session (server)\nimplementation\n    \nshrub-skin (server)\nimplementation\n    \nshrub-socket (server)\nimplementation\n    \nshrub-user-reddit (server)\nimplementation\n    \nshrub-user (server)\nimplementation\n    \nshrub-villiany (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nserver/config (server)\ninvocation\n  \n\n\n\n\n\nshrubCoreBootstrapMiddleware\n\n\nDefine middleware to run when the server application is bootstrapping.\n\n\nThis hook is where most of the major initialization work happens on the\nShrub server. \nshrub-http\n spins up an HTTP server,\n\nshrub-orm\n spins up Waterline, and more.\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(next) {\n  ...\n}\n\n\n\n\n11 implementations\n\n  \n\n    \nshrub-angular-sandbox (server)\nimplementation\n    \nshrub-http-express/session (server)\nimplementation\n    \nshrub-http (server)\nimplementation\n    \nshrub-install (server)\nimplementation\n    \nshrub-nodemailer (server)\nimplementation\n    \nshrub-orm (server)\nimplementation\n    \nshrub-passport (server)\nimplementation\n    \nshrub-repl (server)\nimplementation\n    \nshrub-rpc (server)\nimplementation\n    \nshrub-socket (server)\nimplementation\n    \nshrub-ui/notifications (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nserver (server)\ninvocation\n  \n\n\n\n\n\nshrubCorePreBootstrap\n\n\nInvoked before the application bootstrap phase.\n\n\nMitigate slow build times\n\n\n\nIf your package \nrequire\ns heavy modules, you should require them in an\nimplementation of hook \nshrubCorePreBootstrap\n. For instance, say you have a\npackage like:\n\n\nvar someHeavyModule = require('some-heavy-module');\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};\n\n\n\n\nThis will slow the build process down, since \nsome-heavy-module\n must be\nloaded when loading your package. Use this pattern instead:\n\n\nvar someHeavyModule = null;\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubCorePreBootstrap', function() {\n    someHeavyModule = require('some-heavy-module');\n  });\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};\n\n\n\n\nSo that the heavy module will not be \nrequire\nd until hook\n\nshrubCorePreBootstrap\n is invoked.\n\n\n13 implementations\n\n  \n\n    \nshrub-http-express (server)\nimplementation\n    \nshrub-limiter (server)\nimplementation\n    \nshrub-nodemailer (server)\nimplementation\n    \nshrub-orm (server)\nimplementation\n    \nshrub-passport (server)\nimplementation\n    \nshrub-rpc (server)\nimplementation\n    \nshrub-ui/notifications (server)\nimplementation\n    \nshrub-user-local (server)\nimplementation\n    \nshrub-user-local/register (server)\nimplementation\n    \nshrub-user-reddit (server)\nimplementation\n    \nshrub-user (server)\nimplementation\n    \nshrub-user/login (server)\nimplementation\n    \nshrub-villiany (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nserver (server)\ninvocation\n  \n\n\n\n\n\nshrubCoreProcessExit\n\n\nFinal cleanups as the process is exiting.\n\n\nShrub tries its hardest to always invoke this hook, even in the event of a\nraised signal or unhandled exception.\n\n\nYou should not schedule asynchronous events, as they will not be dispatched.\nSee \nthe Node.js documentation\n\nfor more information.\n\n\n1 implementation\n\n  \n\n    \nshrub-repl (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nserver (server)\ninvocation\n  \n\n\n\n\n\nshrubFormAlter\n\n\nAlter any \nform definition object\n\nbefore it's rendered.\n\n\nPackages may implement this hook to modify the form definition object in any\nway.\n\n\n1 invocation\n\n  \n\n    \nshrub-form (client)\ninvocation\n  \n\n\n\n\n\nshrubFormFormKeyAlter\n\n\nAlter any \nform definition object\n whose\nkey matches before it's rendered.\n\n\nThis hook targets a specific form key. The form key is automatically\ncamelized, e.g. form key \nshrub-user-login\n will match\n\nshrubFormShrubUserLoginAlter\n.\n\n\nPackages may implement this hook to modify the form definition object in any\nway (although altering the key would probably be confusing at this point).\n\n\n1 invocation\n\n  \n\n    \nshrub-form (client)\ninvocation\n  \n\n\n\n\n\nshrubFormWidgets\n\n\nDefine form widgets for use when defining\n\nform definition objects\n.\n\n\nImplementations must return\n\n\n\nAn array of objects structured like:\n\n\n\n\n(String) \ntype\n - The widget type, used in form definition objects.\n\n\n(String) \ndirective\n - The directive used to render the widget.\n\n\n(Optional Function) \nassignToElement\n - A function which can be used to apply\n  complex widget values to the widget element. The function takes two\n  parameters:\n\n\n(jqLite/jQuery object) \nelement\n - The widget's wrapped DOM element.\n\n\n(Any) \nvalue\n - The value to apply to the widget element.\n\n\n\n\n\n\n\n\n11 implementations\n\n  \n\n    \nshrub-form/widget/checkbox (client)\nimplementation\n    \nshrub-form/widget/checkboxes (client)\nimplementation\n    \nshrub-form/widget/group (client)\nimplementation\n    \nshrub-form/widget/hidden (client)\nimplementation\n    \nshrub-form/widget/markup (client)\nimplementation\n    \nshrub-form/widget/radio (client)\nimplementation\n    \nshrub-form/widget/radios (client)\nimplementation\n    \nshrub-form/widget/select (client)\nimplementation\n    \nshrub-form/widget/submit (client)\nimplementation\n    \nshrub-form/widget/text (client)\nimplementation\n    \nshrub-form/widget/textarea (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-form (client)\ninvocation\n  \n\n\n\n\n\nshrubGruntConfig\n\n\nHook into the Grunt build process.\n\n\nThis hook allows packages to define Grunt tasks, configure existing tasks, and\nload NPM tasks. This is achieved through the first implementation parameter\nwhich is an instance of the class\n\nGruntConfiguration\n. The\n\ngrunt\n object is passed in through the second parameter in case it's needed.\n\n\nOne of the most common uses of this hook is to copy any asset files your\npackage may include to the \napp\n directory, where they can be served to\nclients.\n\n\n13 implementations\n\n  \n\n    \nshrub-angular (server)\nimplementation\n    \nshrub-assets (server)\nimplementation\n    \nshrub-grunt/dox (server)\nimplementation\n    \nshrub-grunt (server)\nimplementation\n    \nshrub-grunt/lint (server)\nimplementation\n    \nshrub-grunt/modules (server)\nimplementation\n    \nshrub-grunt/tests/build (server)\nimplementation\n    \nshrub-grunt/tests/run (server)\nimplementation\n    \nshrub-html5-local-storage (server)\nimplementation\n    \nshrub-html5-notification (server)\nimplementation\n    \nshrub-orm (server)\nimplementation\n    \nshrub-skin-strapped (server)\nimplementation\n    \nshrub-socket-socket.io (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nGruntfile (server)\ninvocation\n  \n\n\n\n\n\nshrubGruntConfigAlter\n\n\nAlter the Grunt build process.\n\n\nThis hook allows packages to alter Grunt configuration specified through\n\nshrubGruntConfig\n.\n\n\nThe first implementation parameter is an instance of the class\n\nGruntConfiguration\n. The \ngrunt\n\nobject is passed in through the second parameter in case it's needed.\n\n\n2 implementations\n\n  \n\n    \nshrub-grunt (server)\nimplementation\n    \nshrub-grunt/tests/build (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nGruntfile (server)\ninvocation\n  \n\n\n\n\n\nshrubHttpMiddleware\n\n\nDefine middleware to run for every HTTP request.\n\n\nThe \nreq\n parameter to the middleware is an instance of\n\nhttp.IncomingMessage\n\nfrom the HTTP request.\n\n\nThe \nres\n parameter to the middleware is an instance of\n\nhttp.ServerResponse\n\nfrom the HTTP request.\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(req, res, next) {\n  ...\n}\n\n\n\n\n13 implementations\n\n  \n\n    \nshrub-angular-sandbox (server)\nimplementation\n    \nshrub-config (server)\nimplementation\n    \nshrub-core (server)\nimplementation\n    \nshrub-form (server)\nimplementation\n    \nshrub-http-express/errors (server)\nimplementation\n    \nshrub-http-express/logger (server)\nimplementation\n    \nshrub-http-express/routes (server)\nimplementation\n    \nshrub-http-express/session (server)\nimplementation\n    \nshrub-http-express/static (server)\nimplementation\n    \nshrub-http (server)\nimplementation\n    \nshrub-passport (server)\nimplementation\n    \nshrub-skin (server)\nimplementation\n    \nshrub-villiany (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-http/manager (server)\ninvocation\n  \n\n\n\n\n\nshrubHttpRoutes\n\n\nDefine HTTP routes.\n\n\nPackages use this hook to define HTTP routes.\n\n\nImplementations must return\n\n\n\nAn array of objects structured like:\n\n\n\n\n(String) \npath\n - The HTTP path of the route. Include the leading slash.\n\n\n(String) \nverb\n - The HTTP verb to associate with this route. Defaults to\n  \n'get'\n.\n\n\n(Function) \nreceiver\n - The function invoked when the route is hit. Takes\n  three parameters:\n\n\n(http.IncomingMessage) \nreq\n - The request object.\n\n\n(http.ServerResponse) \nres\n - The response object.\n\n\n(Function) \nfn\n - A nodeback called when the route is complete.\n\n\n\n\n\n\n\n\n2 implementations\n\n  \n\n    \nshrub-example/about (server)\nimplementation\n    \nshrub-user-reddit (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-http/manager (server)\ninvocation\n  \n\n\n\n\n\nshrubLimiterCheck\n\n\nSpecifiy criteria which will skip limiter checks.\n\n\nYou may bypass limit checks by returning \nSKIP\n (\nshrub-limiter\n package) from\nimplementations of this hook, e.g.\n\n\n\nregistrar.registerHook('shrubLimiterCheck', function(req) {\n\n  if (req.somethingWeWantToCheck) {\n    return require('shrub-limiter').SKIP;\n  }\n})\n\n\n\n\n\nReturning any other value besides \nSKIP\n will have no effect.\n\n\nImplementation arguments\n\n\n\n\n\n(http.IncomingMessage) \nreq\n: The route request object.\n\n\n\n\nImplementations must return\n\n\n\nSKIP\n to skip the limiter check, or anything else otherwise.\n\n\n1 invocation\n\n  \n\n    \nshrub-limiter (server)\ninvocation\n  \n\n\n\n\n\nshrubNodemailerHtml\n\n\nCompose outgoing email.\n\n\nThis hook is implemented by skins. Only the active skin's implementation is\ncalled for any email.\n\n\nImplementations accept the following parameters:\n\n\n\n\n(cheerio element) \n$body\n - The body tag of the rendered app HTML, wrapped\n  with \ncheerio\n, a lightweight\n  server-side implementation of a lot of jQuery's functionality.\n\n\n(String) \nhtml\n - The mail HTML, generated from the directive.\n\n\n(cheerio) \n$\n - The cheerio instance.\n\n\n\n\nIt is the skin's responsibility to inject the email HTML from the second\nparameter to where it belongs in the app HTML. The skin should also remove any\ntrace of dynamic JavaScript-driven functionality as that will surely break\nin email where such things are not allowed.\n\n\n1 implementation\n\n  \n\n    \nshrub-skin-strapped (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-nodemailer (server)\ninvocation\n  \n\n\n\n\n\nshrubOrmCollections\n\n\nDefine collections of models.\n\n\nPackages can implement this hook to define collections of models for use\nthroughout the server (and to a limited extent, the client) application.\n\n\nShrub uses Waterline as an ORM, so you can follow the\n\nWaterline documentation for how to define model collections\n.\nShrub handles calling \nWaterline.Collection.extend\n, so you only have to return\nthe raw object.\n\n\nImplementations must return\n\n\n\nA keyed object whose values are raw model collection objects. e.g.\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubOrmCollections', function() {\n\n    return {\n      'some-model': {\n        attributes: {\n          foo: 'string'\n        }\n      },\n      'some-other-model': {\n        attributes: {\n          bar: 'string'\n        }\n      }\n    };\n  });\n};\n\n\n\n\n8 implementations\n\n  \n\n    \nshrub-user (client)\nimplementation\n    \nshrub-user (server)\nimplementation\n    \nshrub-limiter (server)\nimplementation\n    \nshrub-session (server)\nimplementation\n    \nshrub-ui/notifications (server)\nimplementation\n    \nshrub-user-local (server)\nimplementation\n    \nshrub-user-reddit (server)\nimplementation\n    \nshrub-villiany (server)\nimplementation\n  \n\n\n\n\n\n2 invocations\n\n  \n\n    \nshrub-orm (client)\ninvocation\n    \nshrub-orm (server)\ninvocation\n  \n\n\n\n\n\nshrubOrmCollectionsAlter\n\n\nAlter collections defined by packages.\n\n\nPackages can implement this hook to alter collections defined by any other (or\neven the same) package.\n\n\nImplementations are passed a keyed object containing all of the collections\ndefined by all modules.\n\n\nSee: \nshrubOrmcollections\n.\n\n\n1 implementation\n\n  \n\n    \nshrub-user (client)\nimplementation\n  \n\n\n\n\n\n2 invocations\n\n  \n\n    \nshrub-orm (client)\ninvocation\n    \nshrub-orm (server)\ninvocation\n  \n\n\n\n\n\nshrubReplContext\n\n\nAdd to the REPL context.\n\n\nPackages may use this hook to provide access to parts of their state to the\nREPL context.\n\n\nImplementations accept the following arguments:\n\n\n\n\n(Object) \ncontext\n - The context object.\n\n\n\n\nTo set context variables, simply set them on the context object.\n\n\n5 implementations\n\n  \n\n    \nshrub-install (server)\nimplementation\n    \nshrub-nodemailer (server)\nimplementation\n    \nshrub-orm (server)\nimplementation\n    \nshrub-socket (server)\nimplementation\n    \nshrub-user-local/register (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-repl (server)\ninvocation\n  \n\n\n\n\n\nshrubRpcCall\n\n\nNotify packages when any RPC call is made.\n\n\nPackages can implement this hook to be notified when any RPC call is made.\nFor instance, \nshrub-ui/messages\n uses\nthis hook to display an error message if any RPC call returned with an error.\n\n\nImplementations must return\n\n\n\nAn \nannotated function\n. The following\nlocals are injected:\n\n\n\n\n(String) \nroute\n - The RPC route path.\n\n\n(Any) \ndata\n - The data sent to the server.\n\n\n(Promise) \nresult\n - The result promise.\n\n\n\n\n1 implementation\n\n  \n\n    \nshrub-ui/messages (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-rpc (client)\ninvocation\n  \n\n\n\n\n\nshrubRpcRoutes\n\n\nDefine RPC routes.\n\n\nPackages use this hook to define RPC routes.\n\n\nImplementations must return\n\n\n\nAn array of objects structured like:\n\n\n\n\n(String) \npath\n - The HTTP path of the route. Include the leading slash.\n\n\n(Function Array) \nmiddleware\n - A middleware stack which is dispatched when\n  the route is hit. The middleware have the following signature:\n\n\n\n\nfunction(req, res, next) {\n  ...\n}\n\n\n\n\nreq\n has the following properties set by default:\n\n\n\n\n(Any) \nbody\n: The data passed in from the RPC call.\n\n\n(Object) \nroute\n: the route definition object specified above.\n\n\n(Socket) \nsocket\n: The raw socket object.\n\n\n\n\nres\n has the following properties set by default:\n\n\n\n\n(Function) \nend\n: Called with the data to respond to the RPC call.\n\n\n\n\n7 implementations\n\n  \n\n    \nshrub-angular-sandbox (server)\nimplementation\n    \nshrub-passport/logout (server)\nimplementation\n    \nshrub-ui/notifications (server)\nimplementation\n    \nshrub-user-local/forgot (server)\nimplementation\n    \nshrub-user-local/register (server)\nimplementation\n    \nshrub-user-local/reset (server)\nimplementation\n    \nshrub-user/login (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-rpc (server)\ninvocation\n  \n\n\n\n\n\nshrubRpcRoutesAlter\n\n\nAlter RPC routes defined by packages.\n\n\nPackages can implement this hook to alter RPC routes defined by any other (or\neven the same) package.\n\n\nSee: \nshrubRpcRoutes\n.\n\n\n7 implementations\n\n  \n\n    \nshrub-core (server)\nimplementation\n    \nshrub-example (server)\nimplementation\n    \nshrub-http-express (server)\nimplementation\n    \nshrub-http-express/session (server)\nimplementation\n    \nshrub-limiter (server)\nimplementation\n    \nshrub-passport (server)\nimplementation\n    \nshrub-villiany (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-rpc (server)\ninvocation\n  \n\n\n\n\n\nshrubSkinAssets\n\n\nAllow skins to define extra assets that they include on the page.\n\n\nBy default, a skin includes an \napp\n directory containing assets which are\ncopied to the application's \napp\n directory. These assets are automatically\nincluded on each page depending on the execution environment. By default,\nproduction includes all stylesheets matching \n*.min.css\n and scripts matching\n\n*.min.js\n. All other environments include stylesheets matching the pattern\n\n*.css\n (excluding \n*.min.css\n) and scripts matching \n*.js\n (excluding\n\n*.min.js\n).\n\n\nThis is not always enough, since your skin may do its own building, e.g.\ncompiling LESS/Sass to CSS, and those resources need to be added to the page\nas well. This hook lets you do so.\n\n\n1 implementation\n\n  \n\n    \nshrub-skin-strapped (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-skin (server)\ninvocation\n  \n\n\n\n\n\nshrubSkinLink\n\n\nRegister a link function to run on all directives.\n\n\nThis hook allows packages to run additional link functions for directives. The\nlink functions are run every time skin or attribute changes result in directive\nrecompilation.\n\n\nImplementations must return\n\n\n\nAn \nannotated function\n. The following\nlocals are injected:\n\n\n\n\n(Scope) \n$scope\n - Angular scope object for this directive.\n\n\n(jqLite element) \n$element\n: Directive DOM element.\n\n\n(Attributes) \n$attr\n: Directive attributes object.\n\n\n(Function or Function Array or null) \n$controller\n: Directive controller(s), if\n  any.\n\n\n(Function or null) \n$transclude\n: Transclusion function, if any.\n\n\n\n\n1 implementation\n\n  \n\n    \nshrub-skin-strapped/form (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-skin (client)\ninvocation\n  \n\n\n\n\n\nshrubSkinLink--DIRECTIVE\n\n\nRegister a link function to run on directives matching directive name.\n\n\nThis hook allows packages to run additional link functions for directives. The\nlink functions are run every time skin or attribute changes result in directive\nrecompilation.\n\n\nImplementations must return\n\n\n\nAn \nannotated function\n. The following\nlocals are injected:\n\n\n\n\n(Scope) \n$scope\n - Angular scope object for this directive.\n\n\n(jqLite element) \n$element\n: Directive DOM element.\n\n\n(Attributes) \n$attr\n: Directive attributes object.\n\n\n(Function or Function Array or null) \n$controller\n: Directive controller(s), if\n  any.\n\n\n(Function or null) \n$transclude\n: Transclusion function, if any.\n\n\n\n\n3 implementations\n\n  \n\n    \nshrub-example (client)\nimplementation\n    \nshrub-skin-strapped/form (client)\nimplementation\n    \nshrub-skin-strapped/notifications (client)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-skin (client)\ninvocation\n  \n\n\n\n\n\nshrubSkinLink--DIRECTIVE--ID\n\n\nRegister a link function to run on directives matching directive name and ID.\n\n\nThis hook allows packages to run additional link functions for directives. The\nlink functions are run every time skin or attribute changes result in directive\nrecompilation.\n\n\nImplementations must return\n\n\n\nAn \nannotated function\n. The following\nlocals are injected:\n\n\n\n\n(Scope) \n$scope\n - Angular scope object for this directive.\n\n\n(jqLite element) \n$element\n: Directive DOM element.\n\n\n(Attributes) \n$attr\n: Directive attributes object.\n\n\n(Function or Function Array or null) \n$controller\n: Directive controller(s), if\n  any.\n\n\n(Function or null) \n$transclude\n: Transclusion function, if any.\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-skin (client)\ninvocation\n  \n\n\n\n\n\nshrubSocketConnectionMiddleware\n\n\nAct after a socket connection.\n\n\nPackages may implement this hook to take action after a socket is connected.\n\n\nThe \nreq\n parameter to the middleware is an instance of\n\nhttp.IncomingMessage\n\nfrom the HTTP request.\n\n\nThe \nres\n parameter to the middleware is an instance of\n\nhttp.ServerResponse\n\nfrom the HTTP request.\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(req, res, next) {\n  ...\n}\n\n\n\n\n6 implementations\n\n  \n\n    \nshrub-core (server)\nimplementation\n    \nshrub-http-express/session (server)\nimplementation\n    \nshrub-passport (server)\nimplementation\n    \nshrub-rpc (server)\nimplementation\n    \nshrub-session (server)\nimplementation\n    \nshrub-villiany (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-socket/manager (server)\ninvocation\n  \n\n\n\n\n\nshrubSocketDisconnectionMiddleware\n\n\nAct after a socket disconnect.\n\n\nPackages may implement this hook to take action after a socket is disconnected.\n\n\nThe \nreq\n parameter to the middleware is an instance of\n\nhttp.IncomingMessage\n\nfrom the HTTP request.\n\n\nThe \nres\n parameter to the middleware is an instance of\n\nhttp.ServerResponse\n\nfrom the HTTP request.\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(req, res, next) {\n  ...\n}\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-socket/manager (server)\ninvocation\n  \n\n\n\n\n\nshrubTransmittableErrors\n\n\nDefine errors that can be transmitted to the client.\n\n\nSee \nthe documentation on errors\n for more information.\n\n\nImplementations must return\n\n\n\nAn array of subclasses of\n\nTransmittableError\n.\n\n\n6 implementations\n\n  \n\n    \nshrub-limiter (client)\nimplementation\n    \nshrub-limiter (server)\nimplementation\n    \nshrub-user-local (client)\nimplementation\n    \nshrub-user-local (server)\nimplementation\n    \nshrub-user (client)\nimplementation\n    \nshrub-user (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nmodules/errors (client)\ninvocation\n  \n\n\n\n\n\nshrubUiNotificationQueues\n\n\nDefine persistent notification queues.\n\n\nPackages may implement this hook to define queues of notifications.\n\n\nImplementations must return\n\n\n\nAn object whose keys are queue names and whose values are structured like:\n\n\n\n\n(Function) \nchannelFromRequest\n - An idempotent function which returns the\n  channel of the queue. The channel is represented as a string value.\n  Typically the channel maps to the concept of ownership -- a queue which\n  stores some notifications for a user will likely belong to a channel\n  which is identical to the user ID. This function takes the following\n  parameters:\n\n\n(http.IncomingMessage) \nreq\n - The request object.\n\n\n\n\n\n\n\n\n1 implementation\n\n  \n\n    \nshrub-example (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-ui/notifications (server)\ninvocation\n  \n\n\n\n\n\nshrubUserAfterLoginMiddleware\n\n\nTake action after a user logs in.\n\n\nThis hook allows packages to act after a user is logged in.\n\n\nThe \nreq\n parameter to the middleware is an instance of\n\nhttp.IncomingMessage\n.\n\n\nNote\n\n  \n\n    \nreq.user\n as well as \nreq.loggingInUser\n will be\n    populated with the newly logged-in user at this point.\n  \n\n\n\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(req, next) {\n  ...\n}\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-passport (server)\ninvocation\n  \n\n\n\n\n\nshrubUserAfterLogoutMiddleware\n\n\nTake action after a user logs out.\n\n\nThis hook allows packages to act after a user is logged out.\n\n\nThe \nreq\n parameter to the middleware is an instance of\n\nhttp.IncomingMessage\n.\n\n\nNote\n\n  \n\n    \nreq.user\n will \nnot\n be populated with the\n    previously logged-out user at this point, but\n    \nreq.loggingOutUser\n will.\n  \n\n\n\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(req, next) {\n  ...\n}\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-passport (server)\ninvocation\n  \n\n\n\n\n\nshrubUserBeforeLoginMiddleware\n\n\nTake action before a user logs in.\n\n\nThis hook allows packages to act before a user is logged in. If an error is\nthrown or passed to the middleware \nnext\n function, the login fails.\n\n\nThe \nreq\n parameter to the middleware is an instance of\n\nhttp.IncomingMessage\n.\n\n\nNote\n\n  \n\n    \nreq.user\n will \nnot\n be populated with the\n    logging in user at this point, but \nreq.loggingInUser\n will.\n  \n\n\n\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(req, next) {\n  ...\n}\n\n\n\n\n1 implementation\n\n  \n\n    \nshrub-user (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-passport (server)\ninvocation\n  \n\n\n\n\n\nshrubUserBeforeLogoutMiddleware\n\n\nTake action before a user logs out.\n\n\nThis hook allows packages to act before a user is logged out. If an error is\nthrown or passed to the middleware \nnext\n function, the logout fails.\n\n\nThe \nreq\n parameter to the middleware is an instance of\n\nhttp.IncomingMessage\n.\n\n\nNote\n\n  \n\n    \nreq.user\n as well as \nreq.loggingOutUser\n will be\n    populated with the logging out user at this point.\n  \n\n\n\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(req, next) {\n  ...\n}\n\n\n\n\n1 implementation\n\n  \n\n    \nshrub-user (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-passport (server)\ninvocation\n  \n\n\n\n\n\nshrubUserLoginStrategies\n\n\nDefine login strategies for users.\n\n\nThis hook allows packages to define login strategies.\n\n\nImplementations must return\n\n\n\n\n\n\n\nClient-side:\n\n\n\n\n\n\n(string) \nmethodLabel\n - A label used on the user login form to identify\nyour login strategy e.g. \nLocal\n.\n\n\n\n\n\n\n(object) \nfields\n - \nShrub form fields definition\n which\nare used on the login form under a subgroup for your login strategy. For\ninstance, the local user login strategy defines \nusername\n, \npassword\n,\n\nsubmit\n and a \nforgot\n markup link.\n\n\n\n\n\n\n\n\n\n\nServer-side:\n  \n\n    (mixed) \n...\n - A concrete strategy for the underlying authentication\n    framework that is active for the site. By default this is\n    \nshrub-passport\n which requires a\n    strategy to implement a \npassportStrategy\n field e.g. an instance of\n    \nrequire('passport-local').Strategy\n.\n  \n\n\n\n\n\n\n4 implementations\n\n  \n\n    \nshrub-user-local (client)\nimplementation\n    \nshrub-user-local (server)\nimplementation\n    \nshrub-user-reddit (client)\nimplementation\n    \nshrub-user-reddit (server)\nimplementation\n  \n\n\n\n\n\n2 invocations\n\n  \n\n    \nshrub-user/login (client)\ninvocation\n    \nshrub-passport (server)\ninvocation\n  \n\n\n\n\n\nshrubUserLoginStrategiesAlter\n\n\nAlter defined login strategies for users.\n\n\nThis hook allows packages to alter defined login strategies.\n\n\nImplementations can adjust:\n\n\n\n\n\n\n\nClient-side:\n\n\n\n\n\n\n(string) \nmethodLabel\n - A label used on the user login form to identify\nyour login strategy e.g. \nLocal\n.\n\n\n\n\n\n\n(object) \nfields\n - \nShrub form fields definition\n which\nare used on the login form under a subgroup for your login strategy. For\ninstance, the local user login strategy defines \nusername\n, \npassword\n,\n\nsubmit\n and a \nforgot\n markup link.\n\n\n\n\n\n\n\n\n\n\nServer-side:\n  \n\n    (mixed) \n...\n - A concrete strategy for the underlying authentication\n    framework that is active for the site. By default this is\n    \nshrub-passport\n which requires a\n    strategy to implement a \npassportStrategy\n field e.g. an instance of\n    \nrequire('passport-local').Strategy\n. If you are implementing some other\n    authorization framework, you would add the strategy implementation using\n    this hook.\n  \n\n\n\n\n\n\n2 invocations\n\n  \n\n    \nshrub-user/login (client)\ninvocation\n    \nshrub-passport (server)\ninvocation\n  \n\n\n\n\n\nshrubUserRedactors\n\n\nDefine functions to redact objects for users.\n\n\nThis hook allows packages to define redaction functions that take an object\nand a user and redact the object based on a user's permissions. For instance,\n\nshrub-user-local\n defines redactors for\n\nshrub-user-local\n models, which prune the \npassword\n and \nsalt\n fields. The\nredactor also checks if the local user belongs to the same user on whose\nbehalf the redaction is occuring. If it's the same user, the redactor decrypts\nand includes the \nemail\n field. Otherwise, the \nemail\n field is completely\nredacted.\n\n\nImplementations must return\n\n\n\nAn object whose keys correspond to object types (a rule of thumb is to use\nthe model name e.g. \nshrub-user\n, \nshrub-user-local\n, etc.) and whose value is\nan array of redaction functions.\n\n\nSupposing we wanted to implement a redaction function which would redact the\n\nname\n field for a \nshrub-user-local\n model, we could implement it like so:\n\n\nexports.pkgmanRegister = (registrar) ->\n\n  # #### Implements hook `shrubUserRedactors`.\n  registrar.registerHook 'shrubUserRedactors', ->\n\n    'shrub-user-local': [\n\n      (object, user) ->\n\n        delete object.name\n        return object\n\n    ]\n\n\n\n\nNote\n\n  \n\n    Redaction functions may return a promised redacted object.\n  \n\n\n\n\n\n3 implementations\n\n  \n\n    \nshrub-user-local (server)\nimplementation\n    \nshrub-user-reddit (server)\nimplementation\n    \nshrub-user (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-user (server)\ninvocation\n  \n\n\n\n\n\nshrubVillianyReport\n\n\nAct on reported villianous actions.\n\n\nPackages can invoke this hook to notify other packages that villianous behavior\nhas occurred. This is an abstract concept that is application-specific: one\napplication in core shrub is exceeding RPC call limits, however you could use\nthe system for things like user flagging, abusive behavior, etc.\n\n\nImplementation arguments\n\n\n\n\n\n(http.IncomingMessage) \nreq\n: The route request object.\n\n\n(Number) \nscore\n: The numeric score this action contributes towards a ban.\n\n\n(String) \nkey\n: A unique key for this villianous action.\n\n\n(String Array) \nexcludedKeys\n: Fingerprint keys to exclude from ban.\n\n\n\n\nImplementations must return\n\n\n\nA boolean or a promise that resolves to boolean indicating whether or not the\nvillianous action results in a ban.\n\n\n1 implementation\n\n  \n\n    \nshrub-villiany (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nshrub-limiter (server)\ninvocation",
            "title": "Hooks"
        },
        {
            "location": "/hooks/#shrubangularahrefsanitizationwhitelist",
            "text": "Allow packages to define whitelisted patterns for ngHref attributes.  By default, Angular filters 'unsafe' URLs passed to the ngHref attribute. This\nbehavior is normally configured through $compileProvider.aHrefSanitizationWhitelist \nso Shrub provides this hook to make it easy to add your own whitelisted\npatterns.  Implementations of this hook should return an array of strings. The strings\nare compiled into a regular expression which determines whether the href is\nallowed or not. For instance,  shrub-angular  provides two patterns by default:  '(?:https?|ftp|mailto|tel|file):'  which allows the usage of http, https, ftp mailto, tel, and file\nprotocols, and  'javascript:void\\\\(0\\\\)'  which allows the usage of  javascript:void(0)  as an href.  Shrub combines all patterns into a regular expression and automatically\nenforces that the pattern will occur at the beginning of the string. For\nexample, if we have two patterns, like:  ['foo', 'bar']  the resulting regular expression will be equivalent to:  /^\\s*(?:foo|bar)/  This hook should be used sparingly, as the reason there is a whitelist in the\nfirst place is because there are security implications to allowing just any\nhref in a dynamic directive.  Use caution .  Implementations must return  An array of strings to be compiled into a regular expression.  1 implementation \n   \n     shrub-angular (client) implementation      1 invocation \n   \n     shrub-angular (client) invocation",
            "title": "shrubAngularAHrefSanitizationWhitelist"
        },
        {
            "location": "/hooks/#shrubangularappconfig",
            "text": "Allow packages to hook into the configuration phase of the Angular\napplication.  Packages should implement this hook when they need to run code during the\nAngular module configuration phase. See the Angular documentation \non  Configuration blocks  for more explanation.  Implementations must return  An  annotated function .  4 implementations \n   \n     shrub-angular (client) implementation      shrub-example/home (client) implementation      shrub-html5-local-storage (client) implementation      shrub-html5-notification (client) implementation      1 invocation \n   \n     app (client) invocation",
            "title": "shrubAngularAppConfig"
        },
        {
            "location": "/hooks/#shrubangularapprun",
            "text": "Allow packages to hook into the run phase of the Angular application.  Packages should implement this hook when they need to run code during the\nAngular module run phase. See the Angular documentation \non  Run blocks  for more explanation.  Implementations must return  An  annotated function .  4 implementations \n   \n     shrub-angular-sandbox (client) implementation      shrub-core (client) implementation      shrub-ui/messages (client) implementation      shrub-ui/window-title (client) implementation      1 invocation \n   \n     app (client) invocation",
            "title": "shrubAngularAppRun"
        },
        {
            "location": "/hooks/#shrubangularcontroller",
            "text": "Define Angular controllers.  See  the Angular documentation \nfor more information about how to define a controller.  Implementations must return  An  annotated function .  4 implementations \n   \n     shrub-ui/list (client) implementation      shrub-ui/list/item (client) implementation      shrub-ui/menu (client) implementation      shrub-ui/window-title (client) implementation      1 invocation \n   \n     packages (client) invocation",
            "title": "shrubAngularController"
        },
        {
            "location": "/hooks/#shrubangulardirective",
            "text": "Define Angular directives.  Use this hook to define Angular directives for your application.  Shrub augments Angular directives to automate some functionality:   directive.link  is proxied to automatically attempt to invoke the  link \n  method of any controllers attached to the directive. Controllers'  link \n  method is invoked  before  the directive link function.  If  bindToController  is set on the Directive Definition Object, the\n  directive defaults to including a controller of the same name. This means if\n  you define a controller and a directive in the same package (which will have\n  the same name), and you specify  bindToController  on the directive, that\n  controller will be automatically attached.   See  the Angular documentation \nfor more information about how to define a directive.  Implementations must return  An  annotated function .  25 implementations \n   \n     shrub-form (client) implementation      shrub-form/widget/checkbox (client) implementation      shrub-form/widget/checkboxes (client) implementation      shrub-form/widget/group (client) implementation      shrub-form/widget/hidden (client) implementation      shrub-form/widget/markup (client) implementation      shrub-form/widget/radio (client) implementation      shrub-form/widget/radios (client) implementation      shrub-form/widget/select (client) implementation      shrub-form/widget/submit (client) implementation      shrub-form/widget/text (client) implementation      shrub-form/widget/textarea (client) implementation      shrub-skin-strapped/main-nav (client) implementation      shrub-ui/attributes (client) implementation      shrub-ui/list (client) implementation      shrub-ui/list/item (client) implementation      shrub-ui/menu (client) implementation      shrub-ui/messages (client) implementation      shrub-ui/notifications (client) implementation      shrub-ui/notifications/item (client) implementation      shrub-ui/notifications/title (client) implementation      shrub-ui/window-title (client) implementation      shrub-user-local/email/forgot (client) implementation      shrub-user-local/email/register (client) implementation      shrub-user (client) implementation      1 invocation \n   \n     packages (client) invocation",
            "title": "shrubAngularDirective"
        },
        {
            "location": "/hooks/#shrubangulardirectivealter",
            "text": "Augment or modify directive definition objects.  This hook allows packages to make changes to directive definition objects \nprovided by packages' implementations of the shrubAngularDirective  hook.  shrub-skin  uses this hook to provide the\ndynamic directive recompilation necessary to implement on-the-fly skin changes.  1 implementation \n   \n     shrub-skin (client) implementation      1 invocation \n   \n     packages (client) invocation",
            "title": "shrubAngularDirectiveAlter"
        },
        {
            "location": "/hooks/#shrubangularfilter",
            "text": "Define Angular filters.  See the Angular documentation \nfor more information about how to define and use filters.  Implementations must return  A pure function taking the (string) input as the first parameter, followed by\nany optional configuration parameters.  1 implementation \n   \n     shrub-ui/markdown (client) implementation      1 invocation \n   \n     packages (client) invocation",
            "title": "shrubAngularFilter"
        },
        {
            "location": "/hooks/#shrubangularpackagedependencies",
            "text": "Define third-party Angular modules to include as application dependencies.  Angular modules are defined as a dependency tree. Since we would have to edit\nthe application file to include those dependencies when defining the  shrub \ntop-level application module (And we don't want to do that), we need a better\nsolution.  angularPackageDependencies  is that solution.  Shrub provides the shrub-html5-notification  package, which\nuses the angular-notification  module.\nThe name of the module is  notification , so the hook implementation looks\nlike:  registrar.registerHook('shrubAngularPackageDependencies', function() {\n\n  return [\n    'notification'\n  ];\n});  This ensures our application has the  notification  module marked as a\ndependency. You will still need to use the shrubGruntConfig  hook to provide the actual\nJavaScript assets to the client.  Implementations must return  An array of strings naming the modules you want to include.  2 implementations \n   \n     shrub-html5-local-storage (server) implementation      shrub-html5-notification (server) implementation      1 invocation \n   \n     shrub-angular (server) invocation",
            "title": "shrubAngularPackageDependencies"
        },
        {
            "location": "/hooks/#shrubangularprovider",
            "text": "Define Angular providers.  See the Angular documentation \nfor more information about how to define and use providers.  Implementations must return  A provider constructor function.  3 implementations \n   \n     shrub-html5-local-storage (client) implementation      shrub-html5-notification (client) implementation      shrub-skin (client) implementation      1 invocation \n   \n     packages (client) invocation",
            "title": "shrubAngularProvider"
        },
        {
            "location": "/hooks/#shrubangularroutes",
            "text": "Define Angular routes.  Packages use this hook to define Angular routes.  Implementations must return  A route object.  See the Angular documentation \n(specifically the  route  parameter) for information on defining a route object.  Also note that the  path  parameter is defined in the route object itself.  8 implementations \n   \n     shrub-core (client) implementation      shrub-example/about (client) implementation      shrub-example/home (client) implementation      shrub-user-local/forgot (client) implementation      shrub-user-local/register (client) implementation      shrub-user-local/reset (client) implementation      shrub-user/login (client) implementation      shrub-user/logout (client) implementation      1 invocation \n   \n     shrub-angular (client) invocation",
            "title": "shrubAngularRoutes"
        },
        {
            "location": "/hooks/#shrubangularsandboxnavigationmiddleware",
            "text": "Define middleware to run when Angular is navigated in its sandbox.  Angular sandboxes retain navigation (and other) state for a client without\nJavaScript capability. When a user hits another page on the server, the\nsandbox navigates the Angular application to the new path. If the path\nchanged, the middleware collected by this hook are dispatched, allowing\npackages to react to the navigation change.  The  req  parameter to the middleware is an instance of http.IncomingMessage \nfrom the original HTTP request, along with the following extra properties:   (Sandbox)  sandbox  - The sandbox instance.   Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(req, next) {\n  ...\n}  1 implementation \n   \n     shrub-form (server) implementation      1 invocation \n   \n     shrub-angular-sandbox (server) invocation",
            "title": "shrubAngularSandboxNavigationMiddleware"
        },
        {
            "location": "/hooks/#shrubangularservice",
            "text": "Define Angular services.  Use this hook to define Angular services for your application.  See  the Angular documentation \nfor more information about how to define a service.  Implementations must return  An  annotated function  which returns a\nservice class/constructor function.  8 implementations \n   \n     shrub-form (client) implementation      shrub-orm (client) implementation      shrub-rpc (client) implementation      shrub-socket (client) implementation      shrub-ui/messages (client) implementation      shrub-ui/notifications (client) implementation      shrub-ui/window-title (client) implementation      shrub-user (client) implementation      1 invocation \n   \n     packages (client) invocation",
            "title": "shrubAngularService"
        },
        {
            "location": "/hooks/#shrubassetsmiddleware",
            "text": "Define assets to serve to the client application.  Packages may come bundled with JavaScript or CSS assets. This hook is how you\ncan provide them to the client application.  Asset middleware takes  assets  as its first argument. This is an object with\nthe following properties:   (String Array)  scripts  - A list of script assets.  (String Array)  stylesheets  - A list of sylesheet assets.   NOTE : This hook lets you serve assets, but will not automatically copy\nthem from your package to the  app  directory where they will be served.\nYou'll need to implement the  shrubGruntConfig \nhook for that.  Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(assets, next) {\n  ...\n}  8 implementations \n   \n     shrub-angular (server) implementation      shrub-assets (server) implementation      shrub-assets/jquery (server) implementation      shrub-config (server) implementation      shrub-grunt (server) implementation      shrub-html5-local-storage (server) implementation      shrub-html5-notification (server) implementation      shrub-socket-socket.io (server) implementation      1 invocation \n   \n     shrub-assets (server) invocation",
            "title": "shrubAssetsMiddleware"
        },
        {
            "location": "/hooks/#shrubauditfingerprint",
            "text": "Create a fingerprint for a connection .  Each request has a fingerprint generated which allows bad behavior to be\ntracked (like exceeding API limits).  Implementations must return  A keyed object of fingerprint values.  null  or  undefined  values will be\nfiltered out when doing most checks.  3 implementations \n   \n     shrub-core (server) implementation      shrub-session (server) implementation      shrub-user (server) implementation      1 invocation \n   \n     server/fingerprint (server) invocation",
            "title": "shrubAuditFingerprint"
        },
        {
            "location": "/hooks/#shrubconfigclient",
            "text": "Define configuration variables to be sent to the client.  Packages can implement this hook to pass configuration variables to the client.\nConfiguration is keyed by the name of the package.  Variables with  null  or  undefined  values will be filtered out and not sent\nto the client.  Implementations must return  A keyed object.  6 implementations \n   \n     shrub-core (server) implementation      shrub-skin (server) implementation      shrub-socket (server) implementation      shrub-ui (server) implementation      shrub-ui/notifications (server) implementation      shrub-user (server) implementation      1 invocation \n   \n     shrub-config (server) invocation",
            "title": "shrubConfigClient"
        },
        {
            "location": "/hooks/#shrubconfigclientalter",
            "text": "Alter configuration variables defined by packages.  Packages can implement this hook to alter configuration variables defined by\nany other (or even the same) package.  Implementations are passed a  Config  object.  See:  shrubConfigClient .  1 implementation \n   \n     shrub-grunt (server) implementation      1 invocation \n   \n     shrub-config (server) invocation",
            "title": "shrubConfigClientAlter"
        },
        {
            "location": "/hooks/#shrubconfigserver",
            "text": "Define server-side configuration settings.  Packages may use this hook to define default configuration for server-side\nfunctionality. These settings can be overridden in the settings file.  Implementations must return  A recursive object which will be folded into the server configuration under\nthe package name key. For instance, say we have a package  my-package  which\ndefines the hook like:  registrar.registerHook('shrubConfigServer', function() {\n  return {\n    one: 68,\n    two: {\n      three: 419\n    }\n  };\n});  You would then find those values in the configuration at:  config.get('packageSettings:my-package:one');\nconfig.get('packageSettings:my-package:two:three');  See  the default configuration file  for\nan example of how settings may be overridden. This should always be preferred\nto actually changing the code in a given package's hook.  13 implementations \n   \n     shrub-angular-sandbox (server) implementation      shrub-assets (server) implementation      shrub-core (server) implementation      shrub-http (server) implementation      shrub-nodemailer (server) implementation      shrub-orm (server) implementation      shrub-repl (server) implementation      shrub-session (server) implementation      shrub-skin (server) implementation      shrub-socket (server) implementation      shrub-user-reddit (server) implementation      shrub-user (server) implementation      shrub-villiany (server) implementation      1 invocation \n   \n     server/config (server) invocation",
            "title": "shrubConfigServer"
        },
        {
            "location": "/hooks/#shrubcorebootstrapmiddleware",
            "text": "Define middleware to run when the server application is bootstrapping.  This hook is where most of the major initialization work happens on the\nShrub server.  shrub-http  spins up an HTTP server, shrub-orm  spins up Waterline, and more.  Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(next) {\n  ...\n}  11 implementations \n   \n     shrub-angular-sandbox (server) implementation      shrub-http-express/session (server) implementation      shrub-http (server) implementation      shrub-install (server) implementation      shrub-nodemailer (server) implementation      shrub-orm (server) implementation      shrub-passport (server) implementation      shrub-repl (server) implementation      shrub-rpc (server) implementation      shrub-socket (server) implementation      shrub-ui/notifications (server) implementation      1 invocation \n   \n     server (server) invocation",
            "title": "shrubCoreBootstrapMiddleware"
        },
        {
            "location": "/hooks/#shrubcoreprebootstrap",
            "text": "Invoked before the application bootstrap phase.  Mitigate slow build times  If your package  require s heavy modules, you should require them in an\nimplementation of hook  shrubCorePreBootstrap . For instance, say you have a\npackage like:  var someHeavyModule = require('some-heavy-module');\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};  This will slow the build process down, since  some-heavy-module  must be\nloaded when loading your package. Use this pattern instead:  var someHeavyModule = null;\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubCorePreBootstrap', function() {\n    someHeavyModule = require('some-heavy-module');\n  });\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};  So that the heavy module will not be  require d until hook shrubCorePreBootstrap  is invoked.  13 implementations \n   \n     shrub-http-express (server) implementation      shrub-limiter (server) implementation      shrub-nodemailer (server) implementation      shrub-orm (server) implementation      shrub-passport (server) implementation      shrub-rpc (server) implementation      shrub-ui/notifications (server) implementation      shrub-user-local (server) implementation      shrub-user-local/register (server) implementation      shrub-user-reddit (server) implementation      shrub-user (server) implementation      shrub-user/login (server) implementation      shrub-villiany (server) implementation      1 invocation \n   \n     server (server) invocation",
            "title": "shrubCorePreBootstrap"
        },
        {
            "location": "/hooks/#shrubcoreprocessexit",
            "text": "Final cleanups as the process is exiting.  Shrub tries its hardest to always invoke this hook, even in the event of a\nraised signal or unhandled exception.  You should not schedule asynchronous events, as they will not be dispatched.\nSee  the Node.js documentation \nfor more information.  1 implementation \n   \n     shrub-repl (server) implementation      1 invocation \n   \n     server (server) invocation",
            "title": "shrubCoreProcessExit"
        },
        {
            "location": "/hooks/#shrubformalter",
            "text": "Alter any  form definition object \nbefore it's rendered.  Packages may implement this hook to modify the form definition object in any\nway.  1 invocation \n   \n     shrub-form (client) invocation",
            "title": "shrubFormAlter"
        },
        {
            "location": "/hooks/#shrubformformkeyalter",
            "text": "Alter any  form definition object  whose\nkey matches before it's rendered.  This hook targets a specific form key. The form key is automatically\ncamelized, e.g. form key  shrub-user-login  will match shrubFormShrubUserLoginAlter .  Packages may implement this hook to modify the form definition object in any\nway (although altering the key would probably be confusing at this point).  1 invocation \n   \n     shrub-form (client) invocation",
            "title": "shrubFormFormKeyAlter"
        },
        {
            "location": "/hooks/#shrubformwidgets",
            "text": "Define form widgets for use when defining form definition objects .  Implementations must return  An array of objects structured like:   (String)  type  - The widget type, used in form definition objects.  (String)  directive  - The directive used to render the widget.  (Optional Function)  assignToElement  - A function which can be used to apply\n  complex widget values to the widget element. The function takes two\n  parameters:  (jqLite/jQuery object)  element  - The widget's wrapped DOM element.  (Any)  value  - The value to apply to the widget element.     11 implementations \n   \n     shrub-form/widget/checkbox (client) implementation      shrub-form/widget/checkboxes (client) implementation      shrub-form/widget/group (client) implementation      shrub-form/widget/hidden (client) implementation      shrub-form/widget/markup (client) implementation      shrub-form/widget/radio (client) implementation      shrub-form/widget/radios (client) implementation      shrub-form/widget/select (client) implementation      shrub-form/widget/submit (client) implementation      shrub-form/widget/text (client) implementation      shrub-form/widget/textarea (client) implementation      1 invocation \n   \n     shrub-form (client) invocation",
            "title": "shrubFormWidgets"
        },
        {
            "location": "/hooks/#shrubgruntconfig",
            "text": "Hook into the Grunt build process.  This hook allows packages to define Grunt tasks, configure existing tasks, and\nload NPM tasks. This is achieved through the first implementation parameter\nwhich is an instance of the class GruntConfiguration . The grunt  object is passed in through the second parameter in case it's needed.  One of the most common uses of this hook is to copy any asset files your\npackage may include to the  app  directory, where they can be served to\nclients.  13 implementations \n   \n     shrub-angular (server) implementation      shrub-assets (server) implementation      shrub-grunt/dox (server) implementation      shrub-grunt (server) implementation      shrub-grunt/lint (server) implementation      shrub-grunt/modules (server) implementation      shrub-grunt/tests/build (server) implementation      shrub-grunt/tests/run (server) implementation      shrub-html5-local-storage (server) implementation      shrub-html5-notification (server) implementation      shrub-orm (server) implementation      shrub-skin-strapped (server) implementation      shrub-socket-socket.io (server) implementation      1 invocation \n   \n     Gruntfile (server) invocation",
            "title": "shrubGruntConfig"
        },
        {
            "location": "/hooks/#shrubgruntconfigalter",
            "text": "Alter the Grunt build process.  This hook allows packages to alter Grunt configuration specified through shrubGruntConfig .  The first implementation parameter is an instance of the class GruntConfiguration . The  grunt \nobject is passed in through the second parameter in case it's needed.  2 implementations \n   \n     shrub-grunt (server) implementation      shrub-grunt/tests/build (server) implementation      1 invocation \n   \n     Gruntfile (server) invocation",
            "title": "shrubGruntConfigAlter"
        },
        {
            "location": "/hooks/#shrubhttpmiddleware",
            "text": "Define middleware to run for every HTTP request.  The  req  parameter to the middleware is an instance of http.IncomingMessage \nfrom the HTTP request.  The  res  parameter to the middleware is an instance of http.ServerResponse \nfrom the HTTP request.  Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(req, res, next) {\n  ...\n}  13 implementations \n   \n     shrub-angular-sandbox (server) implementation      shrub-config (server) implementation      shrub-core (server) implementation      shrub-form (server) implementation      shrub-http-express/errors (server) implementation      shrub-http-express/logger (server) implementation      shrub-http-express/routes (server) implementation      shrub-http-express/session (server) implementation      shrub-http-express/static (server) implementation      shrub-http (server) implementation      shrub-passport (server) implementation      shrub-skin (server) implementation      shrub-villiany (server) implementation      1 invocation \n   \n     shrub-http/manager (server) invocation",
            "title": "shrubHttpMiddleware"
        },
        {
            "location": "/hooks/#shrubhttproutes",
            "text": "Define HTTP routes.  Packages use this hook to define HTTP routes.  Implementations must return  An array of objects structured like:   (String)  path  - The HTTP path of the route. Include the leading slash.  (String)  verb  - The HTTP verb to associate with this route. Defaults to\n   'get' .  (Function)  receiver  - The function invoked when the route is hit. Takes\n  three parameters:  (http.IncomingMessage)  req  - The request object.  (http.ServerResponse)  res  - The response object.  (Function)  fn  - A nodeback called when the route is complete.     2 implementations \n   \n     shrub-example/about (server) implementation      shrub-user-reddit (server) implementation      1 invocation \n   \n     shrub-http/manager (server) invocation",
            "title": "shrubHttpRoutes"
        },
        {
            "location": "/hooks/#shrublimitercheck",
            "text": "Specifiy criteria which will skip limiter checks.  You may bypass limit checks by returning  SKIP  ( shrub-limiter  package) from\nimplementations of this hook, e.g.  \nregistrar.registerHook('shrubLimiterCheck', function(req) {\n\n  if (req.somethingWeWantToCheck) {\n    return require('shrub-limiter').SKIP;\n  }\n})  Returning any other value besides  SKIP  will have no effect.  Implementation arguments   (http.IncomingMessage)  req : The route request object.   Implementations must return  SKIP  to skip the limiter check, or anything else otherwise.  1 invocation \n   \n     shrub-limiter (server) invocation",
            "title": "shrubLimiterCheck"
        },
        {
            "location": "/hooks/#shrubnodemailerhtml",
            "text": "Compose outgoing email.  This hook is implemented by skins. Only the active skin's implementation is\ncalled for any email.  Implementations accept the following parameters:   (cheerio element)  $body  - The body tag of the rendered app HTML, wrapped\n  with  cheerio , a lightweight\n  server-side implementation of a lot of jQuery's functionality.  (String)  html  - The mail HTML, generated from the directive.  (cheerio)  $  - The cheerio instance.   It is the skin's responsibility to inject the email HTML from the second\nparameter to where it belongs in the app HTML. The skin should also remove any\ntrace of dynamic JavaScript-driven functionality as that will surely break\nin email where such things are not allowed.  1 implementation \n   \n     shrub-skin-strapped (server) implementation      1 invocation \n   \n     shrub-nodemailer (server) invocation",
            "title": "shrubNodemailerHtml"
        },
        {
            "location": "/hooks/#shrubormcollections",
            "text": "Define collections of models.  Packages can implement this hook to define collections of models for use\nthroughout the server (and to a limited extent, the client) application.  Shrub uses Waterline as an ORM, so you can follow the Waterline documentation for how to define model collections .\nShrub handles calling  Waterline.Collection.extend , so you only have to return\nthe raw object.  Implementations must return  A keyed object whose values are raw model collection objects. e.g.  exports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('shrubOrmCollections', function() {\n\n    return {\n      'some-model': {\n        attributes: {\n          foo: 'string'\n        }\n      },\n      'some-other-model': {\n        attributes: {\n          bar: 'string'\n        }\n      }\n    };\n  });\n};  8 implementations \n   \n     shrub-user (client) implementation      shrub-user (server) implementation      shrub-limiter (server) implementation      shrub-session (server) implementation      shrub-ui/notifications (server) implementation      shrub-user-local (server) implementation      shrub-user-reddit (server) implementation      shrub-villiany (server) implementation      2 invocations \n   \n     shrub-orm (client) invocation      shrub-orm (server) invocation",
            "title": "shrubOrmCollections"
        },
        {
            "location": "/hooks/#shrubormcollectionsalter",
            "text": "Alter collections defined by packages.  Packages can implement this hook to alter collections defined by any other (or\neven the same) package.  Implementations are passed a keyed object containing all of the collections\ndefined by all modules.  See:  shrubOrmcollections .  1 implementation \n   \n     shrub-user (client) implementation      2 invocations \n   \n     shrub-orm (client) invocation      shrub-orm (server) invocation",
            "title": "shrubOrmCollectionsAlter"
        },
        {
            "location": "/hooks/#shrubreplcontext",
            "text": "Add to the REPL context.  Packages may use this hook to provide access to parts of their state to the\nREPL context.  Implementations accept the following arguments:   (Object)  context  - The context object.   To set context variables, simply set them on the context object.  5 implementations \n   \n     shrub-install (server) implementation      shrub-nodemailer (server) implementation      shrub-orm (server) implementation      shrub-socket (server) implementation      shrub-user-local/register (server) implementation      1 invocation \n   \n     shrub-repl (server) invocation",
            "title": "shrubReplContext"
        },
        {
            "location": "/hooks/#shrubrpccall",
            "text": "Notify packages when any RPC call is made.  Packages can implement this hook to be notified when any RPC call is made.\nFor instance,  shrub-ui/messages  uses\nthis hook to display an error message if any RPC call returned with an error.  Implementations must return  An  annotated function . The following\nlocals are injected:   (String)  route  - The RPC route path.  (Any)  data  - The data sent to the server.  (Promise)  result  - The result promise.   1 implementation \n   \n     shrub-ui/messages (client) implementation      1 invocation \n   \n     shrub-rpc (client) invocation",
            "title": "shrubRpcCall"
        },
        {
            "location": "/hooks/#shrubrpcroutes",
            "text": "Define RPC routes.  Packages use this hook to define RPC routes.  Implementations must return  An array of objects structured like:   (String)  path  - The HTTP path of the route. Include the leading slash.  (Function Array)  middleware  - A middleware stack which is dispatched when\n  the route is hit. The middleware have the following signature:   function(req, res, next) {\n  ...\n}  req  has the following properties set by default:   (Any)  body : The data passed in from the RPC call.  (Object)  route : the route definition object specified above.  (Socket)  socket : The raw socket object.   res  has the following properties set by default:   (Function)  end : Called with the data to respond to the RPC call.   7 implementations \n   \n     shrub-angular-sandbox (server) implementation      shrub-passport/logout (server) implementation      shrub-ui/notifications (server) implementation      shrub-user-local/forgot (server) implementation      shrub-user-local/register (server) implementation      shrub-user-local/reset (server) implementation      shrub-user/login (server) implementation      1 invocation \n   \n     shrub-rpc (server) invocation",
            "title": "shrubRpcRoutes"
        },
        {
            "location": "/hooks/#shrubrpcroutesalter",
            "text": "Alter RPC routes defined by packages.  Packages can implement this hook to alter RPC routes defined by any other (or\neven the same) package.  See:  shrubRpcRoutes .  7 implementations \n   \n     shrub-core (server) implementation      shrub-example (server) implementation      shrub-http-express (server) implementation      shrub-http-express/session (server) implementation      shrub-limiter (server) implementation      shrub-passport (server) implementation      shrub-villiany (server) implementation      1 invocation \n   \n     shrub-rpc (server) invocation",
            "title": "shrubRpcRoutesAlter"
        },
        {
            "location": "/hooks/#shrubskinassets",
            "text": "Allow skins to define extra assets that they include on the page.  By default, a skin includes an  app  directory containing assets which are\ncopied to the application's  app  directory. These assets are automatically\nincluded on each page depending on the execution environment. By default,\nproduction includes all stylesheets matching  *.min.css  and scripts matching *.min.js . All other environments include stylesheets matching the pattern *.css  (excluding  *.min.css ) and scripts matching  *.js  (excluding *.min.js ).  This is not always enough, since your skin may do its own building, e.g.\ncompiling LESS/Sass to CSS, and those resources need to be added to the page\nas well. This hook lets you do so.  1 implementation \n   \n     shrub-skin-strapped (server) implementation      1 invocation \n   \n     shrub-skin (server) invocation",
            "title": "shrubSkinAssets"
        },
        {
            "location": "/hooks/#shrubskinlink",
            "text": "Register a link function to run on all directives.  This hook allows packages to run additional link functions for directives. The\nlink functions are run every time skin or attribute changes result in directive\nrecompilation.  Implementations must return  An  annotated function . The following\nlocals are injected:   (Scope)  $scope  - Angular scope object for this directive.  (jqLite element)  $element : Directive DOM element.  (Attributes)  $attr : Directive attributes object.  (Function or Function Array or null)  $controller : Directive controller(s), if\n  any.  (Function or null)  $transclude : Transclusion function, if any.   1 implementation \n   \n     shrub-skin-strapped/form (client) implementation      1 invocation \n   \n     shrub-skin (client) invocation",
            "title": "shrubSkinLink"
        },
        {
            "location": "/hooks/#shrubskinlink-directive",
            "text": "Register a link function to run on directives matching directive name.  This hook allows packages to run additional link functions for directives. The\nlink functions are run every time skin or attribute changes result in directive\nrecompilation.  Implementations must return  An  annotated function . The following\nlocals are injected:   (Scope)  $scope  - Angular scope object for this directive.  (jqLite element)  $element : Directive DOM element.  (Attributes)  $attr : Directive attributes object.  (Function or Function Array or null)  $controller : Directive controller(s), if\n  any.  (Function or null)  $transclude : Transclusion function, if any.   3 implementations \n   \n     shrub-example (client) implementation      shrub-skin-strapped/form (client) implementation      shrub-skin-strapped/notifications (client) implementation      1 invocation \n   \n     shrub-skin (client) invocation",
            "title": "shrubSkinLink--DIRECTIVE"
        },
        {
            "location": "/hooks/#shrubskinlink-directive-id",
            "text": "Register a link function to run on directives matching directive name and ID.  This hook allows packages to run additional link functions for directives. The\nlink functions are run every time skin or attribute changes result in directive\nrecompilation.  Implementations must return  An  annotated function . The following\nlocals are injected:   (Scope)  $scope  - Angular scope object for this directive.  (jqLite element)  $element : Directive DOM element.  (Attributes)  $attr : Directive attributes object.  (Function or Function Array or null)  $controller : Directive controller(s), if\n  any.  (Function or null)  $transclude : Transclusion function, if any.   1 invocation \n   \n     shrub-skin (client) invocation",
            "title": "shrubSkinLink--DIRECTIVE--ID"
        },
        {
            "location": "/hooks/#shrubsocketconnectionmiddleware",
            "text": "Act after a socket connection.  Packages may implement this hook to take action after a socket is connected.  The  req  parameter to the middleware is an instance of http.IncomingMessage \nfrom the HTTP request.  The  res  parameter to the middleware is an instance of http.ServerResponse \nfrom the HTTP request.  Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(req, res, next) {\n  ...\n}  6 implementations \n   \n     shrub-core (server) implementation      shrub-http-express/session (server) implementation      shrub-passport (server) implementation      shrub-rpc (server) implementation      shrub-session (server) implementation      shrub-villiany (server) implementation      1 invocation \n   \n     shrub-socket/manager (server) invocation",
            "title": "shrubSocketConnectionMiddleware"
        },
        {
            "location": "/hooks/#shrubsocketdisconnectionmiddleware",
            "text": "Act after a socket disconnect.  Packages may implement this hook to take action after a socket is disconnected.  The  req  parameter to the middleware is an instance of http.IncomingMessage \nfrom the HTTP request.  The  res  parameter to the middleware is an instance of http.ServerResponse \nfrom the HTTP request.  Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(req, res, next) {\n  ...\n}  1 invocation \n   \n     shrub-socket/manager (server) invocation",
            "title": "shrubSocketDisconnectionMiddleware"
        },
        {
            "location": "/hooks/#shrubtransmittableerrors",
            "text": "Define errors that can be transmitted to the client.  See  the documentation on errors  for more information.  Implementations must return  An array of subclasses of TransmittableError .  6 implementations \n   \n     shrub-limiter (client) implementation      shrub-limiter (server) implementation      shrub-user-local (client) implementation      shrub-user-local (server) implementation      shrub-user (client) implementation      shrub-user (server) implementation      1 invocation \n   \n     modules/errors (client) invocation",
            "title": "shrubTransmittableErrors"
        },
        {
            "location": "/hooks/#shrubuinotificationqueues",
            "text": "Define persistent notification queues.  Packages may implement this hook to define queues of notifications.  Implementations must return  An object whose keys are queue names and whose values are structured like:   (Function)  channelFromRequest  - An idempotent function which returns the\n  channel of the queue. The channel is represented as a string value.\n  Typically the channel maps to the concept of ownership -- a queue which\n  stores some notifications for a user will likely belong to a channel\n  which is identical to the user ID. This function takes the following\n  parameters:  (http.IncomingMessage)  req  - The request object.     1 implementation \n   \n     shrub-example (server) implementation      1 invocation \n   \n     shrub-ui/notifications (server) invocation",
            "title": "shrubUiNotificationQueues"
        },
        {
            "location": "/hooks/#shrubuserafterloginmiddleware",
            "text": "Take action after a user logs in.  This hook allows packages to act after a user is logged in.  The  req  parameter to the middleware is an instance of http.IncomingMessage .  Note \n   \n     req.user  as well as  req.loggingInUser  will be\n    populated with the newly logged-in user at this point.\n     Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(req, next) {\n  ...\n}  1 invocation \n   \n     shrub-passport (server) invocation",
            "title": "shrubUserAfterLoginMiddleware"
        },
        {
            "location": "/hooks/#shrubuserafterlogoutmiddleware",
            "text": "Take action after a user logs out.  This hook allows packages to act after a user is logged out.  The  req  parameter to the middleware is an instance of http.IncomingMessage .  Note \n   \n     req.user  will  not  be populated with the\n    previously logged-out user at this point, but\n     req.loggingOutUser  will.\n     Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(req, next) {\n  ...\n}  1 invocation \n   \n     shrub-passport (server) invocation",
            "title": "shrubUserAfterLogoutMiddleware"
        },
        {
            "location": "/hooks/#shrubuserbeforeloginmiddleware",
            "text": "Take action before a user logs in.  This hook allows packages to act before a user is logged in. If an error is\nthrown or passed to the middleware  next  function, the login fails.  The  req  parameter to the middleware is an instance of http.IncomingMessage .  Note \n   \n     req.user  will  not  be populated with the\n    logging in user at this point, but  req.loggingInUser  will.\n     Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(req, next) {\n  ...\n}  1 implementation \n   \n     shrub-user (server) implementation      1 invocation \n   \n     shrub-passport (server) invocation",
            "title": "shrubUserBeforeLoginMiddleware"
        },
        {
            "location": "/hooks/#shrubuserbeforelogoutmiddleware",
            "text": "Take action before a user logs out.  This hook allows packages to act before a user is logged out. If an error is\nthrown or passed to the middleware  next  function, the logout fails.  The  req  parameter to the middleware is an instance of http.IncomingMessage .  Note \n   \n     req.user  as well as  req.loggingOutUser  will be\n    populated with the logging out user at this point.\n     Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(req, next) {\n  ...\n}  1 implementation \n   \n     shrub-user (server) implementation      1 invocation \n   \n     shrub-passport (server) invocation",
            "title": "shrubUserBeforeLogoutMiddleware"
        },
        {
            "location": "/hooks/#shrubuserloginstrategies",
            "text": "Define login strategies for users.  This hook allows packages to define login strategies.  Implementations must return    Client-side:    (string)  methodLabel  - A label used on the user login form to identify\nyour login strategy e.g.  Local .    (object)  fields  -  Shrub form fields definition  which\nare used on the login form under a subgroup for your login strategy. For\ninstance, the local user login strategy defines  username ,  password , submit  and a  forgot  markup link.      Server-side:\n   \n    (mixed)  ...  - A concrete strategy for the underlying authentication\n    framework that is active for the site. By default this is\n     shrub-passport  which requires a\n    strategy to implement a  passportStrategy  field e.g. an instance of\n     require('passport-local').Strategy .\n      4 implementations \n   \n     shrub-user-local (client) implementation      shrub-user-local (server) implementation      shrub-user-reddit (client) implementation      shrub-user-reddit (server) implementation      2 invocations \n   \n     shrub-user/login (client) invocation      shrub-passport (server) invocation",
            "title": "shrubUserLoginStrategies"
        },
        {
            "location": "/hooks/#shrubuserloginstrategiesalter",
            "text": "Alter defined login strategies for users.  This hook allows packages to alter defined login strategies.  Implementations can adjust:    Client-side:    (string)  methodLabel  - A label used on the user login form to identify\nyour login strategy e.g.  Local .    (object)  fields  -  Shrub form fields definition  which\nare used on the login form under a subgroup for your login strategy. For\ninstance, the local user login strategy defines  username ,  password , submit  and a  forgot  markup link.      Server-side:\n   \n    (mixed)  ...  - A concrete strategy for the underlying authentication\n    framework that is active for the site. By default this is\n     shrub-passport  which requires a\n    strategy to implement a  passportStrategy  field e.g. an instance of\n     require('passport-local').Strategy . If you are implementing some other\n    authorization framework, you would add the strategy implementation using\n    this hook.\n      2 invocations \n   \n     shrub-user/login (client) invocation      shrub-passport (server) invocation",
            "title": "shrubUserLoginStrategiesAlter"
        },
        {
            "location": "/hooks/#shrubuserredactors",
            "text": "Define functions to redact objects for users.  This hook allows packages to define redaction functions that take an object\nand a user and redact the object based on a user's permissions. For instance, shrub-user-local  defines redactors for shrub-user-local  models, which prune the  password  and  salt  fields. The\nredactor also checks if the local user belongs to the same user on whose\nbehalf the redaction is occuring. If it's the same user, the redactor decrypts\nand includes the  email  field. Otherwise, the  email  field is completely\nredacted.  Implementations must return  An object whose keys correspond to object types (a rule of thumb is to use\nthe model name e.g.  shrub-user ,  shrub-user-local , etc.) and whose value is\nan array of redaction functions.  Supposing we wanted to implement a redaction function which would redact the name  field for a  shrub-user-local  model, we could implement it like so:  exports.pkgmanRegister = (registrar) ->\n\n  # #### Implements hook `shrubUserRedactors`.\n  registrar.registerHook 'shrubUserRedactors', ->\n\n    'shrub-user-local': [\n\n      (object, user) ->\n\n        delete object.name\n        return object\n\n    ]  Note \n   \n    Redaction functions may return a promised redacted object.\n     3 implementations \n   \n     shrub-user-local (server) implementation      shrub-user-reddit (server) implementation      shrub-user (server) implementation      1 invocation \n   \n     shrub-user (server) invocation",
            "title": "shrubUserRedactors"
        },
        {
            "location": "/hooks/#shrubvillianyreport",
            "text": "Act on reported villianous actions.  Packages can invoke this hook to notify other packages that villianous behavior\nhas occurred. This is an abstract concept that is application-specific: one\napplication in core shrub is exceeding RPC call limits, however you could use\nthe system for things like user flagging, abusive behavior, etc.  Implementation arguments   (http.IncomingMessage)  req : The route request object.  (Number)  score : The numeric score this action contributes towards a ban.  (String)  key : A unique key for this villianous action.  (String Array)  excludedKeys : Fingerprint keys to exclude from ban.   Implementations must return  A boolean or a promise that resolves to boolean indicating whether or not the\nvillianous action results in a ban.  1 implementation \n   \n     shrub-villiany (server) implementation      1 invocation \n   \n     shrub-limiter (server) invocation",
            "title": "shrubVillianyReport"
        },
        {
            "location": "/packages/",
            "text": "Package reference\n\n\n\nPackages are how Shrub organizes functionality. Packages may be provided for\nthe server or the client (or both).\n\n\nThis page provides a listing of packages in this project, along with a short\ndescription of the functionality they provide.\n\n\nClient-side\n\n\nshrub-angular-sandbox/client\n\n\nAngular sandbox\n\n\nImplements hooks\n  \n\n    \nshrubAngularAppRun\nimplementation\n\n  \n\n\n\n\n\nshrub-angular/client\n\n\nAngular\n\n\nCoordinate various core functionality.\n\n\nImplements hooks\n  \n\n    \nshrubAngularAHrefSanitizationWhitelist\nimplementation\n\n    \nshrubAngularAppConfig\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubAngularAHrefSanitizationWhitelist\ninvocation\n\n    \nshrubAngularRoutes\ninvocation\n\n  \n\n\n\n\n\nshrub-core/client\n\n\nCore client functionality.\n\n\nCoordinate various core functionality.\n\n\nImplements hooks\n  \n\n    \nshrubAngularAppRun\nimplementation\n\n    \nshrubAngularRoutes\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-core/\nclient/test-e2e\n\n\n\n\n\n\nshrub-example/client\n\n\nExample package\n\n\nImplements hooks\n  \n\n    \nshrubSkinLink--DIRECTIVE\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-example/\nclient/about\n\n\nExample - About page\n\n\nImplements hooks\n  \n\n    \nshrubAngularRoutes\nimplementation\n\n  \n\n\n\n\nshrub-example/\nclient/home\n\n\nExample - Home page\n\n\nImplements hooks\n  \n\n    \nshrubAngularAppConfig\nimplementation\n\n    \nshrubAngularRoutes\nimplementation\n\n  \n\n\n\n\nshrub-example/\nclient/test-e2e\n\n\n\n\n\n\nshrub-form/client\n\n\nForm processing\n\n\nDefine a directive for Angular forms, and a service to cache and look them up later.\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubAngularService\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubFormAlter\ninvocation\n\n    \nshrubFormFormKeyAlter\ninvocation\n\n    \nshrubFormWidgets\ninvocation\n\n  \n\n\n\n\n\n\n\nshrub-form/\nclient/test-unit\n\n\n\n\nshrub-form/\nclient/widget/checkbox\n\n\nForm - checkbox\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/checkboxes\n\n\nForm - checkboxes\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/group\n\n\nForm - Group\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/hidden\n\n\nForm - Hidden element\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/markup\n\n\nForm - Markup\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/radio\n\n\nForm - Radio\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/radios\n\n\nForm - Radios\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/select\n\n\nForm - Select\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/submit\n\n\nForm - Submit\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/text\n\n\nForm - Text\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\nshrub-form/\nclient/widget/textarea\n\n\nForm - Text\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubFormWidgets\nimplementation\n\n  \n\n\n\n\n\n\nshrub-html5-audio/client\n\n\nHTML5 audio\n\n\nshrub-html5-local-storage/client\n\n\nHTML5 local storage\n\n\nProvide an Angular service to consume the HTML5 localStorage API.\n\n\nImplements hooks\n  \n\n    \nshrubAngularAppConfig\nimplementation\n\n    \nshrubAngularProvider\nimplementation\n\n  \n\n\n\n\n\nshrub-html5-notification/client\n\n\nHTML5 notifications\n\n\nImplements hooks\n  \n\n    \nshrubAngularAppConfig\nimplementation\n\n    \nshrubAngularProvider\nimplementation\n\n  \n\n\n\n\n\nshrub-limiter/client\n\n\nLimiter\n\n\nDefine a TransmittableError for the limiter.\n\n\nImplements hooks\n  \n\n    \nshrubTransmittableErrors\nimplementation\n\n  \n\n\n\n\n\nshrub-orm/client\n\n\nObject-relational mapping\n\n\nThis is mostly stubbed for the browser. I can't justify sending a 400k ORM library to the client, even though it would be awesome.\n\n\nImplements hooks\n  \n\n    \nshrubAngularService\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubOrmCollections\ninvocation\n\n    \nshrubOrmCollectionsAlter\ninvocation\n\n  \n\n\n\n\n\nshrub-rpc/client\n\n\nRPC\n\n\nDefine an Angular service to issue \nremote procedure calls\n.\n\n\nImplements hooks\n  \n\n    \nshrubAngularService\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubRpcCall\ninvocation\n\n  \n\n\n\n\n\n\n\nshrub-rpc/\nclient/test-unit\n\n\n\n\n\n\nshrub-skin-strapped/client\n\n\nStrapped - client\n\n\n\n\nshrub-skin-strapped/\nclient/form\n\n\nStrapped - Notifications\n\n\nImplements hooks\n  \n\n    \nshrubSkinLink\nimplementation\n\n    \nshrubSkinLink--DIRECTIVE\nimplementation\n\n  \n\n\n\n\nshrub-skin-strapped/\nclient/main-nav\n\n\nStrapped - Main navigation\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n  \n\n\n\n\nshrub-skin-strapped/\nclient/notifications\n\n\nStrapped - Notifications\n\n\nImplements hooks\n  \n\n    \nshrubSkinLink--DIRECTIVE\nimplementation\n\n  \n\n\n\n\n\n\nshrub-skin/client\n\n\nSkinning\n\n\nImplement the skin system, allowing clients to change the look and feel of the site on-the-fly, as well as quickly load assets from the default skin on page load.\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirectiveAlter\nimplementation\n\n    \nshrubAngularProvider\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubSkinLink\ninvocation\n\n    \nshrubSkinLink--DIRECTIVE\ninvocation\n\n    \nshrubSkinLink--DIRECTIVE--ID\ninvocation\n\n  \n\n\n\n\n\nshrub-socket-socket.io/client\n\n\nSocket.IO socket\n\n\nProvide an Angular service wrapping Socket.IO.\n\n\nshrub-socket/client\n\n\nSocket\n\n\nProvide an Angular service wrapping a real-time socket.\n\n\nImplements hooks\n  \n\n    \nshrubAngularService\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-socket/\nclient/dummy\n\n\nDummy socket\n\n\nMock out the socket manager.\n\n\nshrub-socket/\nclient/socket\n\n\nAbstract Socket\n\n\n\n\nshrub-ui/client\n\n\nUser Interface\n\n\nUser interface components.\n\n\n\n\nshrub-ui/\nclient/attributes\n\n\nUI - Attributes\n\n\nGeneralized attribute directive.\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n  \n\n\n\n\nshrub-ui/\nclient/list\n\n\nUI - List\n\n\nImplements hooks\n  \n\n    \nshrubAngularController\nimplementation\n\n    \nshrubAngularDirective\nimplementation\n\n  \n\n\n\n\nshrub-ui/\nclient/list/item\n\n\nUI - list item\n\n\nImplements hooks\n  \n\n    \nshrubAngularController\nimplementation\n\n    \nshrubAngularDirective\nimplementation\n\n  \n\n\n\n\nshrub-ui/\nclient/markdown\n\n\nUI - Markdown\n\n\nImplements hooks\n  \n\n    \nshrubAngularFilter\nimplementation\n\n  \n\n\n\n\nshrub-ui/\nclient/menu\n\n\nUI - Menu\n\n\nManage menus; essentially recursive lists with an emphasis on navigation.\n\n\nImplements hooks\n  \n\n    \nshrubAngularController\nimplementation\n\n    \nshrubAngularDirective\nimplementation\n\n  \n\n\n\n\nshrub-ui/\nclient/messages\n\n\nUI - Messages\n\n\nManage transient UI messages.\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubRpcCall\nimplementation\n\n    \nshrubAngularService\nimplementation\n\n    \nshrubAngularAppRun\nimplementation\n\n  \n\n\n\n\nshrub-ui/\nclient/notifications\n\n\nUI - Notifications\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubAngularService\nimplementation\n\n  \n\n\n\n\nshrub-ui/\nclient/notifications/item\n\n\nUI - Notifications item\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n  \n\n\n\n\nshrub-ui/\nclient/notifications/title\n\n\nUI - Notifications title\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n  \n\n\n\n\nshrub-ui/\nclient/test-unit\n\n\n\n\nshrub-ui/\nclient/window-title\n\n\nUI - Window title\n\n\nManage the window and page titles.\n\n\nImplements hooks\n  \n\n    \nshrubAngularController\nimplementation\n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubAngularAppRun\nimplementation\n\n    \nshrubAngularService\nimplementation\n\n  \n\n\n\n\n\n\nshrub-user-local/client\n\n\n\n\nImplements hooks\n  \n\n    \nshrubTransmittableErrors\nimplementation\n\n    \nshrubUserLoginStrategies\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-user-local/\nclient/email\n\n\nUser - email\n\n\nshrub-user-local/\nclient/email/forgot\n\n\nUser - Forgot password email\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n  \n\n\n\n\nshrub-user-local/\nclient/email/register\n\n\nUser - Register email\n\n\nImplements hooks\n  \n\n    \nshrubAngularDirective\nimplementation\n\n  \n\n\n\n\nshrub-user-local/\nclient/forgot\n\n\nUser - Forgot password\n\n\nImplements hooks\n  \n\n    \nshrubAngularRoutes\nimplementation\n\n  \n\n\n\n\nshrub-user-local/\nclient/register\n\n\nUser - Register\n\n\nImplements hooks\n  \n\n    \nshrubAngularRoutes\nimplementation\n\n  \n\n\n\n\nshrub-user-local/\nclient/reset\n\n\nUser - Reset password\n\n\nImplements hooks\n  \n\n    \nshrubAngularRoutes\nimplementation\n\n  \n\n\n\n\nshrub-user-local/\nclient/test-e2e\n\n\n\n\nshrub-user-local/\nclient/test-unit\n\n\n\n\n\n\nshrub-user-reddit/client\n\n\n\n\nImplements hooks\n  \n\n    \nshrubUserLoginStrategies\nimplementation\n\n  \n\n\n\n\n\nshrub-user/client\n\n\nUser\n\n\nUser operations, model, etc.\n\n\nImplements hooks\n  \n\n    \nshrubOrmCollections\nimplementation\n\n    \nshrubOrmCollectionsAlter\nimplementation\n\n    \nshrubAngularDirective\nimplementation\n\n    \nshrubAngularService\nimplementation\n\n    \nshrubTransmittableErrors\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-user/\nclient/login\n\n\nUser login\n\n\nImplements hooks\n  \n\n    \nshrubAngularRoutes\nimplementation\n\n  \n\n\n\n\nInvokes hooks\n  \n\n    \nshrubUserLoginStrategies\ninvocation\n\n    \nshrubUserLoginStrategiesAlter\ninvocation\n\n  \n\n\n\n\nshrub-user/\nclient/logout\n\n\nUser logout\n\n\nImplements hooks\n  \n\n    \nshrubAngularRoutes\nimplementation\n\n  \n\n\n\n\n\n\nServer-side\n\n\nshrub-angular\n\n\nAngular\n\n\nImplements hooks\n  \n\n    \nshrubAssetsMiddleware\nimplementation\n\n    \nshrubGruntConfig\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubAngularPackageDependencies\ninvocation\n\n  \n\n\n\n\n\nshrub-angular-sandbox\n\n\nAngular sandbox\n\n\nA sandboxed version of Angular, for clients lacking JS.\n\n\nImplements hooks\n  \n\n    \nshrubRpcRoutes\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubAngularSandboxNavigationMiddleware\ninvocation\n\n  \n\n\n\n\n\nshrub-assets\n\n\nAssets management\n\n\nGather, build, and serve assets defined by packages.\n\n\nImplements hooks\n  \n\n    \nshrubAssetsMiddleware\nimplementation\n\n    \nshrubGruntConfig\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubAssetsMiddleware\ninvocation\n\n  \n\n\n\n\n\n\n\nshrub-assets/\njquery\n\n\njQuery assets\n\n\nImplements hooks\n  \n\n    \nshrubAssetsMiddleware\nimplementation\n\n  \n\n\n\n\n\n\nshrub-config\n\n\nConfiguration\n\n\nGathers configuration and serves it as an Angular module for clients.\n\n\nImplements hooks\n  \n\n    \nshrubAssetsMiddleware\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubConfigClient\ninvocation\n\n    \nshrubConfigClientAlter\ninvocation\n\n  \n\n\n\n\n\nshrub-core\n\n\nCore server functionality\n\n\nCoordinate various core functionality.\n\n\nImplements hooks\n  \n\n    \nshrubConfigClient\nimplementation\n\n    \nshrubAuditFingerprint\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n    \nshrubRpcRoutesAlter\nimplementation\n\n    \nshrubSocketConnectionMiddleware\nimplementation\n\n  \n\n\n\n\n\nshrub-example\n\n\nExample package\n\n\nImplements hooks\n  \n\n    \nshrubRpcRoutesAlter\nimplementation\n\n    \nshrubUiNotificationQueues\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-example/\nabout\n\n\nExample - About page\n\n\nDefine a route to access the README.md page.\n\n\nImplements hooks\n  \n\n    \nshrubHttpRoutes\nimplementation\n\n  \n\n\n\n\n\n\nshrub-form\n\n\nForm processing\n\n\nHandle form and method parsing, and submission of POST'ed data into the Angular sandbox.\n\n\nImplements hooks\n  \n\n    \nshrubAngularSandboxNavigationMiddleware\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n  \n\n\n\n\n\nshrub-grunt\n\n\nGrunt build process\n\n\nImplements hooks\n  \n\n    \nshrubAssetsMiddleware\nimplementation\n\n    \nshrubConfigClientAlter\nimplementation\n\n    \nshrubGruntConfig\nimplementation\n\n    \nshrubGruntConfigAlter\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-grunt/\ndox\n\n\nGrunt build process - Documentation\n\n\nBuild the documentation in \ngh-pages\n.\n\n\nImplements hooks\n  \n\n    \nshrubGruntConfig\nimplementation\n\n  \n\n\n\n\nshrub-grunt/\ndox/dynamic\n\n\nGrunt build process - Dynamic documentation\n\n\nshrub-grunt/\nlint\n\n\nGrunt build process - (de)Linting\n\n\nImplements hooks\n  \n\n    \nshrubGruntConfig\nimplementation\n\n  \n\n\n\n\nshrub-grunt/\nmodules\n\n\nGrunt build process - Modules\n\n\nImplements hooks\n  \n\n    \nshrubGruntConfig\nimplementation\n\n  \n\n\n\n\nshrub-grunt/\ntests\n\n\nGrunt build process - Tests\n\n\nBuild and run the tests.\n\n\nshrub-grunt/\ntests/build\n\n\nGrunt build process - Build tests\n\n\nImplements hooks\n  \n\n    \nshrubGruntConfig\nimplementation\n\n    \nshrubGruntConfigAlter\nimplementation\n\n  \n\n\n\n\nshrub-grunt/\ntests/run\n\n\nGrunt build process - Run tests\n\n\nImplements hooks\n  \n\n    \nshrubGruntConfig\nimplementation\n\n  \n\n\n\n\n\n\nshrub-html5-audio\n\n\nHTML5 audio\n\n\nshrub-html5-local-storage\n\n\nHTML5 local storage\n\n\nBuild and serve the HTML5 localStorage support.\n\n\nImplements hooks\n  \n\n    \nshrubGruntConfig\nimplementation\n\n    \nshrubAssetsMiddleware\nimplementation\n\n    \nshrubAngularPackageDependencies\nimplementation\n\n  \n\n\n\n\n\nshrub-html5-notification\n\n\nHTML5 notification\n\n\nBuild and serve the HTML5 notification support.\n\n\nImplements hooks\n  \n\n    \nshrubGruntConfig\nimplementation\n\n    \nshrubAssetsMiddleware\nimplementation\n\n    \nshrubAngularPackageDependencies\nimplementation\n\n  \n\n\n\n\n\nshrub-http\n\n\nHTTP\n\n\nManage HTTP connections.\n\n\nImplements hooks\n  \n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n  \n\n\n\n\n\nshrub-http-express\n\n\nExpress\n\n\nAn \nExpress\n HTTP server implementation, with middleware for sessions, routing, logging, etc.\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubRpcRoutesAlter\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-http-express/\nerrors\n\n\nExpress - error handler\n\n\nImplements hooks\n  \n\n    \nshrubHttpMiddleware\nimplementation\n\n  \n\n\n\n\nshrub-http-express/\nlogger\n\n\nExpress - logger\n\n\nImplements hooks\n  \n\n    \nshrubHttpMiddleware\nimplementation\n\n  \n\n\n\n\nshrub-http-express/\nroutes\n\n\nExpress - routes\n\n\nImplements hooks\n  \n\n    \nshrubHttpMiddleware\nimplementation\n\n  \n\n\n\n\nshrub-http-express/\nsession\n\n\nExpress - routes\n\n\nImplements hooks\n  \n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n    \nshrubRpcRoutesAlter\nimplementation\n\n    \nshrubSocketConnectionMiddleware\nimplementation\n\n  \n\n\n\n\nshrub-http-express/\nstatic\n\n\nExpress - static files\n\n\nImplements hooks\n  \n\n    \nshrubHttpMiddleware\nimplementation\n\n  \n\n\n\n\nshrub-http/\nmanager\n\n\nHTTP Manager\n\n\nManage an HTTP server instance.\n\n\nInvokes hooks\n  \n\n    \nshrubHttpRoutes\ninvocation\n\n    \nshrubHttpMiddleware\ninvocation\n\n  \n\n\n\n\n\n\nshrub-install\n\n\nInstallation\n\n\nInstall shrub if it hasn't been done so yet. This is essentially a hack for now, but will be fleshed out as we go.\n\n\nImplements hooks\n  \n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubReplContext\nimplementation\n\n  \n\n\n\n\n\nshrub-limiter\n\n\nRate limiter\n\n\nLimits the rate at which clients can do certain operations, like call RPC routes.\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubOrmCollections\nimplementation\n\n    \nshrubRpcRoutesAlter\nimplementation\n\n    \nshrubTransmittableErrors\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubLimiterCheck\ninvocation\n\n    \nshrubVillianyReport\ninvocation\n\n  \n\n\n\n\n\n\n\nshrub-limiter/\nlimiter\n\n\nLimiter\n\n\nORM-backed limit handling. Accrue and check scores, and check Time-to-live across multiple \nfingerprint keys\n.\n\n\n\n\nshrub-nodemailer\n\n\nnodemailer\n\n\nRenders and sends email.\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n    \nshrubReplContext\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubNodemailerHtml\ninvocation\n\n  \n\n\n\n\n\nshrub-orm\n\n\nObject-relational mapping\n\n\nTools for working with \nWaterline\n.\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubGruntConfig\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n    \nshrubReplContext\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubOrmCollections\ninvocation\n\n    \nshrubOrmCollectionsAlter\ninvocation\n\n  \n\n\n\n\n\nshrub-passport\n\n\nPassport integration\n\n\nAuthentication system, leaning on \npassport\n.\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n    \nshrubRpcRoutesAlter\nimplementation\n\n    \nshrubSocketConnectionMiddleware\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubUserBeforeLoginMiddleware\ninvocation\n\n    \nshrubUserAfterLoginMiddleware\ninvocation\n\n    \nshrubUserBeforeLogoutMiddleware\ninvocation\n\n    \nshrubUserAfterLogoutMiddleware\ninvocation\n\n    \nshrubUserLoginStrategies\ninvocation\n\n    \nshrubUserLoginStrategiesAlter\ninvocation\n\n  \n\n\n\n\n\n\n\nshrub-passport/\nlogout\n\n\nUser logout\n\n\nImplements hooks\n  \n\n    \nshrubRpcRoutes\nimplementation\n\n  \n\n\n\n\n\n\nshrub-repl\n\n\nREPL\n\n\nRuns a REPL and allows packages to add values to its context.\n\n\nImplements hooks\n  \n\n    \nshrubConfigServer\nimplementation\n\n    \nshrubCoreProcessExit\nimplementation\n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubReplContext\ninvocation\n\n  \n\n\n\n\n\nshrub-rpc\n\n\nRPC\n\n\nFramework for communication between client and server through \nRPC\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubSocketConnectionMiddleware\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubRpcRoutes\ninvocation\n\n    \nshrubRpcRoutesAlter\ninvocation\n\n  \n\n\n\n\n\nshrub-schema-rest\n\n\nREST API for database schema\n\n\nServe the database schema over a REST API.\n\n\nshrub-session\n\n\nSession\n\n\nManage sessions across HTTP and socket connections.\n\n\nImplements hooks\n  \n\n    \nshrubOrmCollections\nimplementation\n\n    \nshrubAuditFingerprint\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n    \nshrubSocketConnectionMiddleware\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-session/\nstore\n\n\nSession store\n\n\n*An implementation of express's \nSession Store\n API.\n\n\n\n\nshrub-skin\n\n\nSkin\n\n\nAllows the visual aspects of the site to be controlled by skin packages.\n\n\nImplements hooks\n  \n\n    \nshrubConfigClient\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubSkinAssets\ninvocation\n\n  \n\n\n\n\n\nshrub-skin-strapped\n\n\nStrapped\n\n\nShrub's default skin.\n\n\nImplements hooks\n  \n\n    \nshrubNodemailerHtml\nimplementation\n\n    \nshrubSkinAssets\nimplementation\n\n    \nshrubGruntConfig\nimplementation\n\n  \n\n\n\n\n\nshrub-socket\n\n\nSocket\n\n\nManage socket connections.\n\n\nImplements hooks\n  \n\n    \nshrubConfigClient\nimplementation\n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n    \nshrubReplContext\nimplementation\n\n  \n\n\n\n\n\nshrub-socket-socket.io\n\n\nSocket.IO\n\n\nBuild and serve \nSocket.IO\n.\n\n\nImplements hooks\n  \n\n    \nshrubAssetsMiddleware\nimplementation\n\n    \nshrubGruntConfig\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-socket-socket.io/\nmanager\n\n\nSocketIoManager\n\n\nA \nSocket.IO\n implementation of SocketManager.\n\n\nshrub-socket/\nmanager\n\n\nSocketManager\n\n\nInvokes hooks\n  \n\n    \nshrubSocketConnectionMiddleware\ninvocation\n\n    \nshrubSocketDisconnectionMiddleware\ninvocation\n\n  \n\n\n\n\n\n\nshrub-ui\n\n\nUser Interface\n\n\nImplements hooks\n  \n\n    \nshrubConfigClient\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-ui/\nnotifications\n\n\nUI - Notifications\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubCoreBootstrapMiddleware\nimplementation\n\n    \nshrubOrmCollections\nimplementation\n\n    \nshrubConfigClient\nimplementation\n\n    \nshrubRpcRoutes\nimplementation\n\n  \n\n\n\n\nInvokes hooks\n  \n\n    \nshrubUiNotificationQueues\ninvocation\n\n  \n\n\n\n\n\n\nshrub-user\n\n\nUser\n\n\nUser operations.\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubConfigClient\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n    \nshrubUserRedactors\nimplementation\n\n    \nshrubAuditFingerprint\nimplementation\n\n    \nshrubOrmCollections\nimplementation\n\n    \nshrubTransmittableErrors\nimplementation\n\n    \nshrubUserBeforeLoginMiddleware\nimplementation\n\n    \nshrubUserBeforeLogoutMiddleware\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \nshrubUserRedactors\ninvocation\n\n  \n\n\n\n\n\nshrub-user-local\n\n\n\n\nLocal user authentication.\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubUserLoginStrategies\nimplementation\n\n    \nshrubUserRedactors\nimplementation\n\n    \nshrubOrmCollections\nimplementation\n\n    \nshrubTransmittableErrors\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-user-local/\nforgot\n\n\nUser - Forgot password\n\n\nImplements hooks\n  \n\n    \nshrubRpcRoutes\nimplementation\n\n  \n\n\n\n\nshrub-user-local/\nregister\n\n\nUser - Registration\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubRpcRoutes\nimplementation\n\n    \nshrubReplContext\nimplementation\n\n  \n\n\n\n\nshrub-user-local/\nreset\n\n\nUser - Password reset\n\n\nImplements hooks\n  \n\n    \nshrubRpcRoutes\nimplementation\n\n  \n\n\n\n\n\n\nshrub-user-reddit\n\n\n\n\nAuthorize using a reddit account.\n\n\nImplements hooks\n  \n\n    \nshrubConfigServer\nimplementation\n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubUserLoginStrategies\nimplementation\n\n    \nshrubHttpRoutes\nimplementation\n\n    \nshrubUserRedactors\nimplementation\n\n    \nshrubOrmCollections\nimplementation\n\n  \n\n\n\n\n\n\n\nshrub-user/\nlogin\n\n\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubRpcRoutes\nimplementation\n\n  \n\n\n\n\n\n\nshrub-villiany\n\n\nVilliany\n\n\nWatch for and punish bad behavior.\n\n\nImplements hooks\n  \n\n    \nshrubCorePreBootstrap\nimplementation\n\n    \nshrubOrmCollections\nimplementation\n\n    \nshrubHttpMiddleware\nimplementation\n\n    \nshrubConfigServer\nimplementation\n\n    \nshrubSocketConnectionMiddleware\nimplementation\n\n    \nshrubRpcRoutesAlter\nimplementation\n\n    \nshrubVillianyReport\nimplementation",
            "title": "Packages"
        },
        {
            "location": "/packages/#client-side",
            "text": "",
            "title": "Client-side"
        },
        {
            "location": "/packages/#shrub-angular-sandboxclient",
            "text": "Angular sandbox  Implements hooks    \n     shrubAngularAppRun implementation",
            "title": "shrub-angular-sandbox/client"
        },
        {
            "location": "/packages/#shrub-angularclient",
            "text": "Angular  Coordinate various core functionality.  Implements hooks    \n     shrubAngularAHrefSanitizationWhitelist implementation \n     shrubAngularAppConfig implementation \n     Invokes hooks    \n     shrubAngularAHrefSanitizationWhitelist invocation \n     shrubAngularRoutes invocation",
            "title": "shrub-angular/client"
        },
        {
            "location": "/packages/#shrub-coreclient",
            "text": "Core client functionality.  Coordinate various core functionality.  Implements hooks    \n     shrubAngularAppRun implementation \n     shrubAngularRoutes implementation",
            "title": "shrub-core/client"
        },
        {
            "location": "/packages/#shrub-coreclienttest-e2e",
            "text": "",
            "title": "shrub-core/client/test-e2e"
        },
        {
            "location": "/packages/#shrub-exampleclient",
            "text": "Example package  Implements hooks    \n     shrubSkinLink--DIRECTIVE implementation",
            "title": "shrub-example/client"
        },
        {
            "location": "/packages/#shrub-exampleclientabout",
            "text": "Example - About page  Implements hooks    \n     shrubAngularRoutes implementation",
            "title": "shrub-example/client/about"
        },
        {
            "location": "/packages/#shrub-exampleclienthome",
            "text": "Example - Home page  Implements hooks    \n     shrubAngularAppConfig implementation \n     shrubAngularRoutes implementation",
            "title": "shrub-example/client/home"
        },
        {
            "location": "/packages/#shrub-exampleclienttest-e2e",
            "text": "",
            "title": "shrub-example/client/test-e2e"
        },
        {
            "location": "/packages/#shrub-formclient",
            "text": "Form processing  Define a directive for Angular forms, and a service to cache and look them up later.  Implements hooks    \n     shrubAngularDirective implementation \n     shrubAngularService implementation \n     Invokes hooks    \n     shrubFormAlter invocation \n     shrubFormFormKeyAlter invocation \n     shrubFormWidgets invocation",
            "title": "shrub-form/client"
        },
        {
            "location": "/packages/#shrub-formclienttest-unit",
            "text": "",
            "title": "shrub-form/client/test-unit"
        },
        {
            "location": "/packages/#shrub-formclientwidgetcheckbox",
            "text": "Form - checkbox  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/checkbox"
        },
        {
            "location": "/packages/#shrub-formclientwidgetcheckboxes",
            "text": "Form - checkboxes  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/checkboxes"
        },
        {
            "location": "/packages/#shrub-formclientwidgetgroup",
            "text": "Form - Group  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/group"
        },
        {
            "location": "/packages/#shrub-formclientwidgethidden",
            "text": "Form - Hidden element  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/hidden"
        },
        {
            "location": "/packages/#shrub-formclientwidgetmarkup",
            "text": "Form - Markup  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/markup"
        },
        {
            "location": "/packages/#shrub-formclientwidgetradio",
            "text": "Form - Radio  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/radio"
        },
        {
            "location": "/packages/#shrub-formclientwidgetradios",
            "text": "Form - Radios  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/radios"
        },
        {
            "location": "/packages/#shrub-formclientwidgetselect",
            "text": "Form - Select  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/select"
        },
        {
            "location": "/packages/#shrub-formclientwidgetsubmit",
            "text": "Form - Submit  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/submit"
        },
        {
            "location": "/packages/#shrub-formclientwidgettext",
            "text": "Form - Text  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/text"
        },
        {
            "location": "/packages/#shrub-formclientwidgettextarea",
            "text": "Form - Text  Implements hooks    \n     shrubAngularDirective implementation \n     shrubFormWidgets implementation",
            "title": "shrub-form/client/widget/textarea"
        },
        {
            "location": "/packages/#shrub-html5-audioclient",
            "text": "HTML5 audio",
            "title": "shrub-html5-audio/client"
        },
        {
            "location": "/packages/#shrub-html5-local-storageclient",
            "text": "HTML5 local storage  Provide an Angular service to consume the HTML5 localStorage API.  Implements hooks    \n     shrubAngularAppConfig implementation \n     shrubAngularProvider implementation",
            "title": "shrub-html5-local-storage/client"
        },
        {
            "location": "/packages/#shrub-html5-notificationclient",
            "text": "HTML5 notifications  Implements hooks    \n     shrubAngularAppConfig implementation \n     shrubAngularProvider implementation",
            "title": "shrub-html5-notification/client"
        },
        {
            "location": "/packages/#shrub-limiterclient",
            "text": "Limiter  Define a TransmittableError for the limiter.  Implements hooks    \n     shrubTransmittableErrors implementation",
            "title": "shrub-limiter/client"
        },
        {
            "location": "/packages/#shrub-ormclient",
            "text": "Object-relational mapping  This is mostly stubbed for the browser. I can't justify sending a 400k ORM library to the client, even though it would be awesome.  Implements hooks    \n     shrubAngularService implementation \n     Invokes hooks    \n     shrubOrmCollections invocation \n     shrubOrmCollectionsAlter invocation",
            "title": "shrub-orm/client"
        },
        {
            "location": "/packages/#shrub-rpcclient",
            "text": "RPC  Define an Angular service to issue  remote procedure calls .  Implements hooks    \n     shrubAngularService implementation \n     Invokes hooks    \n     shrubRpcCall invocation",
            "title": "shrub-rpc/client"
        },
        {
            "location": "/packages/#shrub-rpcclienttest-unit",
            "text": "",
            "title": "shrub-rpc/client/test-unit"
        },
        {
            "location": "/packages/#shrub-skin-strappedclient",
            "text": "Strapped - client",
            "title": "shrub-skin-strapped/client"
        },
        {
            "location": "/packages/#shrub-skin-strappedclientform",
            "text": "Strapped - Notifications  Implements hooks    \n     shrubSkinLink implementation \n     shrubSkinLink--DIRECTIVE implementation",
            "title": "shrub-skin-strapped/client/form"
        },
        {
            "location": "/packages/#shrub-skin-strappedclientmain-nav",
            "text": "Strapped - Main navigation  Implements hooks    \n     shrubAngularDirective implementation",
            "title": "shrub-skin-strapped/client/main-nav"
        },
        {
            "location": "/packages/#shrub-skin-strappedclientnotifications",
            "text": "Strapped - Notifications  Implements hooks    \n     shrubSkinLink--DIRECTIVE implementation",
            "title": "shrub-skin-strapped/client/notifications"
        },
        {
            "location": "/packages/#shrub-skinclient",
            "text": "Skinning  Implement the skin system, allowing clients to change the look and feel of the site on-the-fly, as well as quickly load assets from the default skin on page load.  Implements hooks    \n     shrubAngularDirectiveAlter implementation \n     shrubAngularProvider implementation \n     Invokes hooks    \n     shrubSkinLink invocation \n     shrubSkinLink--DIRECTIVE invocation \n     shrubSkinLink--DIRECTIVE--ID invocation",
            "title": "shrub-skin/client"
        },
        {
            "location": "/packages/#shrub-socket-socketioclient",
            "text": "Socket.IO socket  Provide an Angular service wrapping Socket.IO.",
            "title": "shrub-socket-socket.io/client"
        },
        {
            "location": "/packages/#shrub-socketclient",
            "text": "Socket  Provide an Angular service wrapping a real-time socket.  Implements hooks    \n     shrubAngularService implementation",
            "title": "shrub-socket/client"
        },
        {
            "location": "/packages/#shrub-socketclientdummy",
            "text": "Dummy socket  Mock out the socket manager.",
            "title": "shrub-socket/client/dummy"
        },
        {
            "location": "/packages/#shrub-socketclientsocket",
            "text": "Abstract Socket",
            "title": "shrub-socket/client/socket"
        },
        {
            "location": "/packages/#shrub-uiclient",
            "text": "User Interface  User interface components.",
            "title": "shrub-ui/client"
        },
        {
            "location": "/packages/#shrub-uiclientattributes",
            "text": "UI - Attributes  Generalized attribute directive.  Implements hooks    \n     shrubAngularDirective implementation",
            "title": "shrub-ui/client/attributes"
        },
        {
            "location": "/packages/#shrub-uiclientlist",
            "text": "UI - List  Implements hooks    \n     shrubAngularController implementation \n     shrubAngularDirective implementation",
            "title": "shrub-ui/client/list"
        },
        {
            "location": "/packages/#shrub-uiclientlistitem",
            "text": "UI - list item  Implements hooks    \n     shrubAngularController implementation \n     shrubAngularDirective implementation",
            "title": "shrub-ui/client/list/item"
        },
        {
            "location": "/packages/#shrub-uiclientmarkdown",
            "text": "UI - Markdown  Implements hooks    \n     shrubAngularFilter implementation",
            "title": "shrub-ui/client/markdown"
        },
        {
            "location": "/packages/#shrub-uiclientmenu",
            "text": "UI - Menu  Manage menus; essentially recursive lists with an emphasis on navigation.  Implements hooks    \n     shrubAngularController implementation \n     shrubAngularDirective implementation",
            "title": "shrub-ui/client/menu"
        },
        {
            "location": "/packages/#shrub-uiclientmessages",
            "text": "UI - Messages  Manage transient UI messages.  Implements hooks    \n     shrubAngularDirective implementation \n     shrubRpcCall implementation \n     shrubAngularService implementation \n     shrubAngularAppRun implementation",
            "title": "shrub-ui/client/messages"
        },
        {
            "location": "/packages/#shrub-uiclientnotifications",
            "text": "UI - Notifications  Implements hooks    \n     shrubAngularDirective implementation \n     shrubAngularService implementation",
            "title": "shrub-ui/client/notifications"
        },
        {
            "location": "/packages/#shrub-uiclientnotificationsitem",
            "text": "UI - Notifications item  Implements hooks    \n     shrubAngularDirective implementation",
            "title": "shrub-ui/client/notifications/item"
        },
        {
            "location": "/packages/#shrub-uiclientnotificationstitle",
            "text": "UI - Notifications title  Implements hooks    \n     shrubAngularDirective implementation",
            "title": "shrub-ui/client/notifications/title"
        },
        {
            "location": "/packages/#shrub-uiclienttest-unit",
            "text": "",
            "title": "shrub-ui/client/test-unit"
        },
        {
            "location": "/packages/#shrub-uiclientwindow-title",
            "text": "UI - Window title  Manage the window and page titles.  Implements hooks    \n     shrubAngularController implementation \n     shrubAngularDirective implementation \n     shrubAngularAppRun implementation \n     shrubAngularService implementation",
            "title": "shrub-ui/client/window-title"
        },
        {
            "location": "/packages/#shrub-user-localclient",
            "text": "Implements hooks    \n     shrubTransmittableErrors implementation \n     shrubUserLoginStrategies implementation",
            "title": "shrub-user-local/client"
        },
        {
            "location": "/packages/#shrub-user-localclientemail",
            "text": "User - email",
            "title": "shrub-user-local/client/email"
        },
        {
            "location": "/packages/#shrub-user-localclientemailforgot",
            "text": "User - Forgot password email  Implements hooks    \n     shrubAngularDirective implementation",
            "title": "shrub-user-local/client/email/forgot"
        },
        {
            "location": "/packages/#shrub-user-localclientemailregister",
            "text": "User - Register email  Implements hooks    \n     shrubAngularDirective implementation",
            "title": "shrub-user-local/client/email/register"
        },
        {
            "location": "/packages/#shrub-user-localclientforgot",
            "text": "User - Forgot password  Implements hooks    \n     shrubAngularRoutes implementation",
            "title": "shrub-user-local/client/forgot"
        },
        {
            "location": "/packages/#shrub-user-localclientregister",
            "text": "User - Register  Implements hooks    \n     shrubAngularRoutes implementation",
            "title": "shrub-user-local/client/register"
        },
        {
            "location": "/packages/#shrub-user-localclientreset",
            "text": "User - Reset password  Implements hooks    \n     shrubAngularRoutes implementation",
            "title": "shrub-user-local/client/reset"
        },
        {
            "location": "/packages/#shrub-user-localclienttest-e2e",
            "text": "",
            "title": "shrub-user-local/client/test-e2e"
        },
        {
            "location": "/packages/#shrub-user-localclienttest-unit",
            "text": "",
            "title": "shrub-user-local/client/test-unit"
        },
        {
            "location": "/packages/#shrub-user-redditclient",
            "text": "Implements hooks    \n     shrubUserLoginStrategies implementation",
            "title": "shrub-user-reddit/client"
        },
        {
            "location": "/packages/#shrub-userclient",
            "text": "User  User operations, model, etc.  Implements hooks    \n     shrubOrmCollections implementation \n     shrubOrmCollectionsAlter implementation \n     shrubAngularDirective implementation \n     shrubAngularService implementation \n     shrubTransmittableErrors implementation",
            "title": "shrub-user/client"
        },
        {
            "location": "/packages/#shrub-userclientlogin",
            "text": "User login  Implements hooks    \n     shrubAngularRoutes implementation \n     Invokes hooks    \n     shrubUserLoginStrategies invocation \n     shrubUserLoginStrategiesAlter invocation",
            "title": "shrub-user/client/login"
        },
        {
            "location": "/packages/#shrub-userclientlogout",
            "text": "User logout  Implements hooks    \n     shrubAngularRoutes implementation",
            "title": "shrub-user/client/logout"
        },
        {
            "location": "/packages/#server-side",
            "text": "",
            "title": "Server-side"
        },
        {
            "location": "/packages/#shrub-angular",
            "text": "Angular  Implements hooks    \n     shrubAssetsMiddleware implementation \n     shrubGruntConfig implementation \n     Invokes hooks    \n     shrubAngularPackageDependencies invocation",
            "title": "shrub-angular"
        },
        {
            "location": "/packages/#shrub-angular-sandbox",
            "text": "Angular sandbox  A sandboxed version of Angular, for clients lacking JS.  Implements hooks    \n     shrubRpcRoutes implementation \n     shrubHttpMiddleware implementation \n     shrubCoreBootstrapMiddleware implementation \n     shrubConfigServer implementation \n     Invokes hooks    \n     shrubAngularSandboxNavigationMiddleware invocation",
            "title": "shrub-angular-sandbox"
        },
        {
            "location": "/packages/#shrub-assets",
            "text": "Assets management  Gather, build, and serve assets defined by packages.  Implements hooks    \n     shrubAssetsMiddleware implementation \n     shrubGruntConfig implementation \n     shrubConfigServer implementation \n     Invokes hooks    \n     shrubAssetsMiddleware invocation",
            "title": "shrub-assets"
        },
        {
            "location": "/packages/#shrub-assetsjquery",
            "text": "jQuery assets  Implements hooks    \n     shrubAssetsMiddleware implementation",
            "title": "shrub-assets/jquery"
        },
        {
            "location": "/packages/#shrub-config",
            "text": "Configuration  Gathers configuration and serves it as an Angular module for clients.  Implements hooks    \n     shrubAssetsMiddleware implementation \n     shrubHttpMiddleware implementation \n     Invokes hooks    \n     shrubConfigClient invocation \n     shrubConfigClientAlter invocation",
            "title": "shrub-config"
        },
        {
            "location": "/packages/#shrub-core",
            "text": "Core server functionality  Coordinate various core functionality.  Implements hooks    \n     shrubConfigClient implementation \n     shrubAuditFingerprint implementation \n     shrubHttpMiddleware implementation \n     shrubConfigServer implementation \n     shrubRpcRoutesAlter implementation \n     shrubSocketConnectionMiddleware implementation",
            "title": "shrub-core"
        },
        {
            "location": "/packages/#shrub-example",
            "text": "Example package  Implements hooks    \n     shrubRpcRoutesAlter implementation \n     shrubUiNotificationQueues implementation",
            "title": "shrub-example"
        },
        {
            "location": "/packages/#shrub-exampleabout",
            "text": "Example - About page  Define a route to access the README.md page.  Implements hooks    \n     shrubHttpRoutes implementation",
            "title": "shrub-example/about"
        },
        {
            "location": "/packages/#shrub-form",
            "text": "Form processing  Handle form and method parsing, and submission of POST'ed data into the Angular sandbox.  Implements hooks    \n     shrubAngularSandboxNavigationMiddleware implementation \n     shrubHttpMiddleware implementation",
            "title": "shrub-form"
        },
        {
            "location": "/packages/#shrub-grunt",
            "text": "Grunt build process  Implements hooks    \n     shrubAssetsMiddleware implementation \n     shrubConfigClientAlter implementation \n     shrubGruntConfig implementation \n     shrubGruntConfigAlter implementation",
            "title": "shrub-grunt"
        },
        {
            "location": "/packages/#shrub-gruntdox",
            "text": "Grunt build process - Documentation  Build the documentation in  gh-pages .  Implements hooks    \n     shrubGruntConfig implementation",
            "title": "shrub-grunt/dox"
        },
        {
            "location": "/packages/#shrub-gruntdoxdynamic",
            "text": "Grunt build process - Dynamic documentation",
            "title": "shrub-grunt/dox/dynamic"
        },
        {
            "location": "/packages/#shrub-gruntlint",
            "text": "Grunt build process - (de)Linting  Implements hooks    \n     shrubGruntConfig implementation",
            "title": "shrub-grunt/lint"
        },
        {
            "location": "/packages/#shrub-gruntmodules",
            "text": "Grunt build process - Modules  Implements hooks    \n     shrubGruntConfig implementation",
            "title": "shrub-grunt/modules"
        },
        {
            "location": "/packages/#shrub-grunttests",
            "text": "Grunt build process - Tests  Build and run the tests.",
            "title": "shrub-grunt/tests"
        },
        {
            "location": "/packages/#shrub-grunttestsbuild",
            "text": "Grunt build process - Build tests  Implements hooks    \n     shrubGruntConfig implementation \n     shrubGruntConfigAlter implementation",
            "title": "shrub-grunt/tests/build"
        },
        {
            "location": "/packages/#shrub-grunttestsrun",
            "text": "Grunt build process - Run tests  Implements hooks    \n     shrubGruntConfig implementation",
            "title": "shrub-grunt/tests/run"
        },
        {
            "location": "/packages/#shrub-html5-audio",
            "text": "HTML5 audio",
            "title": "shrub-html5-audio"
        },
        {
            "location": "/packages/#shrub-html5-local-storage",
            "text": "HTML5 local storage  Build and serve the HTML5 localStorage support.  Implements hooks    \n     shrubGruntConfig implementation \n     shrubAssetsMiddleware implementation \n     shrubAngularPackageDependencies implementation",
            "title": "shrub-html5-local-storage"
        },
        {
            "location": "/packages/#shrub-html5-notification",
            "text": "HTML5 notification  Build and serve the HTML5 notification support.  Implements hooks    \n     shrubGruntConfig implementation \n     shrubAssetsMiddleware implementation \n     shrubAngularPackageDependencies implementation",
            "title": "shrub-html5-notification"
        },
        {
            "location": "/packages/#shrub-http",
            "text": "HTTP  Manage HTTP connections.  Implements hooks    \n     shrubCoreBootstrapMiddleware implementation \n     shrubHttpMiddleware implementation \n     shrubConfigServer implementation",
            "title": "shrub-http"
        },
        {
            "location": "/packages/#shrub-http-express",
            "text": "Express  An  Express  HTTP server implementation, with middleware for sessions, routing, logging, etc.  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubRpcRoutesAlter implementation",
            "title": "shrub-http-express"
        },
        {
            "location": "/packages/#shrub-http-expresserrors",
            "text": "Express - error handler  Implements hooks    \n     shrubHttpMiddleware implementation",
            "title": "shrub-http-express/errors"
        },
        {
            "location": "/packages/#shrub-http-expresslogger",
            "text": "Express - logger  Implements hooks    \n     shrubHttpMiddleware implementation",
            "title": "shrub-http-express/logger"
        },
        {
            "location": "/packages/#shrub-http-expressroutes",
            "text": "Express - routes  Implements hooks    \n     shrubHttpMiddleware implementation",
            "title": "shrub-http-express/routes"
        },
        {
            "location": "/packages/#shrub-http-expresssession",
            "text": "Express - routes  Implements hooks    \n     shrubCoreBootstrapMiddleware implementation \n     shrubHttpMiddleware implementation \n     shrubRpcRoutesAlter implementation \n     shrubSocketConnectionMiddleware implementation",
            "title": "shrub-http-express/session"
        },
        {
            "location": "/packages/#shrub-http-expressstatic",
            "text": "Express - static files  Implements hooks    \n     shrubHttpMiddleware implementation",
            "title": "shrub-http-express/static"
        },
        {
            "location": "/packages/#shrub-httpmanager",
            "text": "HTTP Manager  Manage an HTTP server instance.  Invokes hooks    \n     shrubHttpRoutes invocation \n     shrubHttpMiddleware invocation",
            "title": "shrub-http/manager"
        },
        {
            "location": "/packages/#shrub-install",
            "text": "Installation  Install shrub if it hasn't been done so yet. This is essentially a hack for now, but will be fleshed out as we go.  Implements hooks    \n     shrubCoreBootstrapMiddleware implementation \n     shrubReplContext implementation",
            "title": "shrub-install"
        },
        {
            "location": "/packages/#shrub-limiter",
            "text": "Rate limiter  Limits the rate at which clients can do certain operations, like call RPC routes.  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubOrmCollections implementation \n     shrubRpcRoutesAlter implementation \n     shrubTransmittableErrors implementation \n     Invokes hooks    \n     shrubLimiterCheck invocation \n     shrubVillianyReport invocation",
            "title": "shrub-limiter"
        },
        {
            "location": "/packages/#shrub-limiterlimiter",
            "text": "Limiter  ORM-backed limit handling. Accrue and check scores, and check Time-to-live across multiple  fingerprint keys .",
            "title": "shrub-limiter/limiter"
        },
        {
            "location": "/packages/#shrub-nodemailer",
            "text": "nodemailer  Renders and sends email.  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubCoreBootstrapMiddleware implementation \n     shrubConfigServer implementation \n     shrubReplContext implementation \n     Invokes hooks    \n     shrubNodemailerHtml invocation",
            "title": "shrub-nodemailer"
        },
        {
            "location": "/packages/#shrub-orm",
            "text": "Object-relational mapping  Tools for working with  Waterline .  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubCoreBootstrapMiddleware implementation \n     shrubGruntConfig implementation \n     shrubConfigServer implementation \n     shrubReplContext implementation \n     Invokes hooks    \n     shrubOrmCollections invocation \n     shrubOrmCollectionsAlter invocation",
            "title": "shrub-orm"
        },
        {
            "location": "/packages/#shrub-passport",
            "text": "Passport integration  Authentication system, leaning on  passport .  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubCoreBootstrapMiddleware implementation \n     shrubHttpMiddleware implementation \n     shrubRpcRoutesAlter implementation \n     shrubSocketConnectionMiddleware implementation \n     Invokes hooks    \n     shrubUserBeforeLoginMiddleware invocation \n     shrubUserAfterLoginMiddleware invocation \n     shrubUserBeforeLogoutMiddleware invocation \n     shrubUserAfterLogoutMiddleware invocation \n     shrubUserLoginStrategies invocation \n     shrubUserLoginStrategiesAlter invocation",
            "title": "shrub-passport"
        },
        {
            "location": "/packages/#shrub-passportlogout",
            "text": "User logout  Implements hooks    \n     shrubRpcRoutes implementation",
            "title": "shrub-passport/logout"
        },
        {
            "location": "/packages/#shrub-repl",
            "text": "REPL  Runs a REPL and allows packages to add values to its context.  Implements hooks    \n     shrubConfigServer implementation \n     shrubCoreProcessExit implementation \n     shrubCoreBootstrapMiddleware implementation \n     Invokes hooks    \n     shrubReplContext invocation",
            "title": "shrub-repl"
        },
        {
            "location": "/packages/#shrub-rpc",
            "text": "RPC  Framework for communication between client and server through  RPC  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubCoreBootstrapMiddleware implementation \n     shrubSocketConnectionMiddleware implementation \n     Invokes hooks    \n     shrubRpcRoutes invocation \n     shrubRpcRoutesAlter invocation",
            "title": "shrub-rpc"
        },
        {
            "location": "/packages/#shrub-schema-rest",
            "text": "REST API for database schema  Serve the database schema over a REST API.",
            "title": "shrub-schema-rest"
        },
        {
            "location": "/packages/#shrub-session",
            "text": "Session  Manage sessions across HTTP and socket connections.  Implements hooks    \n     shrubOrmCollections implementation \n     shrubAuditFingerprint implementation \n     shrubConfigServer implementation \n     shrubSocketConnectionMiddleware implementation",
            "title": "shrub-session"
        },
        {
            "location": "/packages/#shrub-sessionstore",
            "text": "Session store  *An implementation of express's  Session Store  API.",
            "title": "shrub-session/store"
        },
        {
            "location": "/packages/#shrub-skin",
            "text": "Skin  Allows the visual aspects of the site to be controlled by skin packages.  Implements hooks    \n     shrubConfigClient implementation \n     shrubHttpMiddleware implementation \n     shrubHttpMiddleware implementation \n     shrubConfigServer implementation \n     Invokes hooks    \n     shrubSkinAssets invocation",
            "title": "shrub-skin"
        },
        {
            "location": "/packages/#shrub-skin-strapped",
            "text": "Strapped  Shrub's default skin.  Implements hooks    \n     shrubNodemailerHtml implementation \n     shrubSkinAssets implementation \n     shrubGruntConfig implementation",
            "title": "shrub-skin-strapped"
        },
        {
            "location": "/packages/#shrub-socket",
            "text": "Socket  Manage socket connections.  Implements hooks    \n     shrubConfigClient implementation \n     shrubCoreBootstrapMiddleware implementation \n     shrubConfigServer implementation \n     shrubReplContext implementation",
            "title": "shrub-socket"
        },
        {
            "location": "/packages/#shrub-socket-socketio",
            "text": "Socket.IO  Build and serve  Socket.IO .  Implements hooks    \n     shrubAssetsMiddleware implementation \n     shrubGruntConfig implementation",
            "title": "shrub-socket-socket.io"
        },
        {
            "location": "/packages/#shrub-socket-socketiomanager",
            "text": "SocketIoManager  A  Socket.IO  implementation of SocketManager.",
            "title": "shrub-socket-socket.io/manager"
        },
        {
            "location": "/packages/#shrub-socketmanager",
            "text": "SocketManager  Invokes hooks    \n     shrubSocketConnectionMiddleware invocation \n     shrubSocketDisconnectionMiddleware invocation",
            "title": "shrub-socket/manager"
        },
        {
            "location": "/packages/#shrub-ui",
            "text": "User Interface  Implements hooks    \n     shrubConfigClient implementation",
            "title": "shrub-ui"
        },
        {
            "location": "/packages/#shrub-uinotifications",
            "text": "UI - Notifications  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubCoreBootstrapMiddleware implementation \n     shrubOrmCollections implementation \n     shrubConfigClient implementation \n     shrubRpcRoutes implementation \n     Invokes hooks    \n     shrubUiNotificationQueues invocation",
            "title": "shrub-ui/notifications"
        },
        {
            "location": "/packages/#shrub-user",
            "text": "User  User operations.  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubConfigClient implementation \n     shrubConfigServer implementation \n     shrubUserRedactors implementation \n     shrubAuditFingerprint implementation \n     shrubOrmCollections implementation \n     shrubTransmittableErrors implementation \n     shrubUserBeforeLoginMiddleware implementation \n     shrubUserBeforeLogoutMiddleware implementation \n     Invokes hooks    \n     shrubUserRedactors invocation",
            "title": "shrub-user"
        },
        {
            "location": "/packages/#shrub-user-local",
            "text": "Local user authentication.  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubUserLoginStrategies implementation \n     shrubUserRedactors implementation \n     shrubOrmCollections implementation \n     shrubTransmittableErrors implementation",
            "title": "shrub-user-local"
        },
        {
            "location": "/packages/#shrub-user-localforgot",
            "text": "User - Forgot password  Implements hooks    \n     shrubRpcRoutes implementation",
            "title": "shrub-user-local/forgot"
        },
        {
            "location": "/packages/#shrub-user-localregister",
            "text": "User - Registration  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubRpcRoutes implementation \n     shrubReplContext implementation",
            "title": "shrub-user-local/register"
        },
        {
            "location": "/packages/#shrub-user-localreset",
            "text": "User - Password reset  Implements hooks    \n     shrubRpcRoutes implementation",
            "title": "shrub-user-local/reset"
        },
        {
            "location": "/packages/#shrub-user-reddit",
            "text": "Authorize using a reddit account.  Implements hooks    \n     shrubConfigServer implementation \n     shrubCorePreBootstrap implementation \n     shrubUserLoginStrategies implementation \n     shrubHttpRoutes implementation \n     shrubUserRedactors implementation \n     shrubOrmCollections implementation",
            "title": "shrub-user-reddit"
        },
        {
            "location": "/packages/#shrub-userlogin",
            "text": "Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubRpcRoutes implementation",
            "title": "shrub-user/login"
        },
        {
            "location": "/packages/#shrub-villiany",
            "text": "Villiany  Watch for and punish bad behavior.  Implements hooks    \n     shrubCorePreBootstrap implementation \n     shrubOrmCollections implementation \n     shrubHttpMiddleware implementation \n     shrubConfigServer implementation \n     shrubSocketConnectionMiddleware implementation \n     shrubRpcRoutesAlter implementation \n     shrubVillianyReport implementation",
            "title": "shrub-villiany"
        },
        {
            "location": "/todos/",
            "text": "TODO list\n\n\n\nShrub \u2014 like any project \u2014 always presents a path for improvement.\nThis is a dynamically generated list of TODO items, each with context.\n\n\nTODO: Cluster refactoring, with master/worker hooks\n\n\n\n\n\n      # Completely override the $q service with Bluebird, because it's\n      # awesome.\n      #\n\n\n\n\nTODO: Angular also implements a private service called $$q used for animation. We should override that one, too.\n\n\n      $provide.decorator '$q', [\n        '$rootScope', '$exceptionHandler'\n        ($rootScope, $exceptionHandler) ->\n\n\n\n\nthe above found in packages/shrub-angular/client/index.coffee:43\n\n\n\n\n        ($q, $window) ->\n\n          service = {}\n\n\n\n\n\nTODO: Configure filetype priorities per browser.\n\n\n          service.loadFile = (filename) ->\n\n            unless audioFiles[filename]?\n\n\n\n\nthe above found in packages/shrub-html5-audio/client/index.coffee:25\n\n\n\n\n# # Socket.IO socket\n#\n# *Provide an Angular service wrapping Socket.IO.*\n#\n\n\n\n\nTODO: Need to handle connection errors.\n\n\nconfig = require 'config'\ndebug = require('debug') 'shrub:socket.io'\n\n\n\n\n\nthe above found in packages/shrub-socket-socket.io/client/index.coffee:4\n\n\n\n\n  ]\n\nexports.shrubOrmCollections = ->\n\n\n\n\n\nTODO: Finish these docs.\n\n\n  Group =\n\n    associations: [\n\n\n\n\nthe above found in packages/shrub-user/client/index.coffee:128\n\n\n\n\n# # Angular sandbox\n#\n# *A sandboxed version of Angular, for clients lacking JS.*\n#\n\n\n\n\nTODO: Sandbox pool, might be better handled by \nsandboxes\n.\n\n\n_ = require 'lodash'\nPromise = require 'bluebird'\nurl = require 'url'\n\n\n\n\nthe above found in packages/shrub-angular-sandbox/index.coffee:4\n\n\n\n\n        'shrub-http-express/session'\n\n        (req, res, next) ->\n\n\n\n\n\nTODO: Cookie-less clients won't have a valid session ID to call with. This should be some other token, perhaps CSRF.\n\n\n          id = req.session?.id\n          if (sandbox = sandboxManager.lookup id)?\n            sandbox.close().finally -> res.end()\n\n\n\n\nthe above found in packages/shrub-angular-sandbox/index.coffee:36\n\n\n\n\n      # Check for any regexs.\n      for key, route of routes\n        if route.regexp?.test path\n\n\n\n\n\nTODO: Need to extract params to build redirectTo, it's a small enough mismatch to ignore for now.\n\n\n          return\n\n      # Angular's $routeProvider.otherwise() target.\n\n\n\n\nthe above found in packages/shrub-angular-sandbox/index.coffee:359\n\n\n\n\n        {body, sandbox} = req\n\n        # Make sure there's a formKey in the submission.\n        #\n\n\n\n\nTODO: CRSF check needed here.\n\n\n        return next() unless body.formKey?\n\n        # Lookup the cached form.\n\n\n\n\nthe above found in packages/shrub-form/index.coffee:24\n\n\n\n\n  #\n  # *Create the server.*\n  constructor: ->\n\n\n\n\n\nTODO: Keeping a reference here means HTTP stuff can't be updated at run-time.\n\n\n    @_config = config.get 'packageConfig:shrub-http'\n\n    @_middleware = null\n\n\n\n\nthe above found in packages/shrub-http/manager.coffee:26\n\n\n\n\n      (next) ->\n\n        # No superuser? Install...\n        #\n\n\n\n\nTODO: There should be a more robust check than just 'is there a superuser?'.\n\n\n        User = orm.collection 'shrub-user'\n        User.findOne(id: 1).then((user) ->\n          return if user?\n\n\n\n\nthe above found in packages/shrub-install/index.coffee:20\n\n\n\n\n          routeReq.body = data\n          routeReq.route = route\n          routeReq.socket = req.socket\n\n\n\n\n\nTODO: Doc\n\n\n          routeRes = new class RpcRouteResponse extends EventEmitter\n\n            constructor: ->\n\n\n\n\nthe above found in packages/shrub-rpc/index.coffee:98\n\n\n\n\n# * (String) `key` - The skin key.\n#\n# *Get the assets for a skin.*\n#\n\n\n\n\nTODO: This needs caching.\n\n\nexports.assets = (skinKey) ->\n\n  glob = require 'simple-glob'\n\n\n\n\nthe above found in packages/shrub-skin/index.coffee:182\n\n\n\n\n            scope =\n\n              email: email\n\n\n\n\n\nTODO: HTTPS\n\n\n              loginUrl: \"#{siteUrl}/user/reset/#{localUser.resetPasswordToken}\"\n\n              siteUrl: siteUrl\n\n\n\n\nthe above found in packages/shrub-user-local/forgot.coffee:81\n\n\n\n\n\n        # Not found? Generic login error.\n        throw errors.instantiate 'shrub-user-local-login' unless @localUser\n\n\n\n\n\nTODO: Any way to automate this?\n\n\n        @localUser.model = 'shrub-user-local'\n\n        # Hash the input password for comparison.\n\n\n\n\nthe above found in packages/shrub-user-local/index.coffee:40\n\n\n\n\n      size: 128\n\n    # ## UserLocal#associatedUser\n    #\n\n\n\n\nTODO: This should be in a superclass.\n\n\n    #\n    # *Get the user (if any) associated with this instance.*\n    UserLocal.attributes.associatedUser = ->\n\n\n\n\nthe above found in packages/shrub-user-local/index.coffee:134\n\n\n\n\n            scope =\n\n              email: email\n\n\n\n\n\nTODO: HTTPS\n\n\n              loginUrl: \"#{siteUrl}/user/reset/#{user.resetPasswordToken}\"\n\n              siteUrl: siteUrl\n\n\n\n\nthe above found in packages/shrub-user-local/register.coffee:57\n\n\n\n\n    } = collections\n\n    # ## UserReddit#associatedUser\n    #\n\n\n\n\nTODO: This should be in a superclass.\n\n\n    #\n    # *Get the user (if any) associated with this instance.*\n    UserReddit.attributes.associatedUser = ->\n\n\n\n\nthe above found in packages/shrub-user-reddit/index.coffee:169\n\n\n\n\n\n        redacted =\n          id: object.id\n\n\n\n\n\nTODO: Include/merge permissions.\n\n\n\n        for group in object.groups\n\n\n\n\n\nthe above found in packages/shrub-user/index.coffee:52\n\n\n\n\n      pkgman = require 'pkgman'\n\n      # Collect redactors.\n      #\n\n\n\n\nTODO: Caching.\n\n\n      unless redactors?\n        redactors = {}\n\n\n\n\n\nthe above found in packages/shrub-user/index.coffee:174\n\n\n\n\n          return resolve sandbox\n\n        # Just emit the first error.\n        #\n\n\n\n\nTODO: How can we collapse multiple errors into one?\n\n\n        reject window.__shrubStartupErrors[0]\n\n  # ## Sandbox#emitHtml\n\n\n\n\nthe above found in server/sandboxes.coffee:114",
            "title": "TODO list"
        },
        {
            "location": "/todos/#todo-cluster-refactoring-with-masterworker-hooks",
            "text": "# Completely override the $q service with Bluebird, because it's\n      # awesome.\n      #",
            "title": "TODO: Cluster refactoring, with master/worker hooks"
        },
        {
            "location": "/todos/#todo-angular-also-implements-a-private-service-called-q-used-for-animation-we-should-override-that-one-too",
            "text": "$provide.decorator '$q', [\n        '$rootScope', '$exceptionHandler'\n        ($rootScope, $exceptionHandler) ->  the above found in packages/shrub-angular/client/index.coffee:43           ($q, $window) ->\n\n          service = {}",
            "title": "TODO: Angular also implements a private service called $$q used for animation. We should override that one, too."
        },
        {
            "location": "/todos/#todo-configure-filetype-priorities-per-browser",
            "text": "service.loadFile = (filename) ->\n\n            unless audioFiles[filename]?  the above found in packages/shrub-html5-audio/client/index.coffee:25   # # Socket.IO socket\n#\n# *Provide an Angular service wrapping Socket.IO.*\n#",
            "title": "TODO: Configure filetype priorities per browser."
        },
        {
            "location": "/todos/#todo-need-to-handle-connection-errors",
            "text": "config = require 'config'\ndebug = require('debug') 'shrub:socket.io'  the above found in packages/shrub-socket-socket.io/client/index.coffee:4     ]\n\nexports.shrubOrmCollections = ->",
            "title": "TODO: Need to handle connection errors."
        },
        {
            "location": "/todos/#todo-finish-these-docs",
            "text": "Group =\n\n    associations: [  the above found in packages/shrub-user/client/index.coffee:128   # # Angular sandbox\n#\n# *A sandboxed version of Angular, for clients lacking JS.*\n#",
            "title": "TODO: Finish these docs."
        },
        {
            "location": "/todos/#todo-sandbox-pool-might-be-better-handled-by-sandboxes",
            "text": "_ = require 'lodash'\nPromise = require 'bluebird'\nurl = require 'url'  the above found in packages/shrub-angular-sandbox/index.coffee:4           'shrub-http-express/session'\n\n        (req, res, next) ->",
            "title": "TODO: Sandbox pool, might be better handled by sandboxes."
        },
        {
            "location": "/todos/#todo-cookie-less-clients-wont-have-a-valid-session-id-to-call-with-this-should-be-some-other-token-perhaps-csrf",
            "text": "id = req.session?.id\n          if (sandbox = sandboxManager.lookup id)?\n            sandbox.close().finally -> res.end()  the above found in packages/shrub-angular-sandbox/index.coffee:36         # Check for any regexs.\n      for key, route of routes\n        if route.regexp?.test path",
            "title": "TODO: Cookie-less clients won't have a valid session ID to call with. This should be some other token, perhaps CSRF."
        },
        {
            "location": "/todos/#todo-need-to-extract-params-to-build-redirectto-its-a-small-enough-mismatch-to-ignore-for-now",
            "text": "return\n\n      # Angular's $routeProvider.otherwise() target.  the above found in packages/shrub-angular-sandbox/index.coffee:359           {body, sandbox} = req\n\n        # Make sure there's a formKey in the submission.\n        #",
            "title": "TODO: Need to extract params to build redirectTo, it's a small enough mismatch to ignore for now."
        },
        {
            "location": "/todos/#todo-crsf-check-needed-here",
            "text": "return next() unless body.formKey?\n\n        # Lookup the cached form.  the above found in packages/shrub-form/index.coffee:24     #\n  # *Create the server.*\n  constructor: ->",
            "title": "TODO: CRSF check needed here."
        },
        {
            "location": "/todos/#todo-keeping-a-reference-here-means-http-stuff-cant-be-updated-at-run-time",
            "text": "@_config = config.get 'packageConfig:shrub-http'\n\n    @_middleware = null  the above found in packages/shrub-http/manager.coffee:26         (next) ->\n\n        # No superuser? Install...\n        #",
            "title": "TODO: Keeping a reference here means HTTP stuff can't be updated at run-time."
        },
        {
            "location": "/todos/#todo-there-should-be-a-more-robust-check-than-just-is-there-a-superuser",
            "text": "User = orm.collection 'shrub-user'\n        User.findOne(id: 1).then((user) ->\n          return if user?  the above found in packages/shrub-install/index.coffee:20             routeReq.body = data\n          routeReq.route = route\n          routeReq.socket = req.socket",
            "title": "TODO: There should be a more robust check than just 'is there a superuser?'."
        },
        {
            "location": "/todos/#todo-doc",
            "text": "routeRes = new class RpcRouteResponse extends EventEmitter\n\n            constructor: ->  the above found in packages/shrub-rpc/index.coffee:98   # * (String) `key` - The skin key.\n#\n# *Get the assets for a skin.*\n#",
            "title": "TODO: Doc"
        },
        {
            "location": "/todos/#todo-this-needs-caching",
            "text": "exports.assets = (skinKey) ->\n\n  glob = require 'simple-glob'  the above found in packages/shrub-skin/index.coffee:182               scope =\n\n              email: email",
            "title": "TODO: This needs caching."
        },
        {
            "location": "/todos/#todo-https",
            "text": "loginUrl: \"#{siteUrl}/user/reset/#{localUser.resetPasswordToken}\"\n\n              siteUrl: siteUrl  the above found in packages/shrub-user-local/forgot.coffee:81   \n        # Not found? Generic login error.\n        throw errors.instantiate 'shrub-user-local-login' unless @localUser",
            "title": "TODO: HTTPS"
        },
        {
            "location": "/todos/#todo-any-way-to-automate-this",
            "text": "@localUser.model = 'shrub-user-local'\n\n        # Hash the input password for comparison.  the above found in packages/shrub-user-local/index.coffee:40         size: 128\n\n    # ## UserLocal#associatedUser\n    #",
            "title": "TODO: Any way to automate this?"
        },
        {
            "location": "/todos/#todo-this-should-be-in-a-superclass",
            "text": "#\n    # *Get the user (if any) associated with this instance.*\n    UserLocal.attributes.associatedUser = ->  the above found in packages/shrub-user-local/index.coffee:134               scope =\n\n              email: email",
            "title": "TODO: This should be in a superclass."
        },
        {
            "location": "/todos/#todo-https_1",
            "text": "loginUrl: \"#{siteUrl}/user/reset/#{user.resetPasswordToken}\"\n\n              siteUrl: siteUrl  the above found in packages/shrub-user-local/register.coffee:57       } = collections\n\n    # ## UserReddit#associatedUser\n    #",
            "title": "TODO: HTTPS"
        },
        {
            "location": "/todos/#todo-this-should-be-in-a-superclass_1",
            "text": "#\n    # *Get the user (if any) associated with this instance.*\n    UserReddit.attributes.associatedUser = ->  the above found in packages/shrub-user-reddit/index.coffee:169   \n        redacted =\n          id: object.id",
            "title": "TODO: This should be in a superclass."
        },
        {
            "location": "/todos/#todo-includemerge-permissions",
            "text": "for group in object.groups  the above found in packages/shrub-user/index.coffee:52         pkgman = require 'pkgman'\n\n      # Collect redactors.\n      #",
            "title": "TODO: Include/merge permissions."
        },
        {
            "location": "/todos/#todo-caching",
            "text": "unless redactors?\n        redactors = {}  the above found in packages/shrub-user/index.coffee:174             return resolve sandbox\n\n        # Just emit the first error.\n        #",
            "title": "TODO: Caching."
        },
        {
            "location": "/todos/#todo-how-can-we-collapse-multiple-errors-into-one",
            "text": "reject window.__shrubStartupErrors[0]\n\n  # ## Sandbox#emitHtml  the above found in server/sandboxes.coffee:114",
            "title": "TODO: How can we collapse multiple errors into one?"
        },
        {
            "location": "/source/client/app/",
            "text": "Client application entry point.\n\n\nDefinition of the main top-level Angular module, with dependency gathering\nand config/run hook invocation.\n\n\nTop-level module.\n\n\nangular.module 'shrub', ['shrub.core']\n\n\n\n\nInclude core Angular dependencies.\n\n\ncoreDependencies = []\ncoreDependencies.push 'ngRoute'\ncoreDependencies.push 'ngSanitize'\n\n\n\n\npackageDependencies\n will be automatically generated and populated by\nGrunt.\n\n\nSee the documentation for\n\nshrubAngularPackageDependencies\n.\n\n\ncoreDependencies.push packageDependencies...\n\n\n\n\nInclude core shrub dependencies.\n\n\ncoreDependencies.push 'shrub.config'\ncoreDependencies.push 'shrub.packages'\ncoreDependencies.push 'shrub.require'\n\n\n\n\nDefine the core Shrub module.\n\n\nangular.module('shrub.core', coreDependencies)\n\n  .config([\n    '$injector', 'shrub-pkgmanProvider'\n    ({invoke}, {invokeFlat}) ->\n\n\n\n\nInvoke hook \nshrubAngularAppConfig\n\n\nInvoked when the Angular application is in the configuration phase.\nImplementations should return an \nannotated\nfunction\n.\n\n\n      invoke injectable for injectable in invokeFlat 'shrubAngularAppConfig'\n\n      return\n\n  ])\n\n  .run([\n\n    '$injector', 'shrub-pkgman'\n    ({invoke}, {invokeFlat}) ->\n\n\n\n\nInvoke hook \nshrubAngularAppRun\n\n\nInvoked when the Angular application is the run phase. Implementations\nshould return an \nannotated\nfunction\n.\n\n\n      invoke injectable for injectable in invokeFlat 'shrubAngularAppRun'\n\n      return\n\n  ])",
            "title": "app.coffee"
        },
        {
            "location": "/source/client/app/#client-application-entry-point",
            "text": "Definition of the main top-level Angular module, with dependency gathering\nand config/run hook invocation.  Top-level module.  angular.module 'shrub', ['shrub.core']  Include core Angular dependencies.  coreDependencies = []\ncoreDependencies.push 'ngRoute'\ncoreDependencies.push 'ngSanitize'  packageDependencies  will be automatically generated and populated by\nGrunt.  See the documentation for shrubAngularPackageDependencies .  coreDependencies.push packageDependencies...  Include core shrub dependencies.  coreDependencies.push 'shrub.config'\ncoreDependencies.push 'shrub.packages'\ncoreDependencies.push 'shrub.require'  Define the core Shrub module.  angular.module('shrub.core', coreDependencies)\n\n  .config([\n    '$injector', 'shrub-pkgmanProvider'\n    ({invoke}, {invokeFlat}) ->  Invoke hook  shrubAngularAppConfig  Invoked when the Angular application is in the configuration phase.\nImplementations should return an  annotated\nfunction .        invoke injectable for injectable in invokeFlat 'shrubAngularAppConfig'\n\n      return\n\n  ])\n\n  .run([\n\n    '$injector', 'shrub-pkgman'\n    ({invoke}, {invokeFlat}) ->  Invoke hook  shrubAngularAppRun  Invoked when the Angular application is the run phase. Implementations\nshould return an  annotated\nfunction .        invoke injectable for injectable in invokeFlat 'shrubAngularAppRun'\n\n      return\n\n  ])",
            "title": "Client application entry point."
        },
        {
            "location": "/source/client/modules/angular/",
            "text": "Angular augmentation module\n\n\nProvides functionality related to Angular for client packages.\n\n\nAllow shrub to set the injector.\n\n\n_$injector = null\nexports.setInjector = ($injector) -> _$injector = $injector\n\n\n\n\nInject dependencies into an \nannotated\nfunction\n.\nPackages may use this to inject dependencies out-of-band.\n\n\nexports.inject = (injectable) -> _$injector.invoke injectable",
            "title": "angular.coffee"
        },
        {
            "location": "/source/client/modules/angular/#angular-augmentation-module",
            "text": "Provides functionality related to Angular for client packages.  Allow shrub to set the injector.  _$injector = null\nexports.setInjector = ($injector) -> _$injector = $injector  Inject dependencies into an  annotated\nfunction .\nPackages may use this to inject dependencies out-of-band.  exports.inject = (injectable) -> _$injector.invoke injectable",
            "title": "Angular augmentation module"
        },
        {
            "location": "/source/client/modules/config/",
            "text": "Configuration system.\n\n\nHandle getting, setting, and checking configuration state.\n\n\nmodule.exports = new class Config\n\n\n\n\nThis class allows us to wrap and subsequently get, set, and check the\nexistence of values in a configuration tree. The configuration tree may be\ntraversed with colons, e.g. \nparent:child:grandchild\n. Supposing we have a\nconfiguration structure:\n\n\nconfiguration =\n  visible: true\n  child:\n    id: 200\n    tag: null\n\n\n\n\nWe may wrap and interact with it as follows:\n\n\nwrapped = new Config configuration\nwrapped.get 'visible'\n\n\n\n\nReturns: \ntrue\n\n\nwrapped.set 'child:name', 'Billy'\nwrapped.get 'child'\n\n\n\n\nReturns: \n{ id: 200, name: 'Billy' }\n\n\nwrapped.has 'child:id'\n\n\n\n\nReturns: \ntrue\n\n\nwrapped.has 'child:thing'\n\n\n\n\nReturns: \nfalse\n\n\nNOTE:\n \nhas\n works with null values:\n\n\nwrapped.has 'child:tag'\n\n\n\n\nReturns: \ntrue\n\n\nProvide the class externally.\n\n\n  Config: Config\n\n\n\n\nconstructor\n\n\n\n\n(object) \nconfig\n - The configuration tree.\n\n\n\n\nCreate a configuration wrapper.\n\n\n  constructor: (config = {}) -> @from config\n\n\n\n\nConfig#from\n\n\n\n\n(object) \nconfig\n - The configuration object.\n\n\n\n\nSet configuration from an object.\n\n\n  from: (@config) ->\n\n\n\n\nConfig#get\n\n\n\n\n(string) \npath\n - The path to look up, e.g. parent:child:grandchild\n\n\n\n\nGet a value by path.\n\n\n  get: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      current = current?[part]\n    current\n\n\n\n\nConfig#has\n\n\n\n\n(string) \npath\n - The path to look up, e.g. \n'parent:child:grandchild'\n\n\n\n\nCheck whether a path exists.\n\n\n  has: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      return false unless part of current\n      current = current[part]\n\n    return true\n\n\n\n\nConfig#set\n\n\n\n\n\n\n(string) \npath\n - The path to look up, e.g. parent:child:grandchild\n\n\n\n\n\n\n(any) \nvalue\n - The value to store at the path location.\n\n\n\n\n\n\nSet a value by path.\n\n\n  set: (path, value) ->\n\n    [parts..., last] = path.split ':'\n    current = @config\n    for part in parts\n      current = (current[part] ?= {})\n\n    current[last] = value\n\n\n\n\nConfig#toJSON\n\n\nReturn config object for serialization.\n\n\n  toJSON: -> @config",
            "title": "config.coffee"
        },
        {
            "location": "/source/client/modules/config/#configuration-system",
            "text": "Handle getting, setting, and checking configuration state.  module.exports = new class Config  This class allows us to wrap and subsequently get, set, and check the\nexistence of values in a configuration tree. The configuration tree may be\ntraversed with colons, e.g.  parent:child:grandchild . Supposing we have a\nconfiguration structure:  configuration =\n  visible: true\n  child:\n    id: 200\n    tag: null  We may wrap and interact with it as follows:  wrapped = new Config configuration\nwrapped.get 'visible'  Returns:  true  wrapped.set 'child:name', 'Billy'\nwrapped.get 'child'  Returns:  { id: 200, name: 'Billy' }  wrapped.has 'child:id'  Returns:  true  wrapped.has 'child:thing'  Returns:  false  NOTE:   has  works with null values:  wrapped.has 'child:tag'  Returns:  true",
            "title": "Configuration system."
        },
        {
            "location": "/source/client/modules/config/#provide-the-class-externally",
            "text": "Config: Config",
            "title": "Provide the class externally."
        },
        {
            "location": "/source/client/modules/config/#constructor",
            "text": "(object)  config  - The configuration tree.   Create a configuration wrapper.    constructor: (config = {}) -> @from config",
            "title": "constructor"
        },
        {
            "location": "/source/client/modules/config/#configfrom",
            "text": "(object)  config  - The configuration object.   Set configuration from an object.    from: (@config) ->",
            "title": "Config#from"
        },
        {
            "location": "/source/client/modules/config/#configget",
            "text": "(string)  path  - The path to look up, e.g. parent:child:grandchild   Get a value by path.    get: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      current = current?[part]\n    current",
            "title": "Config#get"
        },
        {
            "location": "/source/client/modules/config/#confighas",
            "text": "(string)  path  - The path to look up, e.g.  'parent:child:grandchild'   Check whether a path exists.    has: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      return false unless part of current\n      current = current[part]\n\n    return true",
            "title": "Config#has"
        },
        {
            "location": "/source/client/modules/config/#configset",
            "text": "(string)  path  - The path to look up, e.g. parent:child:grandchild    (any)  value  - The value to store at the path location.    Set a value by path.    set: (path, value) ->\n\n    [parts..., last] = path.split ':'\n    current = @config\n    for part in parts\n      current = (current[part] ?= {})\n\n    current[last] = value",
            "title": "Config#set"
        },
        {
            "location": "/source/client/modules/config/#configtojson",
            "text": "Return config object for serialization.    toJSON: -> @config",
            "title": "Config#toJSON"
        },
        {
            "location": "/source/client/modules/config.spec/",
            "text": "config = require './config'\n\ndescribe 'config', ->\n\n  beforeEach ->\n\n    config.from(\n      test: 69\n      another:\n        foo:\n          420\n        bar:\n          null\n    )\n\n  it 'gets variables', ->\n\n    expect(config.get 'test').toBe 69\n    expect(config.get 'another:foo').toBe 420\n\n  it 'checks variables', ->\n\n    expect(config.has 'test').toBe true\n    expect(config.has 'sd').toBe false\n    expect(config.has 'another:foo').toBe true\n    expect(config.has 'another:bar').toBe true\n\n  it 'sets variables', ->\n\n    config.set 'test', 'blah'\n    expect(config.get 'test').toBe 'blah'\n\n    config.set 'another:foo', 421\n    expect(config.get 'another:foo').toBe 421\n\n    config.set 'another:baz:blah', 311\n    expect(config.get 'another:baz:blah').toBe 311",
            "title": "config.spec.coffee"
        },
        {
            "location": "/source/client/modules/errors/",
            "text": "Error handling\n\n\npkgman = require 'pkgman'\n\n\n\n\nTransmittableError\n\n\nExtend this class if you'd like to implement an error.\n\n\nexports.TransmittableError = class TransmittableError extends Error\n\n\n\n\nTransmittableError#constructor\n\n\nSee:\n\nhttps://github.com/jashkenas/coffee-script/issues/2359\n\n\n  constructor: (@message) ->\n\n\n\n\nTransmittableError#errorType\n\n\nA unique key for this error.\n\n\n  errorType: 'unknown'\n\n\n\n\nTransmittableError#template\n\n\nThe template used to format the error output.\n\n\n  template: 'Unknown error: :message'\n\n\n\n\nTransmittableError#toJSON\n\n\nImplement this if you need to transmit more than just the error type and\nthe message. Shrub uses the result from this function to serialize the\nerror over the wire.\n\n\n  toJSON: -> [@errorType, @message]\n\n\n\n\nerrors.instantiate\n\n\n\n\n\n\n(string) \nerrorType\n - The error type.\n\n\n\n\n\n\n(any) \nargs...\n - Additional arguments to pass to the error type's\n\n\n\n\n\n\nconstructor. \nInstantiate an error based on error type, passing along args\nto the error's constructor.\n\n\nexports.instantiate = (errorType, args...) ->\n\n\n\n\nLook up the error type and use it. If it's not registered, fall back to\nthe TransmittableError superclass.\n\n\n  Types = exports.transmittableErrors()\n  Type = if Types[errorType]? then Types[errorType] else TransmittableError\n\n\n\n\nTrickery to be able to essentially call \nnew\n with \nFunction::apply\n.\n\n\n  IType = do (Type) ->\n    F = (args) -> Type.apply this, args\n    F.prototype = Type.prototype\n    (args) -> new F args\n\n\n\n\nThrow so we have a (possibly) meaningful stack.\n\n\n  try\n    throw new Error()\n  catch error\n    stack = error.stack\n\n  error = IType args\n  error.stack = stack\n  error\n\n\n\n\nerrors.message\n\n\n\n\n(Error) \nerror\n - The error object.\n\n\n\n\nExtract an error message from an error.\n\n\nexports.message = (error) ->\n\n\n\n\nOne of us! One of us!\n\n\n  output = if error instanceof TransmittableError\n    error.template\n\n\n\n\nAbstract Error.\n\n\n  else if error instanceof Error\n    TransmittableError::template.replace ':message', error.message\n\n\n\n\nNot an instance of \nError\n. This probably shouldn't happen, but we deal\nwith it anyway.\n\n\n  else\n    TransmittableError::template.replace ':message', error.toString()\n\n\n\n\nReplace placeholders in the template.\n\n\n  output = output.replace \":#{key}\", value for key, value of error\n  output\n\n\n\n\nerrors.serialize\n\n\n\n\n(Error) \nerror\n - The error object.\n\n\n\n\nSerialize an error to send over the wire.\n\n\nexports.serialize = (error) ->\n\n\n\n\nOne of us! One of us!\n\n\n  if error instanceof TransmittableError\n    error.toJSON()\n\n\n\n\nAbstract Error.\n\n\n  else if error instanceof Error\n    [undefined, error.message]\n\n\n\n\nNot an instance of \nError\n. This probably shouldn't happen, but we deal\nwith it anyway.\n\n\n  else\n    [undefined, error]\n\n\n\n\nerrors.stack\n\n\n\n\n(Error) \nerror\n - The error object.\n\n\n\n\nExtract the stack trace from an error.\n\n\nexports.stack = (error) ->\n\n\n\n\nDoes the stack trace exist?\n\n\n  formatStack = if (formatStack = error.stack)?\n\n\n\n\nIf so, shift off the first line (the message).\n\n\n    formatStack = formatStack.split '\\n'\n    formatStack.shift()\n    '\\n' + formatStack.join '\\n'\n\n\n\n\nOtherwise, we don't have much to work with...\n\n\n  else\n    ''\n\n\n\n\nPrepend our pretty formatted message before the stack trace.\n\n\n  \"#{@message error}#{formatStack}\"\n\n\n\n\nerrors.transmittableErrors\n\n\nCollect the error types implemented by packages.\n\n\nexports.transmittableErrors = ->\n\n  _ = require 'lodash'\n\n\n\n\nInvoke hook \nshrubTransmittableErrors\n\n\nAllows packages to specify transmittable errors. Implementations should\nreturn a subclass of \nTransmittableError\n.\n\n\n  Types = {}\n\n  Types[Type::errorType] = Type for Type in [TransmittableError].concat(\n    _.flatten pkgman.invokeFlat 'shrubTransmittableErrors'\n  )\n\n  Types\n\n\n\n\nerrors.unserialize\n\n\nUnserialize an error from over the wire.\n\n\nexports.unserialize = (data) -> exports.instantiate.apply null, data",
            "title": "errors.coffee"
        },
        {
            "location": "/source/client/modules/errors/#error-handling",
            "text": "pkgman = require 'pkgman'",
            "title": "Error handling"
        },
        {
            "location": "/source/client/modules/errors/#transmittableerror",
            "text": "Extend this class if you'd like to implement an error.  exports.TransmittableError = class TransmittableError extends Error",
            "title": "TransmittableError"
        },
        {
            "location": "/source/client/modules/errors/#transmittableerrorconstructor",
            "text": "See: https://github.com/jashkenas/coffee-script/issues/2359    constructor: (@message) ->",
            "title": "TransmittableError#constructor"
        },
        {
            "location": "/source/client/modules/errors/#transmittableerrorerrortype",
            "text": "A unique key for this error.    errorType: 'unknown'",
            "title": "TransmittableError#errorType"
        },
        {
            "location": "/source/client/modules/errors/#transmittableerrortemplate",
            "text": "The template used to format the error output.    template: 'Unknown error: :message'",
            "title": "TransmittableError#template"
        },
        {
            "location": "/source/client/modules/errors/#transmittableerrortojson",
            "text": "Implement this if you need to transmit more than just the error type and\nthe message. Shrub uses the result from this function to serialize the\nerror over the wire.    toJSON: -> [@errorType, @message]",
            "title": "TransmittableError#toJSON"
        },
        {
            "location": "/source/client/modules/errors/#errorsinstantiate",
            "text": "(string)  errorType  - The error type.    (any)  args...  - Additional arguments to pass to the error type's    constructor.  Instantiate an error based on error type, passing along args\nto the error's constructor.  exports.instantiate = (errorType, args...) ->  Look up the error type and use it. If it's not registered, fall back to\nthe TransmittableError superclass.    Types = exports.transmittableErrors()\n  Type = if Types[errorType]? then Types[errorType] else TransmittableError  Trickery to be able to essentially call  new  with  Function::apply .    IType = do (Type) ->\n    F = (args) -> Type.apply this, args\n    F.prototype = Type.prototype\n    (args) -> new F args  Throw so we have a (possibly) meaningful stack.    try\n    throw new Error()\n  catch error\n    stack = error.stack\n\n  error = IType args\n  error.stack = stack\n  error",
            "title": "errors.instantiate"
        },
        {
            "location": "/source/client/modules/errors/#errorsmessage",
            "text": "(Error)  error  - The error object.   Extract an error message from an error.  exports.message = (error) ->  One of us! One of us!    output = if error instanceof TransmittableError\n    error.template  Abstract Error.    else if error instanceof Error\n    TransmittableError::template.replace ':message', error.message  Not an instance of  Error . This probably shouldn't happen, but we deal\nwith it anyway.    else\n    TransmittableError::template.replace ':message', error.toString()  Replace placeholders in the template.    output = output.replace \":#{key}\", value for key, value of error\n  output",
            "title": "errors.message"
        },
        {
            "location": "/source/client/modules/errors/#errorsserialize",
            "text": "(Error)  error  - The error object.   Serialize an error to send over the wire.  exports.serialize = (error) ->  One of us! One of us!    if error instanceof TransmittableError\n    error.toJSON()  Abstract Error.    else if error instanceof Error\n    [undefined, error.message]  Not an instance of  Error . This probably shouldn't happen, but we deal\nwith it anyway.    else\n    [undefined, error]",
            "title": "errors.serialize"
        },
        {
            "location": "/source/client/modules/errors/#errorsstack",
            "text": "(Error)  error  - The error object.   Extract the stack trace from an error.  exports.stack = (error) ->  Does the stack trace exist?    formatStack = if (formatStack = error.stack)?  If so, shift off the first line (the message).      formatStack = formatStack.split '\\n'\n    formatStack.shift()\n    '\\n' + formatStack.join '\\n'  Otherwise, we don't have much to work with...    else\n    ''  Prepend our pretty formatted message before the stack trace.    \"#{@message error}#{formatStack}\"",
            "title": "errors.stack"
        },
        {
            "location": "/source/client/modules/errors/#errorstransmittableerrors",
            "text": "Collect the error types implemented by packages.  exports.transmittableErrors = ->\n\n  _ = require 'lodash'  Invoke hook  shrubTransmittableErrors  Allows packages to specify transmittable errors. Implementations should\nreturn a subclass of  TransmittableError .    Types = {}\n\n  Types[Type::errorType] = Type for Type in [TransmittableError].concat(\n    _.flatten pkgman.invokeFlat 'shrubTransmittableErrors'\n  )\n\n  Types",
            "title": "errors.transmittableErrors"
        },
        {
            "location": "/source/client/modules/errors/#errorsunserialize",
            "text": "Unserialize an error from over the wire.  exports.unserialize = (data) -> exports.instantiate.apply null, data",
            "title": "errors.unserialize"
        },
        {
            "location": "/source/client/modules/errors.spec/",
            "text": "errors = require 'errors'\n\ndescribe 'errors', ->\n\n  error = null\n\n  beforeEach ->\n\n    error = errors.instantiate 'unknown', 'Test'\n\n  it 'instantiates errors', ->\n\n    expect(error instanceof Error).toBe true\n\n  it \"handles (even abstract errors') messages\", ->\n\n    expect(errors.message error).toBe 'Unknown error: Test'\n\n    expect(errors.message new Error 'Foo').toBe 'Unknown error: Foo'\n\n    expect(errors.message 'Blah').toBe 'Unknown error: Blah'\n\n  it 'serializes (even abstract) errors', ->\n\n    O = errors.serialize error\n    expect(O[0]).toBe error.errorType\n    expect(O[1]).toBe error.message\n\n    O = errors.serialize new Error 'Foobar'\n    expect(O[0]).not.toBeDefined()\n    expect(O[1]).toBe 'Foobar'\n\n    O = errors.serialize 'Hmm'\n    expect(O[0]).not.toBeDefined()\n    expect(O[1]).toBe 'Hmm'\n\n  it 'unserializes (even abstract) errors', ->\n\n    O = errors.serialize error\n    expect(errors.message errors.unserialize O).toBe errors.message error\n\n    O = [undefined, 'Blah']\n    expect(errors.message errors.unserialize O).toBe 'Unknown error: Blah'",
            "title": "errors.spec.coffee"
        },
        {
            "location": "/source/client/modules/middleware/",
            "text": "Abstract middleware stacks\n\n\n{EventEmitter} = require 'events'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\n\n\n\nImplements a middleware stack. Middleware functions can be added to the\nstack with \nuse\n. Calling \ndispatch\n invokes the middleware functions\nserially.\n\n\nDefining middleware\n\n\nEach middleware accepts an arbitrary parameters and finally a \nnext\n\nfunction. When a middleware finishes, it must call the \nnext\n function.\nIf there was an error, it must be thrown or passed as the first argument to\n\nnext\n. If no error occurred, \nnext\n must be invoked without arguments.\nError-handling middleware can also be defined. These middleware take an\nadditional parameter at the beginning of the function signature: \nerror\n.\nError-handling middleware are only called if a previous middleware threw\nor passed an error. Conversely, non-error-handling middleware are skipped\nif a previous error occurred.\n\n\nexports.Middleware = class Middleware extends EventEmitter\n\n\n\n\nconstructor\n\n\nCreate a middleware stack.\n\n\n  constructor: -> @_middleware = []\n\n\n\n\nMiddlware#use\n\n\n\n\n(function) \nfn\n - A middleware function.\n\n\n\n\nAdd a middleware function to the stack.\n\n\n  use: (fn) -> @_middleware.push fn\n\n\n\n\nMiddleware#dispatch\n\n\n\n\n\n\n(mixed) \n...\n - Zero or more values to pass to the middleware.\n\n\n\n\n\n\n(function) \nfn\n - A function invoked when the middleware stack has\nfinished. If an error occurred, it will be passed as the first argument.\n\n\n\n\n\n\nInvoke the middleware functions serially.\n\n\n  dispatch: (args..., fn) ->\n    self = this\n\n    index = 0\n\n    invoke = (error) ->\n\n      self.emit 'invoked', self._middleware[index - 1] if index > 0\n\n\n\n\nCall \nfn\n with any error if we're done.\n\n\n      if index is self._middleware.length\n\n\n\n\nIgnore any final error, as we don't want it to cascade back up the\nrecursive invocation path.\n\n\n        try\n          return fn error\n        catch error\n\n      current = self._middleware[index++]\n\n\n\n\nError-handling middleware.\n\n\n      if current.length is args.length + 2\n\n\n\n\nAn error occurred previously.\n\n\n        if error?\n\n\n\n\nTry to invoke the middleware, if it throws, just catch the error\nand pass it along.\n\n\n          try\n            localArgs = args.concat()\n            localArgs.unshift error\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error\n\n\n\n\nNo previous error; skip this middleware.\n\n\n        else\n\n          invoke error\n\n\n\n\nNon-error-handling middleware.\n\n\n      else\n\n\n\n\nAn error occurred previously, skip this middleware.\n\n\n        if error?\n\n          invoke error\n\n\n\n\nNo previous error.\n\n\n        else\n\n\n\n\nTry to invoke the middleware, if it throws, just catch the error\nand pass it along.\n\n\n          try\n            localArgs = args.concat()\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error\n\n\n\n\nKick things off.\n\n\n    invoke()\n\n\n\n\nmiddleware.fromHook\n\n\nCreate a middleware stack from the results of a hook and path\nconfiguration.\n\n\nexports.fromHook = (hook, paths, args...) ->\n\n  debugSilly = require('debug') 'shrub-silly:middleware'\n\n  middleware = new Middleware()\n\n\n\n\nInvoke the hook and \nuse\n the middleware in the paths configuration order.\n\n\n  args.unshift hook\n  hookResults = pkgman.invoke args...\n  for path in paths ? []\n    continue unless (spec = hookResults[path])?\n\n    debugSilly \"- - #{spec.label}\"\n\n    middleware.use fn for fn in spec.middleware ? []\n\n  middleware\n\n\n\n\nmiddleware.fromConfig\n\n\nCreate a middleware stack from a configuration path.\n\n\nexports.fromConfig = (path, args...) ->\n\n  exports.fromHook(\n    pkgman.normalizePath path\n    config.get \"packageConfig:#{path}\"\n  )",
            "title": "middleware.coffee"
        },
        {
            "location": "/source/client/modules/middleware/#abstract-middleware-stacks",
            "text": "{EventEmitter} = require 'events'\n\nconfig = require 'config'\npkgman = require 'pkgman'  Implements a middleware stack. Middleware functions can be added to the\nstack with  use . Calling  dispatch  invokes the middleware functions\nserially.",
            "title": "Abstract middleware stacks"
        },
        {
            "location": "/source/client/modules/middleware/#defining-middleware",
            "text": "Each middleware accepts an arbitrary parameters and finally a  next \nfunction. When a middleware finishes, it must call the  next  function.\nIf there was an error, it must be thrown or passed as the first argument to next . If no error occurred,  next  must be invoked without arguments.\nError-handling middleware can also be defined. These middleware take an\nadditional parameter at the beginning of the function signature:  error .\nError-handling middleware are only called if a previous middleware threw\nor passed an error. Conversely, non-error-handling middleware are skipped\nif a previous error occurred.  exports.Middleware = class Middleware extends EventEmitter",
            "title": "Defining middleware"
        },
        {
            "location": "/source/client/modules/middleware/#constructor",
            "text": "Create a middleware stack.    constructor: -> @_middleware = []",
            "title": "constructor"
        },
        {
            "location": "/source/client/modules/middleware/#middlwareuse",
            "text": "(function)  fn  - A middleware function.   Add a middleware function to the stack.    use: (fn) -> @_middleware.push fn",
            "title": "Middlware#use"
        },
        {
            "location": "/source/client/modules/middleware/#middlewaredispatch",
            "text": "(mixed)  ...  - Zero or more values to pass to the middleware.    (function)  fn  - A function invoked when the middleware stack has\nfinished. If an error occurred, it will be passed as the first argument.    Invoke the middleware functions serially.    dispatch: (args..., fn) ->\n    self = this\n\n    index = 0\n\n    invoke = (error) ->\n\n      self.emit 'invoked', self._middleware[index - 1] if index > 0  Call  fn  with any error if we're done.        if index is self._middleware.length  Ignore any final error, as we don't want it to cascade back up the\nrecursive invocation path.          try\n          return fn error\n        catch error\n\n      current = self._middleware[index++]  Error-handling middleware.        if current.length is args.length + 2  An error occurred previously.          if error?  Try to invoke the middleware, if it throws, just catch the error\nand pass it along.            try\n            localArgs = args.concat()\n            localArgs.unshift error\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error  No previous error; skip this middleware.          else\n\n          invoke error  Non-error-handling middleware.        else  An error occurred previously, skip this middleware.          if error?\n\n          invoke error  No previous error.          else  Try to invoke the middleware, if it throws, just catch the error\nand pass it along.            try\n            localArgs = args.concat()\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error  Kick things off.      invoke()",
            "title": "Middleware#dispatch"
        },
        {
            "location": "/source/client/modules/middleware/#middlewarefromhook",
            "text": "Create a middleware stack from the results of a hook and path\nconfiguration.  exports.fromHook = (hook, paths, args...) ->\n\n  debugSilly = require('debug') 'shrub-silly:middleware'\n\n  middleware = new Middleware()  Invoke the hook and  use  the middleware in the paths configuration order.    args.unshift hook\n  hookResults = pkgman.invoke args...\n  for path in paths ? []\n    continue unless (spec = hookResults[path])?\n\n    debugSilly \"- - #{spec.label}\"\n\n    middleware.use fn for fn in spec.middleware ? []\n\n  middleware",
            "title": "middleware.fromHook"
        },
        {
            "location": "/source/client/modules/middleware/#middlewarefromconfig",
            "text": "Create a middleware stack from a configuration path.  exports.fromConfig = (path, args...) ->\n\n  exports.fromHook(\n    pkgman.normalizePath path\n    config.get \"packageConfig:#{path}\"\n  )",
            "title": "middleware.fromConfig"
        },
        {
            "location": "/source/client/modules/middleware.spec/",
            "text": "middleware = require 'middleware'\n\ndescribe 'middleware', ->\n\n  it 'can use and dispatch', ->\n\n    middleware_ = new middleware.Middleware()\n\n    first = false\n    second = false\n    third = false\n\n    middleware_.use (req, res, next) ->\n\n      first = req.foo is 69 and res.foo is 420\n\n      next()\n\n    middleware_.use (req, res, next) ->\n\n      second = req.foo is 69 and res.foo is 420\n\n      next()\n\n    req = foo: 69\n    res = foo: 420\n\n    middleware_.dispatch req, res, (error) ->\n\n      third = not error?\n\n    expect(first).toBe true\n    expect(second).toBe true\n    expect(third).toBe true\n\n  it 'can properly handle errors', ->\n\n    middleware_ = new middleware.Middleware()\n\n    first = true\n    second = false\n    third = true\n    fourth = false\n    fifth = false\n\n    middleware_.use (req, res, next) ->\n\n      next new Error()\n\n    middleware_.use (req, res, next) ->\n\n      first = false\n\n      next()\n\n    middleware_.use (error, req, res, next) ->\n\n      second = true\n\n      throw new Error()\n\n    middleware_.use (req, res, next) ->\n\n      third = false\n\n      next()\n\n    middleware_.use (error, req, res, next) ->\n\n      fourth = true\n\n      next error\n\n    req = null\n    res = null\n\n    middleware_.dispatch req, res, (error) ->\n\n      fifth = error?\n\n    expect(first).toBe true\n    expect(second).toBe true\n    expect(third).toBe true\n    expect(fourth).toBe true\n    expect(fifth).toBe true",
            "title": "middleware.spec.coffee"
        },
        {
            "location": "/source/client/modules/pkgman/",
            "text": "Package manager\n\n\nRegisters packages and handles hook registration and invocation as well as\nintrospection.\n\n\ndebug = require('debug') 'shrub:pkgman'\ndebugSilly = require('debug') 'shrub-silly:pkgman'\n\n\n\n\nIndex by hook and path for faster invocation and introspection.\n\n\nhookIndex = {}\npathIndex = {}\n\n\n\n\nA list of registered packages.\n\n\n_packages = []\n\n\n\n\nRegistrar object passed to packages to allow them to register hooks and/or\nrecur into their own subpackages to allow them to.\n\n\nclass PkgmanRegistrar\n\n\n\n\nconstructor\n\n\nInstantiate the registrar with the current (sub)package path.\n\n\n  constructor: (@_path) ->\n\n\n\n\nPkgmanRegistrar#path\n\n\nGet the current (sub) package path.\n\n\n  path: -> @_path\n\n\n\n\nPkgmanRegistrar#recur\n\n\n\n\n(string array) \npaths\n - The list of submodule paths to register.\n\n\n\n\nRecur into subpackages to register them and allow them to register hooks\nand/or recur further.\n\n\n  recur: (paths) ->\n\n    for path in paths\n\n      subpath = \"#{@_path}/#{path}\"\n\n      debugSilly \"Requiring #{subpath}\"\n      submodule = require subpath\n      debugSilly \"Required #{subpath}\"\n\n      debugSilly \"Registering hooks for #{subpath}\"\n      submodule.pkgmanRegister? new PkgmanRegistrar subpath\n      debugSilly \"Registered hooks for #{subpath}\"\n\n    return\n\n\n\n\nPkgmanRegistrar#registerHook\n\n\n\n\n\n\n(optional string) \nsubmodule\n - Register this hook under a submodule.\nThis is a convenience for when you might need to register more than one\nimplementation of a hook, bur prefer to keep both implementations in the\nsame physical file.\n\n\n\n\n\n\n(string) \nhook\n - The name of the hook to register.\n\n\n\n\n\n\n(function) \nimpl\n - The hook implementation function. This is invoked\nwhen the hook is invoked. The signature of the implementation function may\nvary, consult the documentation for the specific hook to learn more.\n\n\n\n\n\n\nRegister a hook implementation.\n\n\n  registerHook: (submodule, hook, impl) ->\n\n\n\n\nIf \nsubmodule\n was passed in, modify the path this hook is registered\nagainst.\n\n\n    if impl?\n\n      path = \"#{@_path}/#{submodule}\"\n\n\n\n\nOtherwise, fix up the args.\n\n\n    else\n\n      path = @_path\n      impl = hook\n      hook = submodule\n\n\n\n\nPopulate the indexes with the registered hook.\n\n\n    debugSilly \"Registering hook #{hook}\"\n\n    (hookIndex[hook] ?= []).push path\n    (pathIndex[path] ?= {})[hook] = impl\n\n    debugSilly \"Registered hook #{hook}\"\n\n\n\n\npkgman.rebuildPackageCache\n\n\nRebuild the package cache.\n\n\nDo not invoke this unless you are absolutely sure you know what you're\ndoing.\n\n\nexports.rebuildPackageCache = ->\n  modules = {}\n  hookIndex = {}\n  pathIndex = {}\n\n  for name in _packages\n\n\n\n\nTry to require the package module.\n\n\n    try\n\n      debugSilly \"Requiring package #{name}\"\n\n      module_ = require name\n\n    catch error\n\n\n\n\nSuppress missing package errors.\n\n\n      if error.toString() is \"Error: Cannot find module '#{name}'\"\n        debug \"Missing package #{name}.\"\n        continue\n\n      throw error\n\n    debugSilly \"Required package #{name}\"\n\n    modules[name] = module_\n\n\n\n\nRegister hooks.\n\n\n  for path, module_ of modules\n\n    debugSilly \"Registering hooks for #{path}\"\n    module_.pkgmanRegister? new PkgmanRegistrar path\n    debugSilly \"Registered hooks for #{path}\"\n\n  return\n\n\n\n\npkgman.registerPackageList\n\n\n\n\n(string array) \npackages\n - The list of packages to register.\n\n\n\n\nRegister a list of packages.\n\n\nexports.registerPackageList = (packages) ->\n  _packages.push.apply _packages, packages\n  exports.rebuildPackageCache()\n\n\n\n\npkgman.invoke\n\n\n\n\n\n\n(string) \nhook\n - The name of the hook to invoke.\n\n\n\n\n\n\n(args...) \nargs\n - Arguments to pass along to implementations of the hook.\n\n\n\n\n\n\nInvoke a hook with arguments. Return the result as an object, keyed by\npackage path.\n\n\nexports.invoke = (hook, args...) ->\n\n  results = {}\n\n  for path in exports.packagesImplementing hook\n    results[path] = exports.invokePackage path, hook, args...\n\n  return results\n\n\n\n\npkgman.invokeFlat\n\n\n\n\n\n\n(string) \nhook\n - The name of the hook to invoke.\n\n\n\n\n\n\n(args...) \nargs\n - Arguments to pass along to implementations of the hook.\n\n\n\n\n\n\nInvoke a hook with arguments. Return the result as an array.\n\n\nexports.invokeFlat = (hook, args...) ->\n\n  for path in exports.packagesImplementing hook\n    exports.invokePackage path, hook, args...\n\n\n\n\npkgman.invokePackage\n\n\n\n\n\n\n(string) \npath\n - The path of the package whose implementation we're\ninvoking.\n\n\n\n\n\n\n(string) \nhook\n - The name of the hook to invoke.\n\n\n\n\n\n\n(args...) \nargs\n - Arguments to pass along to the hook implementation.\n\n\n\n\n\n\nInvoke a package's implementation of a hook with arguments. Return the\nresult.\n\n\nexports.invokePackage = (path, hook, args...) ->\n  pathIndex?[path]?[hook]? args...\n\n\n\n\npkgman.packageExists\n\n\n\n\n(string) \nname\n - The name of the package to check.\n\n\n\n\nCheck whether a package exists.\n\n\nexports.packageExists = (name) -> -1 isnt _packages.indexOf name\n\n\n\n\npkgman.packagesImplementing\n\n\n\n\n(string) \nhook\n - The hook to check.\n\n\n\n\nReturn a list of packages implementing the hook.\n\n\nexports.packagesImplementing = (hook) -> hookIndex?[hook] ? []\n\n\n\n\npkgman.normalizePath\n\n\n\n\n\n\n(string) \npath\n - The path to normalize.\n\n\n\n\n\n\n(Boolean) \ncapitalize\n - Whether to capitalize the first letter.\n\n\n\n\n\n\nConverts a package path (e.g. \nshrub-user/login\n) to a normalized path\n(e.g. \nshrubUserLogin\n).\n\n\nexports.normalizePath = (path, capitalize = false) ->\n\n  i8n = require 'inflection'\n\n  parts = for part, i in path.split '/'\n    i8n.camelize i8n.underscore(\n      part.replace /[^\\w]/g, '_'\n      0 is i\n    )\n\n  i8n.camelize (i8n.underscore parts.join ''), not capitalize",
            "title": "pkgman.coffee"
        },
        {
            "location": "/source/client/modules/pkgman/#package-manager",
            "text": "Registers packages and handles hook registration and invocation as well as\nintrospection.  debug = require('debug') 'shrub:pkgman'\ndebugSilly = require('debug') 'shrub-silly:pkgman'  Index by hook and path for faster invocation and introspection.  hookIndex = {}\npathIndex = {}  A list of registered packages.  _packages = []  Registrar object passed to packages to allow them to register hooks and/or\nrecur into their own subpackages to allow them to.  class PkgmanRegistrar",
            "title": "Package manager"
        },
        {
            "location": "/source/client/modules/pkgman/#constructor",
            "text": "Instantiate the registrar with the current (sub)package path.    constructor: (@_path) ->",
            "title": "constructor"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmanregistrarpath",
            "text": "Get the current (sub) package path.    path: -> @_path",
            "title": "PkgmanRegistrar#path"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmanregistrarrecur",
            "text": "(string array)  paths  - The list of submodule paths to register.   Recur into subpackages to register them and allow them to register hooks\nand/or recur further.    recur: (paths) ->\n\n    for path in paths\n\n      subpath = \"#{@_path}/#{path}\"\n\n      debugSilly \"Requiring #{subpath}\"\n      submodule = require subpath\n      debugSilly \"Required #{subpath}\"\n\n      debugSilly \"Registering hooks for #{subpath}\"\n      submodule.pkgmanRegister? new PkgmanRegistrar subpath\n      debugSilly \"Registered hooks for #{subpath}\"\n\n    return",
            "title": "PkgmanRegistrar#recur"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmanregistrarregisterhook",
            "text": "(optional string)  submodule  - Register this hook under a submodule.\nThis is a convenience for when you might need to register more than one\nimplementation of a hook, bur prefer to keep both implementations in the\nsame physical file.    (string)  hook  - The name of the hook to register.    (function)  impl  - The hook implementation function. This is invoked\nwhen the hook is invoked. The signature of the implementation function may\nvary, consult the documentation for the specific hook to learn more.    Register a hook implementation.    registerHook: (submodule, hook, impl) ->  If  submodule  was passed in, modify the path this hook is registered\nagainst.      if impl?\n\n      path = \"#{@_path}/#{submodule}\"  Otherwise, fix up the args.      else\n\n      path = @_path\n      impl = hook\n      hook = submodule  Populate the indexes with the registered hook.      debugSilly \"Registering hook #{hook}\"\n\n    (hookIndex[hook] ?= []).push path\n    (pathIndex[path] ?= {})[hook] = impl\n\n    debugSilly \"Registered hook #{hook}\"",
            "title": "PkgmanRegistrar#registerHook"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmanrebuildpackagecache",
            "text": "Rebuild the package cache.  Do not invoke this unless you are absolutely sure you know what you're\ndoing.  exports.rebuildPackageCache = ->\n  modules = {}\n  hookIndex = {}\n  pathIndex = {}\n\n  for name in _packages  Try to require the package module.      try\n\n      debugSilly \"Requiring package #{name}\"\n\n      module_ = require name\n\n    catch error  Suppress missing package errors.        if error.toString() is \"Error: Cannot find module '#{name}'\"\n        debug \"Missing package #{name}.\"\n        continue\n\n      throw error\n\n    debugSilly \"Required package #{name}\"\n\n    modules[name] = module_  Register hooks.    for path, module_ of modules\n\n    debugSilly \"Registering hooks for #{path}\"\n    module_.pkgmanRegister? new PkgmanRegistrar path\n    debugSilly \"Registered hooks for #{path}\"\n\n  return",
            "title": "pkgman.rebuildPackageCache"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmanregisterpackagelist",
            "text": "(string array)  packages  - The list of packages to register.   Register a list of packages.  exports.registerPackageList = (packages) ->\n  _packages.push.apply _packages, packages\n  exports.rebuildPackageCache()",
            "title": "pkgman.registerPackageList"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmaninvoke",
            "text": "(string)  hook  - The name of the hook to invoke.    (args...)  args  - Arguments to pass along to implementations of the hook.    Invoke a hook with arguments. Return the result as an object, keyed by\npackage path.  exports.invoke = (hook, args...) ->\n\n  results = {}\n\n  for path in exports.packagesImplementing hook\n    results[path] = exports.invokePackage path, hook, args...\n\n  return results",
            "title": "pkgman.invoke"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmaninvokeflat",
            "text": "(string)  hook  - The name of the hook to invoke.    (args...)  args  - Arguments to pass along to implementations of the hook.    Invoke a hook with arguments. Return the result as an array.  exports.invokeFlat = (hook, args...) ->\n\n  for path in exports.packagesImplementing hook\n    exports.invokePackage path, hook, args...",
            "title": "pkgman.invokeFlat"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmaninvokepackage",
            "text": "(string)  path  - The path of the package whose implementation we're\ninvoking.    (string)  hook  - The name of the hook to invoke.    (args...)  args  - Arguments to pass along to the hook implementation.    Invoke a package's implementation of a hook with arguments. Return the\nresult.  exports.invokePackage = (path, hook, args...) ->\n  pathIndex?[path]?[hook]? args...",
            "title": "pkgman.invokePackage"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmanpackageexists",
            "text": "(string)  name  - The name of the package to check.   Check whether a package exists.  exports.packageExists = (name) -> -1 isnt _packages.indexOf name",
            "title": "pkgman.packageExists"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmanpackagesimplementing",
            "text": "(string)  hook  - The hook to check.   Return a list of packages implementing the hook.  exports.packagesImplementing = (hook) -> hookIndex?[hook] ? []",
            "title": "pkgman.packagesImplementing"
        },
        {
            "location": "/source/client/modules/pkgman/#pkgmannormalizepath",
            "text": "(string)  path  - The path to normalize.    (Boolean)  capitalize  - Whether to capitalize the first letter.    Converts a package path (e.g.  shrub-user/login ) to a normalized path\n(e.g.  shrubUserLogin ).  exports.normalizePath = (path, capitalize = false) ->\n\n  i8n = require 'inflection'\n\n  parts = for part, i in path.split '/'\n    i8n.camelize i8n.underscore(\n      part.replace /[^\\w]/g, '_'\n      0 is i\n    )\n\n  i8n.camelize (i8n.underscore parts.join ''), not capitalize",
            "title": "pkgman.normalizePath"
        },
        {
            "location": "/source/client/packages/",
            "text": "Package management for Angular\n\n\nThis is where shrub's package system meets Angular's module system.\nPackages' implementations of controllers, services, filters, providers, and\ndirectives are gathered and registered into Angular.\n\n\nangular.module('shrub.packages', [\n  'shrub.directive'\n  'shrub.require'\n  'shrub.pkgman'\n])\n\n  .config([\n    '$compileProvider', '$controllerProvider', '$filterProvider'\n    '$injector', '$provide', 'shrub-directiveProvider'\n    'shrub-pkgmanProvider', 'shrub-requireProvider'\n    (\n      $compileProvider, $controllerProvider, $filterProvider\n      $injector, $provide, directive, pkgman, {require}\n    ) ->\n\n      config = require 'config'\n      debug = require('debug') 'shrub:angular'\n\n\n\n\nInvoke hook \nshrubAngularController\n\n\n      debug 'Registering controllers...'\n\n      for path, injected of pkgman.invoke 'shrubAngularController'\n        controllerName = pkgman.normalizePath path\n        debug controllerName\n        $controllerProvider.register controllerName, injected\n\n      debug 'Controllers registered.'\n\n\n\n\nInvoke hook \nshrubAngularDirective\n\n\n      debug 'Registering directives...'\n\n      for path, injected of pkgman.invoke 'shrubAngularDirective'\n        directive.define path, injected\n\n      debug 'Directives registered.'\n\n\n\n\nInvoke hook \nshrubAngularFilter\n\n\n      debug 'Registering filters...'\n\n      for path, injected of pkgman.invoke 'shrubAngularFilter'\n        filterName = pkgman.normalizePath path\n        debug filterName\n        $filterProvider.register filterName, injected\n\n      debug 'Filters registered.'\n\n\n\n\nInvoke hook \nshrubAngularProvider\n\n\n      debug 'Registering providers...'\n\n      for path, provider of pkgman.invoke 'shrubAngularProvider'\n        debug path\n        $provide.provider path, provider\n\n      debug 'Providers registered.'\n\n\n\n\nInvoke hook \nshrubAngularService\n\n\n      debug 'Registering services...'\n\n      for path, injected of pkgman.invoke 'shrubAngularService'\n        debug path\n        $provide.service path, injected\n\n      debug 'Services registered.'\n\n  ])\n\n\n\n\nSet an injector so that Angular injection can occur out of band.\n\n\n  .run([\n    '$injector', 'shrub-require'\n    ($injector, require) ->\n\n      angular_ = require 'angular'\n      angular_.setInjector $injector\n\n  ])\n\n\n\n\nProvide Shrub's directive definition API.\n\n\nangular.module('shrub.directive', [\n  'shrub.pkgman'\n  'shrub.require'\n])\n\n  .provider 'shrub-directive', [\n    '$compileProvider', '$injector', '$provide', 'shrub-pkgmanProvider'\n    'shrub-requireProvider'\n    ($compileProvider, $injector, $provide, pkgman, {require}) ->\n\n      debug = require('debug') 'shrub:angular'\n\n\n\n\nNormalize, augment, and register a directive.\n\n\n      prepareDirective = (name, path, injected) -> ($injector) ->\n\n\n\n\nNormalize the directive to Directive Definition Object form.\n\n\n        directive = $injector.invoke injected\n        directive = link: directive if angular.isFunction directive\n\n\n\n\nEnsure a compilation function exists for the directive which by\ndefault returns the \nlink\n function.\n\n\n        directive.compile ?= -> directive.link\n\n\n\n\nProxy any defined link function, firing any attached any\ncontrollers' \nlink\n method, as well as passing execution on to the\noriginal \nlink\n function.\n\n\n        link = directive.link\n        directive.link = (scope, element, attrs, controllers) ->\n          if controllers?\n            controllers = [controllers] unless angular.isArray controllers\n            controller.link? arguments... for controller in controllers\n\n          link? arguments...\n\n\n\n\nEnsure the directive has a name. Defaults to the normalized path of\nthe implementing package.\n\n\n        directive.name ?= name\n\n\n\n\nIf controller binding is specified, the controller defaults to the\ndirective name. In other words, if you define a directive and a\ncontroller in the same package, and specify\n\ndirective.bindToController = true\n, your directive will include the\ncontroller automatically.\n\n\n        if directive.bindToController\n          directive.controller ?= directive.name\n\n\n\n\nHandle a bunch of internal Angular normalization.\n\n\n        directive.require ?= directive.controller and directive.name\n        directive.priority ?= 0\n        directive.restrict ?= 'EA'\n\n        if angular.isObject directive.scope\n          directive.$$isolateBindings = isolateBindingsFor directive\n\n\n\n\nInvoke hook \nshrubAngularDirectiveAlter\n\n\n        for injectedDirective in pkgman.invokeFlat(\n          'shrubAngularDirectiveAlter', directive, path\n        )\n          $injector.invoke injectedDirective\n\n\n\n\nHaven't gone deep enough into Angular to understand why this has to\nbe, but it does.\n\n\n        directive.index = 0\n        return [directive]\n\n\n\n\nInternal Angular state that we have to reset.\n\n\n      isolateBindingsFor = (directive) ->\n\n        LOCAL_REGEXP = /^\\s*([@&]|=(\\*?))(\\??)\\s*(\\w*)\\s*$/\n\n        bindings = {}\n\n        for scopeName, definition of directive.scope\n          match = definition.match LOCAL_REGEXP\n\n          throw angular.$$minErr('$compile')(\n            'iscp'\n            \"\n              Invalid isolate scope definition for directive '{0}'.\n              Definition: {... {1}: '{2}' ...}\n            \"\n            directive.name, scopeName, definition\n          ) unless match\n\n          bindings[scopeName] =\n            mode: match[1][0]\n            collection: match[2] is '*'\n            optional: match[3] is '?'\n            attrName: match[4] or scopeName\n\n        return bindings\n\n\n\n\nBuild the directive provider.\n\n\n      directive = {}\n\n\n\n\nDefine a directive.\n\n\n      directive.define = (path, injected) ->\n        directiveName = pkgman.normalizePath path\n        debug directiveName\n\n\n\n\nFirst, register it through Angular's normal registration mechanism.\nThis sets a bunch of internal state we don't have access to.\n\n\n        $compileProvider.directive directiveName, injected\n\n\n\n\nFollow that by normalizing, augmenting, and registering the\ndirective again. It will run over the previous definition, ensuring\neverything works nicely.\n\n\n        $provide.factory \"#{directiveName}Directive\", [\n          '$injector', prepareDirective directiveName, path, injected\n        ]\n\n\n\n\nProvide the service.\n\n\n      directive.$get = -> directive\n\n      return directive\n\n  ]\n\n\n\n\nProvide Angular with access to Shrub's package manager.\n\n\nangular.module('shrub.pkgman', [\n  'shrub.require'\n])\n\n  .provider 'shrub-pkgman', [\n    '$provide', 'shrub-requireProvider'\n    ($provide, {require}) ->\n\n      config = require 'config'\n      debug = require('debug') 'shrub:pkgman'\n      pkgman = require 'pkgman'\n\n\n\n\nLoad the package list from configuration.\n\n\n      debug 'Loading packages...'\n\n      pkgman.registerPackageList config.get 'packageList'\n\n      debug 'Packages loaded.'\n\n\n\n\nSimply pass along pkgman as the 'service'.\n\n\n      pkgman.$get = -> pkgman\n\n      return pkgman\n  ]",
            "title": "packages.coffee"
        },
        {
            "location": "/source/client/packages/#package-management-for-angular",
            "text": "This is where shrub's package system meets Angular's module system.\nPackages' implementations of controllers, services, filters, providers, and\ndirectives are gathered and registered into Angular.  angular.module('shrub.packages', [\n  'shrub.directive'\n  'shrub.require'\n  'shrub.pkgman'\n])\n\n  .config([\n    '$compileProvider', '$controllerProvider', '$filterProvider'\n    '$injector', '$provide', 'shrub-directiveProvider'\n    'shrub-pkgmanProvider', 'shrub-requireProvider'\n    (\n      $compileProvider, $controllerProvider, $filterProvider\n      $injector, $provide, directive, pkgman, {require}\n    ) ->\n\n      config = require 'config'\n      debug = require('debug') 'shrub:angular'  Invoke hook  shrubAngularController        debug 'Registering controllers...'\n\n      for path, injected of pkgman.invoke 'shrubAngularController'\n        controllerName = pkgman.normalizePath path\n        debug controllerName\n        $controllerProvider.register controllerName, injected\n\n      debug 'Controllers registered.'  Invoke hook  shrubAngularDirective        debug 'Registering directives...'\n\n      for path, injected of pkgman.invoke 'shrubAngularDirective'\n        directive.define path, injected\n\n      debug 'Directives registered.'  Invoke hook  shrubAngularFilter        debug 'Registering filters...'\n\n      for path, injected of pkgman.invoke 'shrubAngularFilter'\n        filterName = pkgman.normalizePath path\n        debug filterName\n        $filterProvider.register filterName, injected\n\n      debug 'Filters registered.'  Invoke hook  shrubAngularProvider        debug 'Registering providers...'\n\n      for path, provider of pkgman.invoke 'shrubAngularProvider'\n        debug path\n        $provide.provider path, provider\n\n      debug 'Providers registered.'  Invoke hook  shrubAngularService        debug 'Registering services...'\n\n      for path, injected of pkgman.invoke 'shrubAngularService'\n        debug path\n        $provide.service path, injected\n\n      debug 'Services registered.'\n\n  ])  Set an injector so that Angular injection can occur out of band.    .run([\n    '$injector', 'shrub-require'\n    ($injector, require) ->\n\n      angular_ = require 'angular'\n      angular_.setInjector $injector\n\n  ])  Provide Shrub's directive definition API.  angular.module('shrub.directive', [\n  'shrub.pkgman'\n  'shrub.require'\n])\n\n  .provider 'shrub-directive', [\n    '$compileProvider', '$injector', '$provide', 'shrub-pkgmanProvider'\n    'shrub-requireProvider'\n    ($compileProvider, $injector, $provide, pkgman, {require}) ->\n\n      debug = require('debug') 'shrub:angular'  Normalize, augment, and register a directive.        prepareDirective = (name, path, injected) -> ($injector) ->  Normalize the directive to Directive Definition Object form.          directive = $injector.invoke injected\n        directive = link: directive if angular.isFunction directive  Ensure a compilation function exists for the directive which by\ndefault returns the  link  function.          directive.compile ?= -> directive.link  Proxy any defined link function, firing any attached any\ncontrollers'  link  method, as well as passing execution on to the\noriginal  link  function.          link = directive.link\n        directive.link = (scope, element, attrs, controllers) ->\n          if controllers?\n            controllers = [controllers] unless angular.isArray controllers\n            controller.link? arguments... for controller in controllers\n\n          link? arguments...  Ensure the directive has a name. Defaults to the normalized path of\nthe implementing package.          directive.name ?= name  If controller binding is specified, the controller defaults to the\ndirective name. In other words, if you define a directive and a\ncontroller in the same package, and specify directive.bindToController = true , your directive will include the\ncontroller automatically.          if directive.bindToController\n          directive.controller ?= directive.name  Handle a bunch of internal Angular normalization.          directive.require ?= directive.controller and directive.name\n        directive.priority ?= 0\n        directive.restrict ?= 'EA'\n\n        if angular.isObject directive.scope\n          directive.$$isolateBindings = isolateBindingsFor directive  Invoke hook  shrubAngularDirectiveAlter          for injectedDirective in pkgman.invokeFlat(\n          'shrubAngularDirectiveAlter', directive, path\n        )\n          $injector.invoke injectedDirective  Haven't gone deep enough into Angular to understand why this has to\nbe, but it does.          directive.index = 0\n        return [directive]  Internal Angular state that we have to reset.        isolateBindingsFor = (directive) ->\n\n        LOCAL_REGEXP = /^\\s*([@&]|=(\\*?))(\\??)\\s*(\\w*)\\s*$/\n\n        bindings = {}\n\n        for scopeName, definition of directive.scope\n          match = definition.match LOCAL_REGEXP\n\n          throw angular.$$minErr('$compile')(\n            'iscp'\n            \"\n              Invalid isolate scope definition for directive '{0}'.\n              Definition: {... {1}: '{2}' ...}\n            \"\n            directive.name, scopeName, definition\n          ) unless match\n\n          bindings[scopeName] =\n            mode: match[1][0]\n            collection: match[2] is '*'\n            optional: match[3] is '?'\n            attrName: match[4] or scopeName\n\n        return bindings  Build the directive provider.        directive = {}  Define a directive.        directive.define = (path, injected) ->\n        directiveName = pkgman.normalizePath path\n        debug directiveName  First, register it through Angular's normal registration mechanism.\nThis sets a bunch of internal state we don't have access to.          $compileProvider.directive directiveName, injected  Follow that by normalizing, augmenting, and registering the\ndirective again. It will run over the previous definition, ensuring\neverything works nicely.          $provide.factory \"#{directiveName}Directive\", [\n          '$injector', prepareDirective directiveName, path, injected\n        ]  Provide the service.        directive.$get = -> directive\n\n      return directive\n\n  ]  Provide Angular with access to Shrub's package manager.  angular.module('shrub.pkgman', [\n  'shrub.require'\n])\n\n  .provider 'shrub-pkgman', [\n    '$provide', 'shrub-requireProvider'\n    ($provide, {require}) ->\n\n      config = require 'config'\n      debug = require('debug') 'shrub:pkgman'\n      pkgman = require 'pkgman'  Load the package list from configuration.        debug 'Loading packages...'\n\n      pkgman.registerPackageList config.get 'packageList'\n\n      debug 'Packages loaded.'  Simply pass along pkgman as the 'service'.        pkgman.$get = -> pkgman\n\n      return pkgman\n  ]",
            "title": "Package management for Angular"
        },
        {
            "location": "/source/client/require/",
            "text": "Require system for Angular\n\n\nImplement require in the spirit of NodeJS.\n\n\n\n\n\nResolve the module name.\n\n\n_resolveModuleName = (name, parentFilename) ->\n\n\n\n\nStrip \n/index\n from the end, if necessary.\n\n\n  checkModuleName = (name) ->\n    return name if requires_[name]?\n    return \"#{name}/index\" if requires_[\"#{name}/index\"]?\n\n\n\n\nAbsolute path match?\n\n\n  return checked if (checked = checkModuleName name)?\n\n\n\n\nResolve relative paths. We have to check methods on \npath\n. See below for\nmore.\n\n\n  path = _require 'path'\n  return checked if (checked = checkModuleName(\n    path.resolve(path.dirname(parentFilename), name).substr 1\n  ))? if path.dirname? and path.resolve?\n\n\n\n\nOops, nothing resolved...\n\n\n  throw new Error \"Cannot find module '#{name}'\"\n\n\n\n\nInternal require function. Uses the parent filename to resolve relative\npaths.\n\n\n_require = (name, parentFilename) ->\n\n\n\n\nModule inclusion is cached.\n\n\n  unless requires_[name = _resolveModuleName name, parentFilename].module?\n\n\n\n\nExtract the module function ahead of time, so we can set up\nmodule/exports and assign it to the old value. Setting this up ahead of\ntime avoids cycles.\n\n\n    f = requires_[name]\n    exports = {}\n    module = exports: exports\n    requires_[name] = module: module\n\n\n\n\nInclude \npath\n, you may observe that this is dangerous because we're\nwithin the require system itself. This is correct and we have to check\nfor \ndirname\n to ensure the object has been required and populated.\n\n\n    path = _require 'path'\n    __dirname = (path.dirname? name) ? ''\n    __filename = name\n\n\n\n\nExecute the top-level module function, passing in all of our objects.\n\n\n    f(\n      module, exports, (name) -> _require name, __filename\n      __dirname, __filename\n    )\n\n  requires_[name].module.exports\n\n\n\n\nProvide require API to Angular.\n\n\nrequire = (name) -> _require name, ''\nangular.module('shrub.require', []).provider 'shrub-require', ->\n  require: require\n  $get: -> require",
            "title": "require.coffee"
        },
        {
            "location": "/source/client/require/#require-system-for-angular",
            "text": "Implement require in the spirit of NodeJS.   Resolve the module name.  _resolveModuleName = (name, parentFilename) ->  Strip  /index  from the end, if necessary.    checkModuleName = (name) ->\n    return name if requires_[name]?\n    return \"#{name}/index\" if requires_[\"#{name}/index\"]?  Absolute path match?    return checked if (checked = checkModuleName name)?  Resolve relative paths. We have to check methods on  path . See below for\nmore.    path = _require 'path'\n  return checked if (checked = checkModuleName(\n    path.resolve(path.dirname(parentFilename), name).substr 1\n  ))? if path.dirname? and path.resolve?  Oops, nothing resolved...    throw new Error \"Cannot find module '#{name}'\"  Internal require function. Uses the parent filename to resolve relative\npaths.  _require = (name, parentFilename) ->  Module inclusion is cached.    unless requires_[name = _resolveModuleName name, parentFilename].module?  Extract the module function ahead of time, so we can set up\nmodule/exports and assign it to the old value. Setting this up ahead of\ntime avoids cycles.      f = requires_[name]\n    exports = {}\n    module = exports: exports\n    requires_[name] = module: module  Include  path , you may observe that this is dangerous because we're\nwithin the require system itself. This is correct and we have to check\nfor  dirname  to ensure the object has been required and populated.      path = _require 'path'\n    __dirname = (path.dirname? name) ? ''\n    __filename = name  Execute the top-level module function, passing in all of our objects.      f(\n      module, exports, (name) -> _require name, __filename\n      __dirname, __filename\n    )\n\n  requires_[name].module.exports  Provide require API to Angular.  require = (name) -> _require name, ''\nangular.module('shrub.require', []).provider 'shrub-require', ->\n  require: require\n  $get: -> require",
            "title": "Require system for Angular"
        },
        {
            "location": "/source/config/default.settings/",
            "text": "Default site configuration\n\n\n\n\nThe list of packages active for this application.\n\n\npackageList: [\n  \"shrub-angular\",\n  \"shrub-assets\",\n  \"shrub-config\",\n  \"shrub-core\",\n  \"shrub-example\",\n  \"shrub-http-express\",\n  \"shrub-form\",\n  \"shrub-grunt\",\n  \"shrub-html5-local-storage\",\n  \"shrub-html5-notification\",\n  \"shrub-http\",\n  \"shrub-install\",\n  \"shrub-limiter\",\n  \"shrub-nodemailer\",\n  \"shrub-orm\",\n  \"shrub-passport\",\n  \"shrub-repl\",\n  \"shrub-rpc\",\n  \"shrub-skin\",\n  \"shrub-skin-strapped\",\n  \"shrub-session\",\n  \"shrub-socket\",\n  \"shrub-socket-socket.io\",\n  \"shrub-ui\",\n  \"shrub-user\",\n  \"shrub-user-local\",\n  \"shrub-user-reddit\",\n  \"shrub-villiany\",\n]\n\n\n\n\nHere you may set values for packages which correspond with the values\nprovided by packages' implementations of hook\n\nshrubConfigServer\n.\n\n\npackageConfig:\n\n\n\n\nUse the package name as the settings key.\n\n\n  shrub-core:\n\n\n\n\nIt's not uncommon to run your node application behind a reverse proxy.\nBy default, we'll provide both ipv4 and embedded ipv6 addresses for\nlocalhost. If a reverse proxy is running on the same machine you will\ntherefore automatically see the correct IP address in \nreq.normalizedIp\n\nwhich is provided to HTTP, socket connection, and RPC endpoint requests.\n\n\n    trustedProxies: [\n      \"127.0.0.1\",\n      \"::ffff:127.0.0.1\",\n    ]",
            "title": "default.settings.yml"
        },
        {
            "location": "/source/config/default.settings/#default-site-configuration",
            "text": "The list of packages active for this application.  packageList: [\n  \"shrub-angular\",\n  \"shrub-assets\",\n  \"shrub-config\",\n  \"shrub-core\",\n  \"shrub-example\",\n  \"shrub-http-express\",\n  \"shrub-form\",\n  \"shrub-grunt\",\n  \"shrub-html5-local-storage\",\n  \"shrub-html5-notification\",\n  \"shrub-http\",\n  \"shrub-install\",\n  \"shrub-limiter\",\n  \"shrub-nodemailer\",\n  \"shrub-orm\",\n  \"shrub-passport\",\n  \"shrub-repl\",\n  \"shrub-rpc\",\n  \"shrub-skin\",\n  \"shrub-skin-strapped\",\n  \"shrub-session\",\n  \"shrub-socket\",\n  \"shrub-socket-socket.io\",\n  \"shrub-ui\",\n  \"shrub-user\",\n  \"shrub-user-local\",\n  \"shrub-user-reddit\",\n  \"shrub-villiany\",\n]  Here you may set values for packages which correspond with the values\nprovided by packages' implementations of hook shrubConfigServer .  packageConfig:  Use the package name as the settings key.    shrub-core:  It's not uncommon to run your node application behind a reverse proxy.\nBy default, we'll provide both ipv4 and embedded ipv6 addresses for\nlocalhost. If a reverse proxy is running on the same machine you will\ntherefore automatically see the correct IP address in  req.normalizedIp \nwhich is provided to HTTP, socket connection, and RPC endpoint requests.      trustedProxies: [\n      \"127.0.0.1\",\n      \"::ffff:127.0.0.1\",\n    ]",
            "title": "Default site configuration"
        },
        {
            "location": "/source/Gruntfile/",
            "text": "Gruntfile\n\n\nEntry point for the Grunt build process.\n\n\n{fork} = require \"#{__dirname}/server/bootstrap\"\n\nmodule.exports = (grunt) ->\n\n\n\n\nFork so we can bootstrap a Shrub environment.\n\n\n  if child = fork()\n    grunt.registerTask 'bootstrap', ->\n\n      done = @async()\n\n      child.on 'close', (code) ->\n\n        return done() if code is 0\n\n        grunt.fail.fatal 'Child process failed', code\n\n\n\n\nForward all tasks.\n\n\n    {tasks} = require 'grunt/lib/grunt/cli'\n    grunt.registerTask tasks[0] ? 'default', ['bootstrap']\n    grunt.registerTask(task, (->)) for task in tasks.slice 1\n\n    return\n\n  config = require 'config'\n  pkgman = require 'pkgman'\n\n\n\n\nLoad configuration.\n\n\n  config.load()\n  config.loadPackageSettings()\n\n\n\n\nGruntConfiguration\n\n\n  class GruntConfiguration\n\n\n\n\nconstructor\n\n\n    constructor: ->\n\n      @_npmTasks = []\n      @_taskConfig = {}\n      @_tasks = {}\n\n      @pkg = grunt.file.readJSON 'package.json'\n\n\n\n\nGruntConfiguration#configureTask\n\n\n\n\n\n\n(String) \ntask\n - The name of the task to configure.\n\n\n\n\n\n\n(String) \nkey\n - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.\n\n\n\n\n\n\n(Object) \nconfig_\n - The configuration to set. See the documentation\nfor the particular grunt task being configured to learn how to configure\nit.\n\n\n\n\n\n\nConfigure a Grunt task.\n\n\n    configureTask: (task, key, config_) ->\n\n      (@_taskConfig[task] ?= {})[key] = config_\n\n      return\n\n\n\n\nGruntConfiguration#taskConfiguration\n\n\n\n\n\n\n(String) \ntask\n - The name of the task to configure.\n\n\n\n\n\n\n(String) \nkey\n - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.\n\n\n\n\n\n\nGet the configuration for a Grunt task.\n\n\n    taskConfiguration: (task, key) -> @_taskConfig[task]?[key]\n\n\n\n\nGruntConfiguration#loadNpmTasks\n\n\n\n\n(String Array) \ntasks\n - The list of NPM tasks to load.\n\n\n\n\nLoad NPM tasks.\n\n\n    loadNpmTasks: (tasks) ->\n\n      @_npmTasks.push task for task in tasks\n\n      return\n\n\n\n\nGruntConfiguration#registerTask\n\n\n\n\n\n\n(String) \ntask\n - The name of the task to configure.\n\n\n\n\n\n\n(String Array or Function) \nsubtasksOrFunction\n - Either an array of\nstrings which define the dependencies for the task, or a function which\nwill be executed for the task.\n\n\n\n\n\n\nRegister a Grunt task.\n\n\n    registerTask: (task, subtasksOrFunction) ->\n\n      if 'function' is typeof subtasksOrFunction\n        @_tasks[task] = subtasksOrFunction\n      else\n        (@_tasks[task] ?= []).push subtasksOrFunction...\n\n      return\n\n\n\n\nGruntConfiguration#copyAppFiles\n\n\n\n\n\n\n(String) \npath\n - The path of the files to copy.\n\n\n\n\n\n\n(String) \nkey\n - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.\n\n\n\n\n\n\n(String) \ndest\n - The destination where the files will be copied.\nDefaults to \n'app'\n.\n\n\n\n\n\n\nCopy package files to \napp\n.\n\n\n    copyAppFiles: (path, key, dest = 'app') ->\n\n      dest ?= 'app'\n\n      gruntConfig.configureTask 'copy', key, files: [\n        src: '**/*'\n        dest: dest\n        expand: true\n        cwd: path\n      ]\n\n      gruntConfig.configureTask(\n        'watch', key\n\n        files: [\n          \"#{path}/**/*\"\n        ]\n        tasks: [\"build:#{key}\"]\n      )\n\n  gruntConfig = new GruntConfiguration()\n\n  gruntConfig.registerTask 'production', ['build']\n  gruntConfig.registerTask 'default', ['buildOnce']\n\n  built = false\n\n  gruntConfig.registerTask 'buildOnce', ->\n    return if built\n    built = true\n\n    grunt.task.run 'build'\n\n\n\n\nInvoke hook \nshrubGruntConfig\n\n\n  pkgman.invoke 'shrubGruntConfig', gruntConfig, grunt\n\n\n\n\nInvoke hook \nshrubGruntConfigAlter\n\n\n  pkgman.invoke 'shrubGruntConfigAlter', gruntConfig, grunt\n\n\n\n\nInitialize configuration.\n\n\n  grunt.initConfig gruntConfig._taskConfig\n\n\n\n\nLoad NPM tasks.\n\n\n  npmTasksLoaded = {}\n  for task in gruntConfig._npmTasks\n    continue if npmTasksLoaded[task]?\n    npmTasksLoaded[task] = true\n    grunt.loadNpmTasks task\n\n\n\n\nRegister custom tasks.\n\n\n  grunt.registerTask task, actions for task, actions of gruntConfig._tasks",
            "title": "Gruntfile.coffee"
        },
        {
            "location": "/source/Gruntfile/#gruntfile",
            "text": "Entry point for the Grunt build process.  {fork} = require \"#{__dirname}/server/bootstrap\"\n\nmodule.exports = (grunt) ->  Fork so we can bootstrap a Shrub environment.    if child = fork()\n    grunt.registerTask 'bootstrap', ->\n\n      done = @async()\n\n      child.on 'close', (code) ->\n\n        return done() if code is 0\n\n        grunt.fail.fatal 'Child process failed', code  Forward all tasks.      {tasks} = require 'grunt/lib/grunt/cli'\n    grunt.registerTask tasks[0] ? 'default', ['bootstrap']\n    grunt.registerTask(task, (->)) for task in tasks.slice 1\n\n    return\n\n  config = require 'config'\n  pkgman = require 'pkgman'  Load configuration.    config.load()\n  config.loadPackageSettings()",
            "title": "Gruntfile"
        },
        {
            "location": "/source/Gruntfile/#gruntconfiguration",
            "text": "class GruntConfiguration",
            "title": "GruntConfiguration"
        },
        {
            "location": "/source/Gruntfile/#constructor",
            "text": "constructor: ->\n\n      @_npmTasks = []\n      @_taskConfig = {}\n      @_tasks = {}\n\n      @pkg = grunt.file.readJSON 'package.json'",
            "title": "constructor"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationconfiguretask",
            "text": "(String)  task  - The name of the task to configure.    (String)  key  - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.    (Object)  config_  - The configuration to set. See the documentation\nfor the particular grunt task being configured to learn how to configure\nit.    Configure a Grunt task.      configureTask: (task, key, config_) ->\n\n      (@_taskConfig[task] ?= {})[key] = config_\n\n      return",
            "title": "GruntConfiguration#configureTask"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationtaskconfiguration",
            "text": "(String)  task  - The name of the task to configure.    (String)  key  - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.    Get the configuration for a Grunt task.      taskConfiguration: (task, key) -> @_taskConfig[task]?[key]",
            "title": "GruntConfiguration#taskConfiguration"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationloadnpmtasks",
            "text": "(String Array)  tasks  - The list of NPM tasks to load.   Load NPM tasks.      loadNpmTasks: (tasks) ->\n\n      @_npmTasks.push task for task in tasks\n\n      return",
            "title": "GruntConfiguration#loadNpmTasks"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationregistertask",
            "text": "(String)  task  - The name of the task to configure.    (String Array or Function)  subtasksOrFunction  - Either an array of\nstrings which define the dependencies for the task, or a function which\nwill be executed for the task.    Register a Grunt task.      registerTask: (task, subtasksOrFunction) ->\n\n      if 'function' is typeof subtasksOrFunction\n        @_tasks[task] = subtasksOrFunction\n      else\n        (@_tasks[task] ?= []).push subtasksOrFunction...\n\n      return",
            "title": "GruntConfiguration#registerTask"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationcopyappfiles",
            "text": "(String)  path  - The path of the files to copy.    (String)  key  - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.    (String)  dest  - The destination where the files will be copied.\nDefaults to  'app' .    Copy package files to  app .      copyAppFiles: (path, key, dest = 'app') ->\n\n      dest ?= 'app'\n\n      gruntConfig.configureTask 'copy', key, files: [\n        src: '**/*'\n        dest: dest\n        expand: true\n        cwd: path\n      ]\n\n      gruntConfig.configureTask(\n        'watch', key\n\n        files: [\n          \"#{path}/**/*\"\n        ]\n        tasks: [\"build:#{key}\"]\n      )\n\n  gruntConfig = new GruntConfiguration()\n\n  gruntConfig.registerTask 'production', ['build']\n  gruntConfig.registerTask 'default', ['buildOnce']\n\n  built = false\n\n  gruntConfig.registerTask 'buildOnce', ->\n    return if built\n    built = true\n\n    grunt.task.run 'build'  Invoke hook  shrubGruntConfig    pkgman.invoke 'shrubGruntConfig', gruntConfig, grunt  Invoke hook  shrubGruntConfigAlter    pkgman.invoke 'shrubGruntConfigAlter', gruntConfig, grunt  Initialize configuration.    grunt.initConfig gruntConfig._taskConfig  Load NPM tasks.    npmTasksLoaded = {}\n  for task in gruntConfig._npmTasks\n    continue if npmTasksLoaded[task]?\n    npmTasksLoaded[task] = true\n    grunt.loadNpmTasks task  Register custom tasks.    grunt.registerTask task, actions for task, actions of gruntConfig._tasks",
            "title": "GruntConfiguration#copyAppFiles"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/client/",
            "text": "Angular sandbox\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularAppRun\n\n\nHang up any sandbox if we don't need it anymore.\n\n\n  registrar.registerHook 'shrubAngularAppRun', -> [\n    '$window', 'shrub-rpc'\n    ($window, rpc) ->\n\n\n\n\nHang up the socket unless it's the local (Node.js) client.\n\n\n      unless $window.navigator.userAgent.match /^Node\\.js .*$/\n        rpc.call 'shrub-angular-sandbox/hangup'\n\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/client/#angular-sandbox",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularAppRun  Hang up any sandbox if we don't need it anymore.    registrar.registerHook 'shrubAngularAppRun', -> [\n    '$window', 'shrub-rpc'\n    ($window, rpc) ->  Hang up the socket unless it's the local (Node.js) client.        unless $window.navigator.userAgent.match /^Node\\.js .*$/\n        rpc.call 'shrub-angular-sandbox/hangup'\n\n  ]",
            "title": "Angular sandbox"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/",
            "text": "Angular sandbox\n\n\nA sandboxed version of Angular, for clients lacking JS.\n\n\nTODO: Sandbox pool, might be better handled by \nsandboxes\n.\n\n\n_ = require 'lodash'\nPromise = require 'bluebird'\nurl = require 'url'\n\nconfig = require 'config'\ndebug = require('debug') 'shrub:angular'\nmiddleware = require 'middleware'\n{Sandbox} = require 'sandboxes'\n\n\n\n\nThe middleware dispatched every time sandboxed angular is navigated.\n\n\nnavigationMiddleware = []\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubRpcRoutes\n\n\nAllow a JSful client to call us back and inform us that we don't need to\nhold their sandbox.\n\n\n  registrar.registerHook 'shrubRpcRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-angular-sandbox/hangup'\n      middleware: [\n\n        'shrub-http-express/session'\n\n        (req, res, next) ->\n\n\n\n\nTODO: Cookie-less clients won't have a valid session ID to call with. This should be some other token, perhaps CSRF.\n\n\n          id = req.session?.id\n          if (sandbox = sandboxManager.lookup id)?\n            sandbox.close().finally -> res.end()\n          else\n            res.end()\n\n      ]\n\n    return routes\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\nIf configuration dictates, render the client-side Angular application in a\nsandbox.\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Render page with Angular'\n    middleware: [\n\n      (req, res, next) ->\n\n\n\n\nSkip render in a sandbox?\n\n\n        settings = config.get 'packageConfig:shrub-angular'\n        return next() unless settings.render\n\n\n\n\nThrown when a request is complete.\n\n\n        class ResponseComplete extends Error\n          constructor: (@message) ->\n\n\n\n\nAfter the template is rendered, lookup or create the sandbox.\n\n\n        Promise.resolve(req.delivery).bind({}).then((html) ->\n\n          sandboxManager.lookupOrCreate(\n            html\n          ,\n            cookie: req.headers.cookie\n\n            url: \"http://localhost:#{\n              config.get 'packageConfig:shrub-http:port'\n            }/shrub-angular-entry-point\"\n          ,\n            req.session.id\n          )\n\n        ).then((@sandbox) ->\n\n\n\n\nEmit the HTML from before the last redirection.\n\n\n          if (redirectionHtml = @sandbox.redirectionHtml())?\n            @sandbox.setRedirectionHtml null\n            res.end redirectionHtml\n            throw new ResponseComplete()\n\n\n\n\nCheck for any new redirection and handle it.\n\n\n          if (redirectionPath = @sandbox.redirectionPath())?\n            @sandbox.setRedirectionPath null\n            res.redirect redirectionPath\n            throw new ResponseComplete()\n\n          @sandbox.navigate req\n\n        ).then(->\n\n          emission = @sandbox.emitHtml()\n\n\n\n\nIf a redirect happened in the sandbox, actually redirect the\nbrowser and save the emission for the next request.\n\n\n          if (redirectionPath = @sandbox.redirectionPath())?\n            @sandbox.setRedirectionPath null\n            @sandbox.setRedirectionHtml emission\n            res.redirect redirectionPath\n\n\n\n\nOtherwise, just emit.\n\n\n          else\n\n            req.delivery = emission\n            next()\n\n\n\n\nThe request was completed early.\n\n\n        ).catch(ResponseComplete, ->\n\n        ).catch next\n\n  ]\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    label: 'Bootstrap Angular'\n    middleware: [\n\n      (next) ->\n\n\n\n\nAlways disable sandbox rendering in end-to-end testing mode.\n\n\n        if config.get 'E2E'\n          config.set 'packageConfig:shrub-angular:render', false\n\n\n\n\nInvoke hook \nshrubAngularSandboxNavigationMiddleware\n\n\nLoad the navigation middleware.\n\n\n        navigationMiddleware = middleware.fromConfig(\n          'shrub-angular-sandbox:navigationMiddleware'\n        )\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n\n\n\nDefault navigation middleware.\n\n\n    navigationMiddleware: [\n      'shrub-form'\n    ]\n\n\n\n\nShould we render in the sandbox?\n\n\n    render: true\n\n\n\n\nTime-to-live for rendering sandboxes.\n\n\n    ttl: 1000 * 60 * 5\n\n\n\n\nThis class handles instantiation of new sandboxes, as well as providing a\nmechanism for registering and looking up persistent sandboxes using an id.\n\n\nsandboxManager = new class SandboxManager\n\n\n\n\nconstructor\n\n\nInitialize the persistent store.\n\n\n  constructor: ->\n\n    @_sandboxes = {}\n\n\n\n\nSandboxManager#create\n\n\n\n\n\n\n(string) \nhtml\n - The HTML to use as the sandbox document.\n\n\n\n\n\n\n(string) \ncookie\n - The cookie to use for the document.\n\n\n\n\n\n\n(optional string) \nid\n - An ID for looking up this sandbox later.\n\n\n\n\n\n\nCreate a sandbox.\n\n\n  create: (html, options, id = null) ->\n\n    debug \"Creating sandbox ID: #{id}\"\n\n    sandbox = new Sandbox()\n    sandbox.id = id\n\n\n\n\nSandbox#close (monkeypatch)\n\n\nRemove from the manager when closing.\n\n\n    close = sandbox.close\n    sandbox.close = =>\n      debug \"Closing sandbox ID: #{id}\"\n\n      @_sandboxes[id] = null\n      close.apply sandbox\n\n\n\n\nCreate the document.\n\n\n    (@_sandboxes[id] = sandbox).createDocument html, options\n\n\n\n\nSandboxManager#lookup\n\n\n\n\n(string) \nid\n - An ID for looking up this sandbox later.\n\n\n\n\nLook up a sandbox by ID.\n\n\n  lookup: (id) -> @_sandboxes[id]?.touch()\n\n\n\n\nSandboxManager#lookupOrCreate\n\n\n\n\n\n\n(string) \nhtml\n - The HTML to use as the sandbox document if creating.\n\n\n\n\n\n\n(string) \ncookie\n - The cookie to use for the document if creating.\n\n\n\n\n\n\n(optional string) \nid\n - An ID either for looking up later (if\ncreating), or as a search now.\n\n\n\n\n\n\nLook up a sandbox by ID, or create one if none is registered for this\nID.\n\n\n  lookupOrCreate: (html, options, id = null) ->\n\n    if (sandbox = @lookup id)?\n\n      Promise.resolve sandbox\n\n    else\n\n      @create(html, options, id).then (sandbox) -> augmentSandbox sandbox\n\n\n\n\nAugment a sandbox with Angular-specific functionality.\n\n\naugmentSandbox = (sandbox) ->\n\n\n\n\nSandbox#touch\n\n\nReset the time-to-live for a sandbox.\n\n\n  ttl = config.get 'packageConfig:shrub-angular:ttl'\n  toucher = _.debounce (-> sandbox.close()), ttl\n  do sandbox.touch = ->\n    debug \"Touched sandbox ID: #{id}\"\n\n    toucher()\n    sandbox\n\n\n\n\nSandbox#(setR|r)edirectionHtml\n\n\n\n\n(string) \nhtml\n - The HTML to be deliviered.\n\n\n\n\nHTML to be delivered upon the next request using this sandbox.\n\n\n  redirectionHtml = null\n  sandbox.redirectionHtml = -> redirectionHtml\n  sandbox.setRedirectionHtml = (html) -> redirectionHtml = html\n\n\n\n\nSandbox#(setR|r)edirectionPath\n\n\n\n\n(string) \npath\n - The URL path to redirect to.\n\n\n\n\nThe path that the client will be redirected to at the end of this\nrequest.\n\n\n  redirectionPath = null\n  sandbox.redirectionPath = -> redirectionPath\n  sandbox.setRedirectionPath = (path) -> redirectionPath = path\n\n\n\n\nSandbox#catchAngularRedirection\n\n\n\n\n(string) \npath\n - URL path.\n\n\n\n\nCheck whether Angular was redirected, and set the client redirection path\nif it was.\n\n\n  sandbox.catchAngularRedirection = (path) ->\n    self = this\n\n    @inject [\n      '$location'\n      ($location) ->\n\n        return if path is $location.url()\n\n        if redirect = self.pathRedirectsTo $location.url()\n          self.setRedirectionPath redirect\n        else\n          self.setRedirectionPath $location.url()\n\n    ]\n\n\n\n\nSandbox#checkPathChanges\n\n\n\n\n(string) \npath\n - URL path.\n\n\n\n\nCheck whether the navigation path is different than the current Angular\nlocation path. If it is, redirect Angular.\n\n\n  sandbox.checkPathChanges = (path) ->\n    self = this\n\n    new Promise (resolve) ->\n\n      self.inject [\n        '$location', '$rootScope'\n        ($location, $rootScope) ->\n\n\n\n\n} Nowhere to go?\n\n\n          return resolve() if path is url.parse(self.url()).path\n\n\n\n\n} Navigate Angular to the request path.\n\n\n          unlisten = $rootScope.$on 'shrub.core.routeRendered', ->\n            unlisten()\n            resolve()\n\n          $rootScope.$apply -> $location.path path\n\n      ]\n\n\n\n\nSandbox#navigate\n\n\n\n\n(http.IncomingMessage) \nreq\n - The HTTP request object.\n\n\n\n\nNavigate angular to a path, and dispatch navigation middleware.\n\n\n  sandbox.navigate = (req) ->\n    self = this\n\n    {path} = url.parse req.url\n\n    @checkPathChanges(path).then ->\n\n      new Promise (resolve, reject) ->\n\n        navigationReq = Object.create req\n        navigationReq.sandbox = sandbox\n\n        navigationMiddleware.dispatch navigationReq, (error) =>\n          return reject error if error?\n\n          self.catchAngularRedirection path\n          resolve()\n\n\n\n\nSandbox#pathRedirectsTo\n\n\n\n\n(string) \npath\n - URL path.\n\n\n\n\nCheck where a path would be redirected by Angular's router.\n\n\n  sandbox.pathRedirectsTo = (path) ->\n\n    routes = null\n\n    @inject [\n      '$route'\n      ($route) -> routes = $route.routes\n    ]\n\n\n\n\nPerfect match.\n\n\n    if routes[path]?\n\n\n\n\nDoes this path redirect? Do an HTTP redirect.\n\n\n      return routes[path].redirectTo if routes[path].redirectTo?\n\n    else\n\n      match = false\n\n\n\n\nCheck for any regexs.\n\n\n      for key, route of routes\n        if route.regexp?.test path\n\n\n\n\nTODO: Need to extract params to build redirectTo, it's a small enough mismatch to ignore for now.\n\n\n          return\n\n\n\n\nAngular's $routeProvider.otherwise() target.\n\n\n      return routes[null].redirectTo if routes[null]?\n\n\n\n\nSandbox#inject\n\n\n\n\n(mixed) \ninjectable\n - An annotated function to inject with dependencies.\n\n\n\n\nInject an \nannotated\nfunction\n with\ndependencies.\n\n\n  sandbox.inject = (injectable) ->\n\n    injector = @_window.angular.element(@_window.document).injector()\n    injector.invoke injectable\n\n\n\n\nMake sure the socket is dead.\n\n\n  sandbox.registerCleanupFunction ->\n\n    new Promise (resolve) ->\n\n      sandbox.inject [\n        'shrub-socket'\n        (socket) ->\n\n          socket.on 'disconnect', -> resolve()\n          socket.disconnect()\n\n      ]\n\n  new Promise (resolve) ->\n\n    sandbox.inject [\n      '$sniffer', 'shrub-socket'\n      ($sniffer, socket) ->\n\n\n\n\nDon't even try HTML 5 history on the server side.\n\n\n        $sniffer.history = false\n\n\n\n\nLet the socket finish initialization.\n\n\n        socket.on 'initialized', -> resolve sandbox\n\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#angular-sandbox",
            "text": "A sandboxed version of Angular, for clients lacking JS.  TODO: Sandbox pool, might be better handled by  sandboxes .  _ = require 'lodash'\nPromise = require 'bluebird'\nurl = require 'url'\n\nconfig = require 'config'\ndebug = require('debug') 'shrub:angular'\nmiddleware = require 'middleware'\n{Sandbox} = require 'sandboxes'  The middleware dispatched every time sandboxed angular is navigated.  navigationMiddleware = []\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubRpcRoutes  Allow a JSful client to call us back and inform us that we don't need to\nhold their sandbox.    registrar.registerHook 'shrubRpcRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-angular-sandbox/hangup'\n      middleware: [\n\n        'shrub-http-express/session'\n\n        (req, res, next) ->  TODO: Cookie-less clients won't have a valid session ID to call with. This should be some other token, perhaps CSRF.            id = req.session?.id\n          if (sandbox = sandboxManager.lookup id)?\n            sandbox.close().finally -> res.end()\n          else\n            res.end()\n\n      ]\n\n    return routes  Implements hook  shrubHttpMiddleware  If configuration dictates, render the client-side Angular application in a\nsandbox.    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Render page with Angular'\n    middleware: [\n\n      (req, res, next) ->  Skip render in a sandbox?          settings = config.get 'packageConfig:shrub-angular'\n        return next() unless settings.render  Thrown when a request is complete.          class ResponseComplete extends Error\n          constructor: (@message) ->  After the template is rendered, lookup or create the sandbox.          Promise.resolve(req.delivery).bind({}).then((html) ->\n\n          sandboxManager.lookupOrCreate(\n            html\n          ,\n            cookie: req.headers.cookie\n\n            url: \"http://localhost:#{\n              config.get 'packageConfig:shrub-http:port'\n            }/shrub-angular-entry-point\"\n          ,\n            req.session.id\n          )\n\n        ).then((@sandbox) ->  Emit the HTML from before the last redirection.            if (redirectionHtml = @sandbox.redirectionHtml())?\n            @sandbox.setRedirectionHtml null\n            res.end redirectionHtml\n            throw new ResponseComplete()  Check for any new redirection and handle it.            if (redirectionPath = @sandbox.redirectionPath())?\n            @sandbox.setRedirectionPath null\n            res.redirect redirectionPath\n            throw new ResponseComplete()\n\n          @sandbox.navigate req\n\n        ).then(->\n\n          emission = @sandbox.emitHtml()  If a redirect happened in the sandbox, actually redirect the\nbrowser and save the emission for the next request.            if (redirectionPath = @sandbox.redirectionPath())?\n            @sandbox.setRedirectionPath null\n            @sandbox.setRedirectionHtml emission\n            res.redirect redirectionPath  Otherwise, just emit.            else\n\n            req.delivery = emission\n            next()  The request was completed early.          ).catch(ResponseComplete, ->\n\n        ).catch next\n\n  ]  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    label: 'Bootstrap Angular'\n    middleware: [\n\n      (next) ->  Always disable sandbox rendering in end-to-end testing mode.          if config.get 'E2E'\n          config.set 'packageConfig:shrub-angular:render', false  Invoke hook  shrubAngularSandboxNavigationMiddleware  Load the navigation middleware.          navigationMiddleware = middleware.fromConfig(\n          'shrub-angular-sandbox:navigationMiddleware'\n        )\n\n        next()\n\n    ]  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->  Default navigation middleware.      navigationMiddleware: [\n      'shrub-form'\n    ]  Should we render in the sandbox?      render: true  Time-to-live for rendering sandboxes.      ttl: 1000 * 60 * 5  This class handles instantiation of new sandboxes, as well as providing a\nmechanism for registering and looking up persistent sandboxes using an id.  sandboxManager = new class SandboxManager",
            "title": "Angular sandbox"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#constructor",
            "text": "Initialize the persistent store.    constructor: ->\n\n    @_sandboxes = {}",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxmanagercreate",
            "text": "(string)  html  - The HTML to use as the sandbox document.    (string)  cookie  - The cookie to use for the document.    (optional string)  id  - An ID for looking up this sandbox later.    Create a sandbox.    create: (html, options, id = null) ->\n\n    debug \"Creating sandbox ID: #{id}\"\n\n    sandbox = new Sandbox()\n    sandbox.id = id",
            "title": "SandboxManager#create"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxclose-monkeypatch",
            "text": "Remove from the manager when closing.      close = sandbox.close\n    sandbox.close = =>\n      debug \"Closing sandbox ID: #{id}\"\n\n      @_sandboxes[id] = null\n      close.apply sandbox  Create the document.      (@_sandboxes[id] = sandbox).createDocument html, options",
            "title": "Sandbox#close (monkeypatch)"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxmanagerlookup",
            "text": "(string)  id  - An ID for looking up this sandbox later.   Look up a sandbox by ID.    lookup: (id) -> @_sandboxes[id]?.touch()",
            "title": "SandboxManager#lookup"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxmanagerlookuporcreate",
            "text": "(string)  html  - The HTML to use as the sandbox document if creating.    (string)  cookie  - The cookie to use for the document if creating.    (optional string)  id  - An ID either for looking up later (if\ncreating), or as a search now.    Look up a sandbox by ID, or create one if none is registered for this\nID.    lookupOrCreate: (html, options, id = null) ->\n\n    if (sandbox = @lookup id)?\n\n      Promise.resolve sandbox\n\n    else\n\n      @create(html, options, id).then (sandbox) -> augmentSandbox sandbox  Augment a sandbox with Angular-specific functionality.  augmentSandbox = (sandbox) ->",
            "title": "SandboxManager#lookupOrCreate"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxtouch",
            "text": "Reset the time-to-live for a sandbox.    ttl = config.get 'packageConfig:shrub-angular:ttl'\n  toucher = _.debounce (-> sandbox.close()), ttl\n  do sandbox.touch = ->\n    debug \"Touched sandbox ID: #{id}\"\n\n    toucher()\n    sandbox",
            "title": "Sandbox#touch"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxsetrredirectionhtml",
            "text": "(string)  html  - The HTML to be deliviered.   HTML to be delivered upon the next request using this sandbox.    redirectionHtml = null\n  sandbox.redirectionHtml = -> redirectionHtml\n  sandbox.setRedirectionHtml = (html) -> redirectionHtml = html",
            "title": "Sandbox#(setR|r)edirectionHtml"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxsetrredirectionpath",
            "text": "(string)  path  - The URL path to redirect to.   The path that the client will be redirected to at the end of this\nrequest.    redirectionPath = null\n  sandbox.redirectionPath = -> redirectionPath\n  sandbox.setRedirectionPath = (path) -> redirectionPath = path",
            "title": "Sandbox#(setR|r)edirectionPath"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxcatchangularredirection",
            "text": "(string)  path  - URL path.   Check whether Angular was redirected, and set the client redirection path\nif it was.    sandbox.catchAngularRedirection = (path) ->\n    self = this\n\n    @inject [\n      '$location'\n      ($location) ->\n\n        return if path is $location.url()\n\n        if redirect = self.pathRedirectsTo $location.url()\n          self.setRedirectionPath redirect\n        else\n          self.setRedirectionPath $location.url()\n\n    ]",
            "title": "Sandbox#catchAngularRedirection"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxcheckpathchanges",
            "text": "(string)  path  - URL path.   Check whether the navigation path is different than the current Angular\nlocation path. If it is, redirect Angular.    sandbox.checkPathChanges = (path) ->\n    self = this\n\n    new Promise (resolve) ->\n\n      self.inject [\n        '$location', '$rootScope'\n        ($location, $rootScope) ->  } Nowhere to go?            return resolve() if path is url.parse(self.url()).path  } Navigate Angular to the request path.            unlisten = $rootScope.$on 'shrub.core.routeRendered', ->\n            unlisten()\n            resolve()\n\n          $rootScope.$apply -> $location.path path\n\n      ]",
            "title": "Sandbox#checkPathChanges"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxnavigate",
            "text": "(http.IncomingMessage)  req  - The HTTP request object.   Navigate angular to a path, and dispatch navigation middleware.    sandbox.navigate = (req) ->\n    self = this\n\n    {path} = url.parse req.url\n\n    @checkPathChanges(path).then ->\n\n      new Promise (resolve, reject) ->\n\n        navigationReq = Object.create req\n        navigationReq.sandbox = sandbox\n\n        navigationMiddleware.dispatch navigationReq, (error) =>\n          return reject error if error?\n\n          self.catchAngularRedirection path\n          resolve()",
            "title": "Sandbox#navigate"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxpathredirectsto",
            "text": "(string)  path  - URL path.   Check where a path would be redirected by Angular's router.    sandbox.pathRedirectsTo = (path) ->\n\n    routes = null\n\n    @inject [\n      '$route'\n      ($route) -> routes = $route.routes\n    ]  Perfect match.      if routes[path]?  Does this path redirect? Do an HTTP redirect.        return routes[path].redirectTo if routes[path].redirectTo?\n\n    else\n\n      match = false  Check for any regexs.        for key, route of routes\n        if route.regexp?.test path  TODO: Need to extract params to build redirectTo, it's a small enough mismatch to ignore for now.            return  Angular's $routeProvider.otherwise() target.        return routes[null].redirectTo if routes[null]?",
            "title": "Sandbox#pathRedirectsTo"
        },
        {
            "location": "/source/packages/shrub-angular-sandbox/#sandboxinject",
            "text": "(mixed)  injectable  - An annotated function to inject with dependencies.   Inject an  annotated\nfunction  with\ndependencies.    sandbox.inject = (injectable) ->\n\n    injector = @_window.angular.element(@_window.document).injector()\n    injector.invoke injectable  Make sure the socket is dead.    sandbox.registerCleanupFunction ->\n\n    new Promise (resolve) ->\n\n      sandbox.inject [\n        'shrub-socket'\n        (socket) ->\n\n          socket.on 'disconnect', -> resolve()\n          socket.disconnect()\n\n      ]\n\n  new Promise (resolve) ->\n\n    sandbox.inject [\n      '$sniffer', 'shrub-socket'\n      ($sniffer, socket) ->  Don't even try HTML 5 history on the server side.          $sniffer.history = false  Let the socket finish initialization.          socket.on 'initialized', -> resolve sandbox\n\n    ]",
            "title": "Sandbox#inject"
        },
        {
            "location": "/source/packages/shrub-angular/client/",
            "text": "Angular\n\n\nCoordinate various core functionality.\n\n\n_ = require 'lodash'\nPromise = require 'bluebird'\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularAHrefSanitizationWhitelist\n\n\n  registrar.registerHook 'shrubAngularAHrefSanitizationWhitelist', -> [\n\n\n\n\nAllow more protocols.\n\n\n    '(?:https?|ftp|mailto|tel|file):'\n\n\n\n\nAllow javascript:void(0).\n\n\n    'javascript:void\\\\(0\\\\)'\n  ]\n\n\n\n\nImplements hook \nshrubAngularAppConfig\n\n\n  registrar.registerHook 'shrubAngularAppConfig', -> [\n    '$compileProvider', '$injector', '$provide', '$routeProvider', '$locationProvider', 'shrub-pkgmanProvider'\n    ($compileProvider, $injector, $provide, $routeProvider, $locationProvider, pkgmanProvider) ->\n\n\n\n\nInvoke hook \nshrubAngularAHrefSanitizationWhitelist\n\n\n      regexes = []\n      for regexes_ in pkgmanProvider.invokeFlat(\n        'shrubAngularAHrefSanitizationWhitelist'\n      )\n        regexes.push regex for regex in regexes_\n\n      $compileProvider.aHrefSanitizationWhitelist new RegExp(\n        \"^\\s*(?:#{regexes.join '|'})\"\n      )\n\n\n\n\nAttach debug info if we're in test mode.\n\n\n      unless config.get 'packageConfig:shrub-core:testMode'\n        $compileProvider.debugInfoEnabled false\n\n\n\n\nCompletely override the $q service with Bluebird, because it's\nawesome.\n\n\nTODO: Angular also implements a private service called $$q used for animation. We should override that one, too.\n\n\n      $provide.decorator '$q', [\n        '$rootScope', '$exceptionHandler'\n        ($rootScope, $exceptionHandler) ->\n\n          Promise.onPossiblyUnhandledRejection (error) ->\n\n\n\n\n$timeout and $interval will throw this for cancellation. It's\nnon-notable.\n\n\n            return if 'canceled' is error.message\n\n            $exceptionHandler error\n\n\n\n\nHook Bluebird's schedule up to Angular.\n\n\n          Promise.setScheduler (fn) -> $rootScope.$evalAsync fn\n\n\n\n\nPromise.defer\n\n\nSee: https://docs.angularjs.org/api/ng/service/$q#the-deferred-api\n\n\n          Promise.defer = ->\n            resolve = null\n            reject = null\n\n\n\n\nCreate a promise.\n\n\n            promise = new Promise ->\n              resolve = arguments[0]\n\n\n\n\nAngular is a scrub, and will reject promises with strings\ninstead of fully-fledged Error instances. Hold its hand.\n\n\n              reject_ = arguments[1]\n              reject = (error) ->\n                error = new Error error if _.isString error\n                reject_ error\n\n              return\n\n\n\n\nAngular depends on notify, which is a crap API. We'll hack\nsupport for it in.\n\n\n            __notifications = []\n            proxyThen = promise.then\n            promise.then = ->\n              args = (arg for arg in arguments)\n              __notifications.push args[2] if args[2]?\n              proxyThen.apply promise, args\n            notify: (args...) -> fn args... for fn in __notifications\n\n\n\n\nReturn the deferred object.\n\n\n            promise: promise\n            resolve: resolve\n            reject: reject\n\n\n\n\nPromise.when\n\n\nSee: https://docs.angularjs.org/api/ng/service/$q#when\n\n\n          Promise.when = (value, handlers...) ->\n            Promise.cast(value).then handlers...\n\n\n\n\nProxy Promise.all because Angular supports passing in an object\nwhere the values are promises, and the result is an object keyed\nwith the resolved values from the promise.\n\n\n          originalAll = Promise.all\n          Promise.all = (promises) ->\n\n\n\n\nDefer to Bluebird if it's an array.\n\n\n            return originalAll promises if angular.isArray promises\n\n\n\n\nIf it's not an object, defer to Bluebird (it'll throw).\n\n\n            return originalAll promises unless angular.isObject promises\n\n\n\n\nTrack the keys so we can map the values.\n\n\n            promiseKeys = []\n            promiseArray = for key, promise of promises\n              promiseKeys.push key\n              promise\n\n            originalAll(promiseArray).then (results) ->\n              objectResult = {}\n\n              for result, index in results\n                objectResult[promiseKeys[index]] = result\n\n              objectResult\n\n\n\n\nReturn the service.\n\n\n          Promise\n\n      ]\n\n\n\n\nInvoke hook \nshrubAngularRoutes\n\n\nAllow packages to define routes in the Angular application.\n\n\n      routes = {}\n      for route in _.flatten pkgmanProvider.invokeFlat 'shrubAngularRoutes'\n        routes[route.path ? path] = route\n\n\n\n\nInvoke hook \nshrubAngularRoutesAlter\n. Allow packages to alter defined\nroutes.\n\n\n      $injector.invoke(\n        injectable, null\n        routes: routes\n      ) for injectable in pkgmanProvider.invokeFlat 'shrubAngularRoutesAlter'\n\n      for path, route of routes\n        do (path, route) ->\n\n\n\n\nWrap the controller so we can provide some automatic behavior.\n\n\n          routeController = route.controller\n          route.controller = [\n            '$controller', '$injector', '$q', '$scope'\n            ($controller, $injector, $q, $scope) ->\n\n\n\n\nImmediately resolve if there's no controller.\n\n\n              unless routeController?\n                return $scope.$emit 'shrub.core.routeRendered'\n\n\n\n\nControllers may return a promise, so wait until any returned\nvalue fulfills. If it's not a promise, this will be in the\nnext tick.\n\n\n              $q.when($injector.invoke(\n                routeController, null\n                $scope: $scope\n                route: route\n              )).then(-> $scope.$emit 'shrub.core.routeRendered').done()\n\n          ]\n\n\n\n\nEnsure a template exists to make Angular happy.\n\n\n          route.template ?= ' '\n\n\n\n\nRegister the path into Angular.\n\n\n          $routeProvider.when \"/#{route.path ? path}\", route\n\n\n\n\nCreate a unique entry point.\n\n\n      $routeProvider.when '/shrub-angular-entry-point', {}\n\n\n\n\nTurn on HTML5 mode: \"Real\" URLs.\n\n\n      $locationProvider.html5Mode true\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-angular/client/#angular",
            "text": "Coordinate various core functionality.  _ = require 'lodash'\nPromise = require 'bluebird'\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularAHrefSanitizationWhitelist    registrar.registerHook 'shrubAngularAHrefSanitizationWhitelist', -> [  Allow more protocols.      '(?:https?|ftp|mailto|tel|file):'  Allow javascript:void(0).      'javascript:void\\\\(0\\\\)'\n  ]  Implements hook  shrubAngularAppConfig    registrar.registerHook 'shrubAngularAppConfig', -> [\n    '$compileProvider', '$injector', '$provide', '$routeProvider', '$locationProvider', 'shrub-pkgmanProvider'\n    ($compileProvider, $injector, $provide, $routeProvider, $locationProvider, pkgmanProvider) ->  Invoke hook  shrubAngularAHrefSanitizationWhitelist        regexes = []\n      for regexes_ in pkgmanProvider.invokeFlat(\n        'shrubAngularAHrefSanitizationWhitelist'\n      )\n        regexes.push regex for regex in regexes_\n\n      $compileProvider.aHrefSanitizationWhitelist new RegExp(\n        \"^\\s*(?:#{regexes.join '|'})\"\n      )  Attach debug info if we're in test mode.        unless config.get 'packageConfig:shrub-core:testMode'\n        $compileProvider.debugInfoEnabled false  Completely override the $q service with Bluebird, because it's\nawesome.  TODO: Angular also implements a private service called $$q used for animation. We should override that one, too.        $provide.decorator '$q', [\n        '$rootScope', '$exceptionHandler'\n        ($rootScope, $exceptionHandler) ->\n\n          Promise.onPossiblyUnhandledRejection (error) ->  $timeout and $interval will throw this for cancellation. It's\nnon-notable.              return if 'canceled' is error.message\n\n            $exceptionHandler error  Hook Bluebird's schedule up to Angular.            Promise.setScheduler (fn) -> $rootScope.$evalAsync fn",
            "title": "Angular"
        },
        {
            "location": "/source/packages/shrub-angular/client/#promisedefer",
            "text": "See: https://docs.angularjs.org/api/ng/service/$q#the-deferred-api            Promise.defer = ->\n            resolve = null\n            reject = null  Create a promise.              promise = new Promise ->\n              resolve = arguments[0]  Angular is a scrub, and will reject promises with strings\ninstead of fully-fledged Error instances. Hold its hand.                reject_ = arguments[1]\n              reject = (error) ->\n                error = new Error error if _.isString error\n                reject_ error\n\n              return  Angular depends on notify, which is a crap API. We'll hack\nsupport for it in.              __notifications = []\n            proxyThen = promise.then\n            promise.then = ->\n              args = (arg for arg in arguments)\n              __notifications.push args[2] if args[2]?\n              proxyThen.apply promise, args\n            notify: (args...) -> fn args... for fn in __notifications  Return the deferred object.              promise: promise\n            resolve: resolve\n            reject: reject",
            "title": "Promise.defer"
        },
        {
            "location": "/source/packages/shrub-angular/client/#promisewhen",
            "text": "See: https://docs.angularjs.org/api/ng/service/$q#when            Promise.when = (value, handlers...) ->\n            Promise.cast(value).then handlers...  Proxy Promise.all because Angular supports passing in an object\nwhere the values are promises, and the result is an object keyed\nwith the resolved values from the promise.            originalAll = Promise.all\n          Promise.all = (promises) ->  Defer to Bluebird if it's an array.              return originalAll promises if angular.isArray promises  If it's not an object, defer to Bluebird (it'll throw).              return originalAll promises unless angular.isObject promises  Track the keys so we can map the values.              promiseKeys = []\n            promiseArray = for key, promise of promises\n              promiseKeys.push key\n              promise\n\n            originalAll(promiseArray).then (results) ->\n              objectResult = {}\n\n              for result, index in results\n                objectResult[promiseKeys[index]] = result\n\n              objectResult  Return the service.            Promise\n\n      ]  Invoke hook  shrubAngularRoutes  Allow packages to define routes in the Angular application.        routes = {}\n      for route in _.flatten pkgmanProvider.invokeFlat 'shrubAngularRoutes'\n        routes[route.path ? path] = route  Invoke hook  shrubAngularRoutesAlter . Allow packages to alter defined\nroutes.        $injector.invoke(\n        injectable, null\n        routes: routes\n      ) for injectable in pkgmanProvider.invokeFlat 'shrubAngularRoutesAlter'\n\n      for path, route of routes\n        do (path, route) ->  Wrap the controller so we can provide some automatic behavior.            routeController = route.controller\n          route.controller = [\n            '$controller', '$injector', '$q', '$scope'\n            ($controller, $injector, $q, $scope) ->  Immediately resolve if there's no controller.                unless routeController?\n                return $scope.$emit 'shrub.core.routeRendered'  Controllers may return a promise, so wait until any returned\nvalue fulfills. If it's not a promise, this will be in the\nnext tick.                $q.when($injector.invoke(\n                routeController, null\n                $scope: $scope\n                route: route\n              )).then(-> $scope.$emit 'shrub.core.routeRendered').done()\n\n          ]  Ensure a template exists to make Angular happy.            route.template ?= ' '  Register the path into Angular.            $routeProvider.when \"/#{route.path ? path}\", route  Create a unique entry point.        $routeProvider.when '/shrub-angular-entry-point', {}  Turn on HTML5 mode: \"Real\" URLs.        $locationProvider.html5Mode true\n  ]",
            "title": "Promise.when"
        },
        {
            "location": "/source/packages/shrub-angular/",
            "text": "Angular\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAssetsMiddleware\n\n\n  registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Angular'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n\n          assets.scripts.push '//ajax.googleapis.com/ajax/libs/angularjs/1.3.8/angular.min.js'\n          assets.scripts.push '//ajax.googleapis.com/ajax/libs/angularjs/1.3.8/angular-route.min.js'\n          assets.scripts.push '//ajax.googleapis.com/ajax/libs/angularjs/1.3.8/angular-sanitize.min.js'\n\n        else\n\n          assets.scripts.push '/lib/angular/angular.js'\n          assets.scripts.push '/lib/angular/angular-route.js'\n          assets.scripts.push '/lib/angular/angular-sanitize.js'\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig, grunt) ->\n\n    gruntConfig.configureTask(\n      'coffee', 'angular'\n\n      files: [\n        src: [\n          'client/app.coffee'\n        ]\n        dest: 'build/js/app/app.js'\n      ]\n      expand: true\n      ext: '.js'\n      options: bare: true\n    )\n\n    gruntConfig.configureTask(\n      'concat', 'angular'\n\n      files: [\n        src: [\n          'build/js/app/app-dependencies.js'\n          'build/js/app/app.js'\n        ]\n        dest: 'build/js/app/app-bundled.js'\n      ]\n      options:\n        banner: '\\n(function() {\\n\\n'\n        footer: '\\n})();\\n\\n'\n    )\n\n    gruntConfig.configureTask(\n      'watch', 'angular'\n\n      files: [\n        'client/app.coffee'\n      ]\n      tasks: [\n        'build:angular', 'build:shrub'\n      ]\n      options: livereload: true\n    )\n\n\n\n\nBuild the list of third-party Angular modules to be injected as\ndependencies of the Angular application.\n\n\n    gruntConfig.registerTask 'shrubAngularPackageDependencies:angular', ->\n\n      pkgman = require 'pkgman'\n\n\n\n\nInvoke hook \nshrubAngularPackageDependencies\n\n\n      dependencies = []\n      for dependenciesList in pkgman.invokeFlat 'shrubAngularPackageDependencies'\n        dependencies.push.apply dependencies, dependenciesList\n\n      js = 'var packageDependencies = [];\\n\\n'\n      js += \"packageDependencies.push('#{\n        dependencies.join \"');\\npackageDependencies.push('\"\n      }');\\n\" if dependencies.length > 0\n\n      grunt.file.write 'build/js/app/app-dependencies.js', js\n\n    gruntConfig.registerTask 'build:angular', [\n      'newer:coffee:angular'\n      'shrubAngularPackageDependencies:angular'\n      'concat:angular'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:angular']",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-angular/#angular",
            "text": "config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAssetsMiddleware    registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Angular'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n\n          assets.scripts.push '//ajax.googleapis.com/ajax/libs/angularjs/1.3.8/angular.min.js'\n          assets.scripts.push '//ajax.googleapis.com/ajax/libs/angularjs/1.3.8/angular-route.min.js'\n          assets.scripts.push '//ajax.googleapis.com/ajax/libs/angularjs/1.3.8/angular-sanitize.min.js'\n\n        else\n\n          assets.scripts.push '/lib/angular/angular.js'\n          assets.scripts.push '/lib/angular/angular-route.js'\n          assets.scripts.push '/lib/angular/angular-sanitize.js'\n\n        next()\n\n    ]  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig, grunt) ->\n\n    gruntConfig.configureTask(\n      'coffee', 'angular'\n\n      files: [\n        src: [\n          'client/app.coffee'\n        ]\n        dest: 'build/js/app/app.js'\n      ]\n      expand: true\n      ext: '.js'\n      options: bare: true\n    )\n\n    gruntConfig.configureTask(\n      'concat', 'angular'\n\n      files: [\n        src: [\n          'build/js/app/app-dependencies.js'\n          'build/js/app/app.js'\n        ]\n        dest: 'build/js/app/app-bundled.js'\n      ]\n      options:\n        banner: '\\n(function() {\\n\\n'\n        footer: '\\n})();\\n\\n'\n    )\n\n    gruntConfig.configureTask(\n      'watch', 'angular'\n\n      files: [\n        'client/app.coffee'\n      ]\n      tasks: [\n        'build:angular', 'build:shrub'\n      ]\n      options: livereload: true\n    )  Build the list of third-party Angular modules to be injected as\ndependencies of the Angular application.      gruntConfig.registerTask 'shrubAngularPackageDependencies:angular', ->\n\n      pkgman = require 'pkgman'  Invoke hook  shrubAngularPackageDependencies        dependencies = []\n      for dependenciesList in pkgman.invokeFlat 'shrubAngularPackageDependencies'\n        dependencies.push.apply dependencies, dependenciesList\n\n      js = 'var packageDependencies = [];\\n\\n'\n      js += \"packageDependencies.push('#{\n        dependencies.join \"');\\npackageDependencies.push('\"\n      }');\\n\" if dependencies.length > 0\n\n      grunt.file.write 'build/js/app/app-dependencies.js', js\n\n    gruntConfig.registerTask 'build:angular', [\n      'newer:coffee:angular'\n      'shrubAngularPackageDependencies:angular'\n      'concat:angular'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:angular']",
            "title": "Angular"
        },
        {
            "location": "/source/packages/shrub-assets/",
            "text": "Assets management\n\n\nGather, build, and serve assets defined by packages.\n\n\nconfig = require 'config'\n\nassets = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAssetsMiddleware\n\n\n  registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Shrub'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n          assets.scripts.push '/lib/shrub/shrub.min.js'\n        else\n          assets.scripts.push '/lib/shrub/shrub.js'\n\n        assets.styleSheets.push '/css/shrub.css'\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-assets'\n\n    gruntConfig.registerTask 'build:shrub-assets', [\n      'newer:copy:shrub-assets'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-assets']\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n    middleware: [\n      'shrub-assets/jquery'\n      'shrub-socket-socket.io'\n      'shrub-angular'\n      'shrub-assets'\n      'shrub-html5-notification'\n      'shrub-html5-local-storage'\n      'shrub-config'\n      'shrub-grunt'\n    ]\n\n  registrar.recur [\n    'jquery'\n  ]\n\nexports.assets = ->\n  return assets if assets?\n\n  debug = require('debug') 'shrub-silly:assets:middleware'\n\n  middleware = require 'middleware'\n\n  assets = scripts: [], styleSheets: []\n\n\n\n\nInvoke hook \nshrubAssetsMiddleware\n\n\n  debug '- Loading asset middleware...'\n\n  assetsMiddleware = middleware.fromConfig 'shrub-assets:middleware'\n\n  debug '- Asset middleware loaded.'\n\n  assetsMiddleware.dispatch assets, (error) -> throw error if error?\n\n  assets",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-assets/#assets-management",
            "text": "Gather, build, and serve assets defined by packages.  config = require 'config'\n\nassets = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAssetsMiddleware    registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Shrub'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n          assets.scripts.push '/lib/shrub/shrub.min.js'\n        else\n          assets.scripts.push '/lib/shrub/shrub.js'\n\n        assets.styleSheets.push '/css/shrub.css'\n\n        next()\n\n    ]  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-assets'\n\n    gruntConfig.registerTask 'build:shrub-assets', [\n      'newer:copy:shrub-assets'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-assets']  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->\n\n    middleware: [\n      'shrub-assets/jquery'\n      'shrub-socket-socket.io'\n      'shrub-angular'\n      'shrub-assets'\n      'shrub-html5-notification'\n      'shrub-html5-local-storage'\n      'shrub-config'\n      'shrub-grunt'\n    ]\n\n  registrar.recur [\n    'jquery'\n  ]\n\nexports.assets = ->\n  return assets if assets?\n\n  debug = require('debug') 'shrub-silly:assets:middleware'\n\n  middleware = require 'middleware'\n\n  assets = scripts: [], styleSheets: []  Invoke hook  shrubAssetsMiddleware    debug '- Loading asset middleware...'\n\n  assetsMiddleware = middleware.fromConfig 'shrub-assets:middleware'\n\n  debug '- Asset middleware loaded.'\n\n  assetsMiddleware.dispatch assets, (error) -> throw error if error?\n\n  assets",
            "title": "Assets management"
        },
        {
            "location": "/source/packages/shrub-assets/jquery/",
            "text": "jQuery assets\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAssetsMiddleware\n\n\n  registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'jQuery'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n\n          assets.scripts.push '//code.jquery.com/jquery-2.1.3.min.js'\n\n        else\n\n          assets.scripts.push '/lib/jquery/jquery-2.1.3.js'\n\n        next()\n\n    ]",
            "title": "jquery.coffee"
        },
        {
            "location": "/source/packages/shrub-assets/jquery/#jquery-assets",
            "text": "config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAssetsMiddleware    registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'jQuery'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n\n          assets.scripts.push '//code.jquery.com/jquery-2.1.3.min.js'\n\n        else\n\n          assets.scripts.push '/lib/jquery/jquery-2.1.3.js'\n\n        next()\n\n    ]",
            "title": "jQuery assets"
        },
        {
            "location": "/source/packages/shrub-config/",
            "text": "Configuration\n\n\nGathers configuration and serves it as an Angular module for clients.\n\n\n_ = require 'lodash'\nPromise = require 'bluebird'\nurl = require 'url'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\n{Config} = require 'client/modules/config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAssetsMiddleware\n\n\n  registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Config'\n    middleware: [\n\n      (assets, next) ->\n\n        assets.scripts.push '/js/config.js'\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Serve package configuration'\n    middleware: [\n\n\n\n\nServe the configuration module.\n\n\n      (req, res, next) ->\n\n\n\n\nOnly if the path matches.\n\n\n        return next() unless req.url is '/js/config.js'\n\n        exports.renderPackageConfig(req).then((code) ->\n\n\n\n\nEmit the configuration module.\n\n\n          res.setHeader 'Content-Type', 'text/javascript'\n          res.send code\n\n        ).catch next\n\n    ]\n\n\n\n\nshrub-config.renderPackageConfig\n\n\n\n\n(http.IncomingRequest) \nreq\n - The request object.\n\n\n\n\nUse a client's request object to render configuration.\n\n\nexports.renderPackageConfig = (req) ->\n\n\n\n\nInvoke hook \nshrubConfigClient\n\n\nAllows packages to specify configuration that will be sent to the client.\nImplementations may return an object, or a promise that resolves to an\nobject.\n\n\n  subconfigs = pkgman.invoke 'shrubConfigClient', req\n\n  Promise.all(\n\n    promise for path, promise of subconfigs\n\n  ).then (fulfilledSubconfigs) ->\n\n    config_ = new Config()\n\n\n\n\nPackage-independent...\n\n\n    config_.set 'packageList', config.get 'packageList'\n\n\n\n\nMerge in the subconfigs.\n\n\n    index = 0\n    for path of subconfigs\n\n      subconfig = fulfilledSubconfigs[index++]\n      for key, value of subconfig\n        continue unless value?\n\n        config_.set \"packageConfig:#{\n          path.replace /\\//g, ':'\n        }:#{\n          key.replace /\\//g, ':'\n        }\", value\n\n\n\n\nInvoke hook \nshrubConfigClientAlter\n\n\n    pkgman.invoke 'shrubConfigClientAlter', req, config_\n\n\n\n\nFormat the configuration to look nice.\n\n\n    prettyPrintConfig = ->\n\n      jsonArgs = [config_]\n\n      if 'production' isnt config.get 'NODE_ENV'\n        jsonArgs = jsonArgs.concat [null, '  ']\n\n      stringified = JSON.stringify jsonArgs...\n      [first, rest...] = stringified.split '\\n'\n      ([first].concat rest.map (line) -> '    ' + line).join '\\n'\n\n    \"\"\"\nangular.module('shrub.config', ['shrub.require']).config([\n  'shrub-requireProvider', function(requireProvider) {\n    requireProvider.require('config').from(#{prettyPrintConfig()});\n  }\n]);\n  \"\"\"",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-config/#configuration",
            "text": "Gathers configuration and serves it as an Angular module for clients.  _ = require 'lodash'\nPromise = require 'bluebird'\nurl = require 'url'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\n{Config} = require 'client/modules/config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAssetsMiddleware    registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Config'\n    middleware: [\n\n      (assets, next) ->\n\n        assets.scripts.push '/js/config.js'\n\n        next()\n\n    ]  Implements hook  shrubHttpMiddleware    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Serve package configuration'\n    middleware: [  Serve the configuration module.        (req, res, next) ->  Only if the path matches.          return next() unless req.url is '/js/config.js'\n\n        exports.renderPackageConfig(req).then((code) ->  Emit the configuration module.            res.setHeader 'Content-Type', 'text/javascript'\n          res.send code\n\n        ).catch next\n\n    ]",
            "title": "Configuration"
        },
        {
            "location": "/source/packages/shrub-config/#shrub-configrenderpackageconfig",
            "text": "(http.IncomingRequest)  req  - The request object.   Use a client's request object to render configuration.  exports.renderPackageConfig = (req) ->  Invoke hook  shrubConfigClient  Allows packages to specify configuration that will be sent to the client.\nImplementations may return an object, or a promise that resolves to an\nobject.    subconfigs = pkgman.invoke 'shrubConfigClient', req\n\n  Promise.all(\n\n    promise for path, promise of subconfigs\n\n  ).then (fulfilledSubconfigs) ->\n\n    config_ = new Config()  Package-independent...      config_.set 'packageList', config.get 'packageList'  Merge in the subconfigs.      index = 0\n    for path of subconfigs\n\n      subconfig = fulfilledSubconfigs[index++]\n      for key, value of subconfig\n        continue unless value?\n\n        config_.set \"packageConfig:#{\n          path.replace /\\//g, ':'\n        }:#{\n          key.replace /\\//g, ':'\n        }\", value  Invoke hook  shrubConfigClientAlter      pkgman.invoke 'shrubConfigClientAlter', req, config_  Format the configuration to look nice.      prettyPrintConfig = ->\n\n      jsonArgs = [config_]\n\n      if 'production' isnt config.get 'NODE_ENV'\n        jsonArgs = jsonArgs.concat [null, '  ']\n\n      stringified = JSON.stringify jsonArgs...\n      [first, rest...] = stringified.split '\\n'\n      ([first].concat rest.map (line) -> '    ' + line).join '\\n'\n\n    \"\"\"\nangular.module('shrub.config', ['shrub.require']).config([\n  'shrub-requireProvider', function(requireProvider) {\n    requireProvider.require('config').from(#{prettyPrintConfig()});\n  }\n]);\n  \"\"\"",
            "title": "shrub-config.renderPackageConfig"
        },
        {
            "location": "/source/packages/shrub-core/client/",
            "text": "Core client functionality.\n\n\nCoordinate various core functionality.\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularAppRun\n\n\n  registrar.registerHook 'shrubAngularAppRun', -> [\n    '$rootScope', '$location', '$window', 'shrub-socket'\n    ($rootScope, $location, $window, socket) ->\n\n\n\n\nSplit the path into the corresponding classes, e.g. \nfoo/bar/baz\n ->\n\nclass=\"foo foo-bar foo-bar-baz\"\n\n\n      $rootScope.$watch (-> $location.path()), ->\n\n        parts = $location.path().substr(1).split '/'\n        parts = parts.map (part) -> part.replace /[^_a-zA-Z0-9-]/g, '-'\n\n        classes = for i in [1..parts.length]\n          parts.slice(0, i).join '-'\n\n        $rootScope.pathClass = classes.join ' '\n\n\n\n\nNavigate the client to \nhref\n.\n\n\n      socket.on 'core.navigateTo', (href) -> $window.location.href = href\n\n\n\n\nReload the client.\n\n\n      socket.on 'core.reload', -> $window.location.reload()\n\n\n\n\nSet up application close behavior.\n\n\n      $window.addEventListener 'beforeunload', (event) ->\n        appCloseEvent = $rootScope.$emit 'shrub.core.appClose'\n        if appCloseEvent.defaultPrevented\n          {confirmationMessage} = appCloseEvent\n          event ?= $window.event\n          event.returnValue = confirmationMessage\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularRoutes\n\n\nA simple path definition to make sure we're running in e2e testing mode.\n\n\n  registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    if 'e2e' is config.get 'packageConfig:shrub-core:testMode'\n      routes.push\n        path: 'e2e/sanity-check'\n\n    return routes",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-core/client/#core-client-functionality",
            "text": "Coordinate various core functionality.  config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularAppRun    registrar.registerHook 'shrubAngularAppRun', -> [\n    '$rootScope', '$location', '$window', 'shrub-socket'\n    ($rootScope, $location, $window, socket) ->  Split the path into the corresponding classes, e.g.  foo/bar/baz  -> class=\"foo foo-bar foo-bar-baz\"        $rootScope.$watch (-> $location.path()), ->\n\n        parts = $location.path().substr(1).split '/'\n        parts = parts.map (part) -> part.replace /[^_a-zA-Z0-9-]/g, '-'\n\n        classes = for i in [1..parts.length]\n          parts.slice(0, i).join '-'\n\n        $rootScope.pathClass = classes.join ' '  Navigate the client to  href .        socket.on 'core.navigateTo', (href) -> $window.location.href = href  Reload the client.        socket.on 'core.reload', -> $window.location.reload()  Set up application close behavior.        $window.addEventListener 'beforeunload', (event) ->\n        appCloseEvent = $rootScope.$emit 'shrub.core.appClose'\n        if appCloseEvent.defaultPrevented\n          {confirmationMessage} = appCloseEvent\n          event ?= $window.event\n          event.returnValue = confirmationMessage\n\n  ]  Implements hook  shrubAngularRoutes  A simple path definition to make sure we're running in e2e testing mode.    registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    if 'e2e' is config.get 'packageConfig:shrub-core:testMode'\n      routes.push\n        path: 'e2e/sanity-check'\n\n    return routes",
            "title": "Core client functionality."
        },
        {
            "location": "/source/packages/shrub-core/client/test-e2e/",
            "text": "describe 'core', ->\n\n  it 'should be running the server in E2E mode', ->\n\n    browser.get '/e2e/sanity-check'\n    expect(browser.getCurrentUrl()).toContain '/e2e/sanity-check'",
            "title": "test-e2e.coffee"
        },
        {
            "location": "/source/packages/shrub-core/",
            "text": "Core server functionality\n\n\nCoordinate various core functionality.\n\n\nconfig = require 'config'\n\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubConfigClient\n\n\n  registrar.registerHook 'shrubConfigClient', (req) ->\n\n\n\n\nThe URL that the site was accessed at.\n\n\n    hostname: if req.headers?.host?\n      \"//#{req.headers.host}\"\n    else\n      \"//#{config.get 'packageConfig:shrub-core:siteHostname'}\"\n\n\n\n\nIs the server running in test mode?\n\n\n    testMode: if (config.get 'E2E')? then 'e2e' else false\n\n\n\n\nThe process ID of this worker.\n\n\n    pid: process.pid if 'production' isnt config.get 'NODE_ENV'\n\n\n\n\nExecution environment, \nproduction\n, or...\n\n\n    environment: config.get 'NODE_ENV'\n\n\n\n\nThe user-visible site name.\n\n\n    siteName: config.get 'packageConfig:shrub-core:siteName'\n\n\n\n\nImplements hook \nshrubAuditFingerprint\n\n\n  registrar.registerHook 'shrubAuditFingerprint', (req) ->\n\n\n\n\nThe IP address.\n\n\n    ip: req?.normalizedIp\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Normalize request variables'\n    middleware: [\n\n\n\n\nNormalize IP address.\n\n\n      (req, res, next) ->\n\n        req.normalizedIp = req.ip\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n\n\n\nMiddleware for server bootstrap phase.\n\n\n    bootstrapMiddleware: [\n      'shrub-orm'\n      'shrub-install'\n      'shrub-http-express/session'\n      'shrub-http'\n      'shrub-socket'\n      'shrub-rpc'\n      'shrub-passport'\n      'shrub-angular'\n      'shrub-ui/notifications'\n      'shrub-nodemailer'\n      'shrub-repl'\n    ]\n\n\n\n\nGlobal site crypto key.\n\n\n    cryptoKey: '***CHANGE THIS***'\n\n\n\n\nThe default hostname of this application. Includes port if any.\n\n\n    siteHostname: 'localhost:4201'\n\n\n\n\nThe name of the site, used in various places.\n\n\n    siteName: 'Shrub example application'\n\n\n\n\nA list of the IP addresses of trusted proxies between clients.\n\n\n    trustedProxies: []\n\n\n\n\nThe amount of workers to create. Defaults to 0 meaning no workers, only\nthe master.\n\n\n    workers: 0\n\n\n\n\nImplements hook \nshrubRpcRoutesAlter\n\n\nPatch in express-specific variables that will be required by middleware.\n\n\n  registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    coreMiddleware = (req, res, next) ->\n\n      req.headers = req.socket.request.headers\n\n      req.normalizedIp = trustedAddress(\n        req.socket.client.conn.remoteAddress\n        req.headers['x-forwarded-for']\n      )\n\n      next()\n\n    coreMiddleware.weight = -10000\n\n    route.middleware.unshift coreMiddleware for path, route of routes\n\n    return\n\n\n\n\nImplements hook \nshrubSocketConnectionMiddleware\n\n\n  registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Normalize request variables'\n    middleware: [\n\n\n\n\nNormalize IP address.\n\n\n      (req, res, next) ->\n\n        req.normalizedIp = trustedAddress(\n          req.socket.client.conn.remoteAddress\n          req.headers['x-forwarded-for']\n        )\n\n        next()\n\n    ]\n\ntrustedAddress = (address, forwardedFor) -> resolveAddress(\n  config.get 'packageConfig:shrub-core:trustedProxies'\n  address\n  forwardedFor\n)\n\n\n\n\nWalk up the X-Forwarded-For header until we hit an untrusted address.\n\n\nresolveAddress = (trustedProxies, address, forwardedFor) ->\n  return address unless forwardedFor?\n  return address if trustedProxies.length is 0\n\n  split = forwardedFor.split /\\s*, */\n  index = split.length - 1\n  address = split[index--] while ~trustedProxies.indexOf address\n\n  address",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-core/#core-server-functionality",
            "text": "Coordinate various core functionality.  config = require 'config'\n\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubConfigClient    registrar.registerHook 'shrubConfigClient', (req) ->  The URL that the site was accessed at.      hostname: if req.headers?.host?\n      \"//#{req.headers.host}\"\n    else\n      \"//#{config.get 'packageConfig:shrub-core:siteHostname'}\"  Is the server running in test mode?      testMode: if (config.get 'E2E')? then 'e2e' else false  The process ID of this worker.      pid: process.pid if 'production' isnt config.get 'NODE_ENV'  Execution environment,  production , or...      environment: config.get 'NODE_ENV'  The user-visible site name.      siteName: config.get 'packageConfig:shrub-core:siteName'  Implements hook  shrubAuditFingerprint    registrar.registerHook 'shrubAuditFingerprint', (req) ->  The IP address.      ip: req?.normalizedIp  Implements hook  shrubHttpMiddleware    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Normalize request variables'\n    middleware: [  Normalize IP address.        (req, res, next) ->\n\n        req.normalizedIp = req.ip\n        next()\n\n    ]  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->  Middleware for server bootstrap phase.      bootstrapMiddleware: [\n      'shrub-orm'\n      'shrub-install'\n      'shrub-http-express/session'\n      'shrub-http'\n      'shrub-socket'\n      'shrub-rpc'\n      'shrub-passport'\n      'shrub-angular'\n      'shrub-ui/notifications'\n      'shrub-nodemailer'\n      'shrub-repl'\n    ]  Global site crypto key.      cryptoKey: '***CHANGE THIS***'  The default hostname of this application. Includes port if any.      siteHostname: 'localhost:4201'  The name of the site, used in various places.      siteName: 'Shrub example application'  A list of the IP addresses of trusted proxies between clients.      trustedProxies: []  The amount of workers to create. Defaults to 0 meaning no workers, only\nthe master.      workers: 0  Implements hook  shrubRpcRoutesAlter  Patch in express-specific variables that will be required by middleware.    registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    coreMiddleware = (req, res, next) ->\n\n      req.headers = req.socket.request.headers\n\n      req.normalizedIp = trustedAddress(\n        req.socket.client.conn.remoteAddress\n        req.headers['x-forwarded-for']\n      )\n\n      next()\n\n    coreMiddleware.weight = -10000\n\n    route.middleware.unshift coreMiddleware for path, route of routes\n\n    return  Implements hook  shrubSocketConnectionMiddleware    registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Normalize request variables'\n    middleware: [  Normalize IP address.        (req, res, next) ->\n\n        req.normalizedIp = trustedAddress(\n          req.socket.client.conn.remoteAddress\n          req.headers['x-forwarded-for']\n        )\n\n        next()\n\n    ]\n\ntrustedAddress = (address, forwardedFor) -> resolveAddress(\n  config.get 'packageConfig:shrub-core:trustedProxies'\n  address\n  forwardedFor\n)  Walk up the X-Forwarded-For header until we hit an untrusted address.  resolveAddress = (trustedProxies, address, forwardedFor) ->\n  return address unless forwardedFor?\n  return address if trustedProxies.length is 0\n\n  split = forwardedFor.split /\\s*, */\n  index = split.length - 1\n  address = split[index--] while ~trustedProxies.indexOf address\n\n  address",
            "title": "Core server functionality"
        },
        {
            "location": "/source/packages/shrub-example/about/",
            "text": "Example - About page\n\n\nDefine a route to access the README.md page.\n\n\nfs = require 'fs'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubHttpRoutes\n\n\n  registrar.registerHook 'shrubHttpRoutes', (http) ->\n    routes = []\n\n\n\n\nProvide the README file.\n\n\n    routes.push\n      path: '/shrub-example/about/README.md'\n      receiver: (req, res) ->\n\n        fs.readFile 'README.md', (error, buffer) ->\n          throw error if error?\n\n          res.end buffer\n\n    return routes",
            "title": "about.coffee"
        },
        {
            "location": "/source/packages/shrub-example/about/#example-about-page",
            "text": "Define a route to access the README.md page.  fs = require 'fs'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubHttpRoutes    registrar.registerHook 'shrubHttpRoutes', (http) ->\n    routes = []  Provide the README file.      routes.push\n      path: '/shrub-example/about/README.md'\n      receiver: (req, res) ->\n\n        fs.readFile 'README.md', (error, buffer) ->\n          throw error if error?\n\n          res.end buffer\n\n    return routes",
            "title": "Example - About page"
        },
        {
            "location": "/source/packages/shrub-example/client/about/",
            "text": "Example - About page\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularRoutes\n\n\n  registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'about'\n      title: 'About'\n\n      controller: [\n        '$http', '$scope'\n        ($http, $scope) ->\n\n          $scope.about = ''\n\n\n\n\nHit the route we created in the server-side of this package.\n\n\n          $http.get('/shrub-example/about/README.md').success((data) ->\n            $scope.about = data\n          )\n\n      ]\n\n      template: '''\n\n<span\n  class=\"about\"\n  data-ng-bind-html=\"about | shrubUiMarkdown:false\"\n></span>\n\n'''\n\n    return routes",
            "title": "about.coffee"
        },
        {
            "location": "/source/packages/shrub-example/client/about/#example-about-page",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularRoutes    registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'about'\n      title: 'About'\n\n      controller: [\n        '$http', '$scope'\n        ($http, $scope) ->\n\n          $scope.about = ''  Hit the route we created in the server-side of this package.            $http.get('/shrub-example/about/README.md').success((data) ->\n            $scope.about = data\n          )\n\n      ]\n\n      template: '''\n\n<span\n  class=\"about\"\n  data-ng-bind-html=\"about | shrubUiMarkdown:false\"\n></span>\n\n'''\n\n    return routes",
            "title": "Example - About page"
        },
        {
            "location": "/source/packages/shrub-example/client/home/",
            "text": "Example - Home page\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularAppConfig\n\n\n  registrar.registerHook 'shrubAngularAppConfig', -> [\n    '$routeProvider'\n    ($routeProvider) ->\n\n\n\n\nWe'll gank the default route.\n\n\n      $routeProvider.otherwise redirectTo: '/home'\n  ]\n\n\n\n\nImplements hook \nshrubAngularRoutes\n\n\n  registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'home'\n      title: 'Home'\n\n      template: '''\n\n<div class=\"jumbotron\">\n\n  <h1>Shrub</h1>\n\n  <p class=\"lead\">Welcome to the example application for Shrub!</p>\n\n</div>\n\n'''\n\n    return routes",
            "title": "home.coffee"
        },
        {
            "location": "/source/packages/shrub-example/client/home/#example-home-page",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularAppConfig    registrar.registerHook 'shrubAngularAppConfig', -> [\n    '$routeProvider'\n    ($routeProvider) ->  We'll gank the default route.        $routeProvider.otherwise redirectTo: '/home'\n  ]  Implements hook  shrubAngularRoutes    registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'home'\n      title: 'Home'\n\n      template: '''\n\n<div class=\"jumbotron\">\n\n  <h1>Shrub</h1>\n\n  <p class=\"lead\">Welcome to the example application for Shrub!</p>\n\n</div>\n\n'''\n\n    return routes",
            "title": "Example - Home page"
        },
        {
            "location": "/source/packages/shrub-example/client/",
            "text": "Example package\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubSkinLink--DIRECTIVE\n\n\n  registrar.registerHook 'shrubSkinLink--shrubSkinStrappedMainNav', -> [\n    '$scope'\n    ($scope) ->\n\n\n\n\nNot ideal, but it's what we have right now.\n\n\n      $scope.menu.items.push\n        path: 'home'\n        label: 'Home'\n\n      $scope.menu.items.push\n        path: 'about'\n        label: 'About'\n\n  ]\n\n  registrar.recur [\n    'about', 'home'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-example/client/#example-package",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubSkinLink--DIRECTIVE    registrar.registerHook 'shrubSkinLink--shrubSkinStrappedMainNav', -> [\n    '$scope'\n    ($scope) ->  Not ideal, but it's what we have right now.        $scope.menu.items.push\n        path: 'home'\n        label: 'Home'\n\n      $scope.menu.items.push\n        path: 'about'\n        label: 'About'\n\n  ]\n\n  registrar.recur [\n    'about', 'home'\n  ]",
            "title": "Example package"
        },
        {
            "location": "/source/packages/shrub-example/client/test-e2e/",
            "text": "describe 'home', ->\n\n  beforeEach ->\n\n    browser.get '/home'\n\n  it 'should render home when user navigates to /home', ->\n\n    expect(shrub.text 'h1').toBe 'Shrub'\n\ndescribe 'about', ->\n\n  beforeEach ->\n\n    browser.get '/about'\n\n  it 'should render about when user navigates to /about', ->\n\n    expect(shrub.text 'h2').toBe 'Shrub'",
            "title": "test-e2e.coffee"
        },
        {
            "location": "/source/packages/shrub-example/",
            "text": "Example package\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubRpcRoutesAlter\n\n\nOur notification queue uses the session, so we'll alter those routes to\nload the session if it's for the shrubExampleGeneral queue.\n\n\n  registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    for path, route of routes\n      if path.match /^shrub-ui\\/notifications.*/\n        route.middleware.unshift (req, res, next) ->\n          if 'shrubExampleGeneral' is req.body.queue\n            return req.loadSession next\n          next()\n\n    return\n\n\n\n\nImplements hook \nshrubUiNotificationQueues\n\n\nImplement the \ngeneral\n queue, used to show some notifications.\n\n\n  registrar.registerHook 'shrubUiNotificationQueues', ->\n\n    shrubExampleGeneral:\n\n      channelFromRequest: (req) -> req.session?.id\n\n  registrar.recur [\n    'about'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-example/#example-package",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubRpcRoutesAlter  Our notification queue uses the session, so we'll alter those routes to\nload the session if it's for the shrubExampleGeneral queue.    registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    for path, route of routes\n      if path.match /^shrub-ui\\/notifications.*/\n        route.middleware.unshift (req, res, next) ->\n          if 'shrubExampleGeneral' is req.body.queue\n            return req.loadSession next\n          next()\n\n    return  Implements hook  shrubUiNotificationQueues  Implement the  general  queue, used to show some notifications.    registrar.registerHook 'shrubUiNotificationQueues', ->\n\n    shrubExampleGeneral:\n\n      channelFromRequest: (req) -> req.session?.id\n\n  registrar.recur [\n    'about'\n  ]",
            "title": "Example package"
        },
        {
            "location": "/source/packages/shrub-form/client/",
            "text": "Form processing\n\n\nDefine a directive for Angular forms, and a service to cache and look them\nup later.\n\n\n_ = require 'lodash'\ni8n = require 'inflection'\n\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    '$compile', '$exceptionHandler', '$injector', '$log', '$q', 'shrub-form', 'shrub-require'\n    ($compile, $exceptionHandler, $injector, $log, $q, formService, require) ->\n\n      link: (scope, element, attrs) ->\n\n\n\n\nKeep a reference to the form scope, if the form attribute value\nchanges, it'll need to be rebuilt.\n\n\n        formScope = null\n        scope.$watch attrs.form, (form) ->\n          return unless form?\n\n          form.key ?= attrs.form\n\n\n\n\nGet the form's current values.\n\n\n          form.values = ->\n            values = {}\n\n            for name, field of form.fields\n              widget = formService.widgets[field.type]\n              if widget.extractValues?\n                widget.extractValues field, values, formService\n              else\n                values[field.name] = field.value\n\n            return values\n\n\n\n\nNormalize form submits into an array.\n\n\n          form.submits = [form.submits] unless angular.isArray form.submits\n\n\n\n\nBuild a submit function which will be bound to ngSubmit.\n\n\n          (scope['$shrubSubmit'] ?= {})[form.key] = ($event) ->\n\n\n\n\nCall all the form submission handlers.\n\n\n            try\n\n              values = form.values()\n\n              promises = for submit in form.submits\n                submit values, form, $event\n\n              $q.all promises\n\n            catch error\n              $exceptionHandler error\n\n\n\n\nInvoke hook \nshrubFormAlter\n\n\n          pkgman.invokeFlat 'shrubFormAlter', form\n\n\n\n\nInvoke hook \nshrubFormFormKeyAlter\n\n\n          pkgman.invokeFlat \"shrubForm#{\n            pkgman.normalizePath form.key, true\n          }Alter\", form\n\n\n\n\nCreate the form element.\n\n\n          $form = angular.element '<form />'\n          $form.addClass form.key\n\n\n\n\nDefault method to POST.\n\n\n          $form.attr 'method', attrs.method ? 'POST'\n          $form.attr 'data-ng-submit', \"$shrubSubmit['#{form.key}']($event)\"\n\n\n\n\nBuild the form fields.\n\n\n          for name, field of form.fields\n\n\n\n\nLook up the widget definition and warn if it doesn't exist.\n\n\n            unless (widget = formService.widgets[field.type])?\n\n              $log.warn \"Form `#{\n                form.key\n              }` contains non-existent field type `#{\n                field.type\n              }`!\"\n              continue\n\n\n\n\nDefault name to the key.\n\n\n            field.name ?= name\n\n\n\n\nHelper function to synchronize the field and model value.\n\n\n            do (field) -> field.syncModel = (scope) ->\n              self = this\n\n              return unless self.model?\n\n              self.$modelDereg?()\n              self.$modelDereg = null\n\n              self.$valueDereg?()\n              self.$valueDereg = null\n\n              if self.model isnt 'field.value'\n\n                self.$valueDereg = scope.$watch 'field.value', (value) ->\n                  scope.$eval \"#{self.model} = value\", value: value\n\n                self.$modelDereg = scope.$watch self.model, (value) ->\n                  self.value = value\n\n              return\n\n            $form.append \"\"\"\n\n<div\n  data-#{widget.directive}\n  data-field=\"#{attrs.form}.fields['#{name}']\"\n  data-form=\"#{attrs.form}\"\n></div><span> </span>\n\n\"\"\"\n\n\n\n\nAdd hidden form key to allow server-side interception/processing.\n\n\n          $formKeyElement = angular.element '<input type=\"hidden\" />'\n          $formKeyElement.attr name: 'formKey', value: form.key\n          $form.append $formKeyElement\n\n\n\n\nRemove any old stuff.\n\n\n          if formScope\n            formScope.$destroy()\n            element.find('form').remove()\n\n\n\n\nInsert and compile the form element.\n\n\n          element.append $form\n          $compile($form) formScope = scope.$new()\n\n\n\n\nRegister the form in the system.\n\n\n          formService.cache form.key, formScope, $form\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularService\n\n\n  registrar.registerHook 'shrubAngularService', -> [\n\n    ->\n\n      service = forms: {}, widgets: {}\n\n\n\n\nform.cache\n\n\n\n\n\n\n(string) \nkey\n - The form key.\n\n\n\n\n\n\n(Scope) \nscope\n - The form's Angular scope.\n\n\n\n\n\n\n(Element) \nelement\n - The form's jqLite element.\n\n\n\n\n\n\nCache a form for later lookup.\n\n\n      service.cache = (key, scope, element) ->\n        service.forms[key] = scope: scope, element: element\n\n\n\n\nInvoke hook \nshrubFormWidgets\n\n\n      for formWidgets in pkgman.invokeFlat 'shrubFormWidgets'\n        formWidgets = [formWidgets] unless _.isArray formWidgets\n\n        for formWidget in formWidgets\n          continue unless formWidget.directive?\n          service.widgets[formWidget.type] = formWidget\n\n      service\n\n  ]\n\n  registrar.recur [\n    'widget/checkbox'\n    'widget/checkboxes'\n    'widget/group'\n    'widget/hidden'\n    'widget/markup'\n    'widget/radio'\n    'widget/radios'\n    'widget/submit'\n    'widget/select'\n    'widget/text'\n    'widget/textarea'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/#form-processing",
            "text": "Define a directive for Angular forms, and a service to cache and look them\nup later.  _ = require 'lodash'\ni8n = require 'inflection'\n\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    '$compile', '$exceptionHandler', '$injector', '$log', '$q', 'shrub-form', 'shrub-require'\n    ($compile, $exceptionHandler, $injector, $log, $q, formService, require) ->\n\n      link: (scope, element, attrs) ->  Keep a reference to the form scope, if the form attribute value\nchanges, it'll need to be rebuilt.          formScope = null\n        scope.$watch attrs.form, (form) ->\n          return unless form?\n\n          form.key ?= attrs.form  Get the form's current values.            form.values = ->\n            values = {}\n\n            for name, field of form.fields\n              widget = formService.widgets[field.type]\n              if widget.extractValues?\n                widget.extractValues field, values, formService\n              else\n                values[field.name] = field.value\n\n            return values  Normalize form submits into an array.            form.submits = [form.submits] unless angular.isArray form.submits  Build a submit function which will be bound to ngSubmit.            (scope['$shrubSubmit'] ?= {})[form.key] = ($event) ->  Call all the form submission handlers.              try\n\n              values = form.values()\n\n              promises = for submit in form.submits\n                submit values, form, $event\n\n              $q.all promises\n\n            catch error\n              $exceptionHandler error  Invoke hook  shrubFormAlter            pkgman.invokeFlat 'shrubFormAlter', form  Invoke hook  shrubFormFormKeyAlter            pkgman.invokeFlat \"shrubForm#{\n            pkgman.normalizePath form.key, true\n          }Alter\", form  Create the form element.            $form = angular.element '<form />'\n          $form.addClass form.key  Default method to POST.            $form.attr 'method', attrs.method ? 'POST'\n          $form.attr 'data-ng-submit', \"$shrubSubmit['#{form.key}']($event)\"  Build the form fields.            for name, field of form.fields  Look up the widget definition and warn if it doesn't exist.              unless (widget = formService.widgets[field.type])?\n\n              $log.warn \"Form `#{\n                form.key\n              }` contains non-existent field type `#{\n                field.type\n              }`!\"\n              continue  Default name to the key.              field.name ?= name  Helper function to synchronize the field and model value.              do (field) -> field.syncModel = (scope) ->\n              self = this\n\n              return unless self.model?\n\n              self.$modelDereg?()\n              self.$modelDereg = null\n\n              self.$valueDereg?()\n              self.$valueDereg = null\n\n              if self.model isnt 'field.value'\n\n                self.$valueDereg = scope.$watch 'field.value', (value) ->\n                  scope.$eval \"#{self.model} = value\", value: value\n\n                self.$modelDereg = scope.$watch self.model, (value) ->\n                  self.value = value\n\n              return\n\n            $form.append \"\"\"\n\n<div\n  data-#{widget.directive}\n  data-field=\"#{attrs.form}.fields['#{name}']\"\n  data-form=\"#{attrs.form}\"\n></div><span> </span>\n\n\"\"\"  Add hidden form key to allow server-side interception/processing.            $formKeyElement = angular.element '<input type=\"hidden\" />'\n          $formKeyElement.attr name: 'formKey', value: form.key\n          $form.append $formKeyElement  Remove any old stuff.            if formScope\n            formScope.$destroy()\n            element.find('form').remove()  Insert and compile the form element.            element.append $form\n          $compile($form) formScope = scope.$new()  Register the form in the system.            formService.cache form.key, formScope, $form\n\n  ]  Implements hook  shrubAngularService    registrar.registerHook 'shrubAngularService', -> [\n\n    ->\n\n      service = forms: {}, widgets: {}",
            "title": "Form processing"
        },
        {
            "location": "/source/packages/shrub-form/client/#formcache",
            "text": "(string)  key  - The form key.    (Scope)  scope  - The form's Angular scope.    (Element)  element  - The form's jqLite element.    Cache a form for later lookup.        service.cache = (key, scope, element) ->\n        service.forms[key] = scope: scope, element: element  Invoke hook  shrubFormWidgets        for formWidgets in pkgman.invokeFlat 'shrubFormWidgets'\n        formWidgets = [formWidgets] unless _.isArray formWidgets\n\n        for formWidget in formWidgets\n          continue unless formWidget.directive?\n          service.widgets[formWidget.type] = formWidget\n\n      service\n\n  ]\n\n  registrar.recur [\n    'widget/checkbox'\n    'widget/checkboxes'\n    'widget/group'\n    'widget/hidden'\n    'widget/markup'\n    'widget/radio'\n    'widget/radios'\n    'widget/submit'\n    'widget/select'\n    'widget/text'\n    'widget/textarea'\n  ]",
            "title": "form.cache"
        },
        {
            "location": "/source/packages/shrub-form/client/test-unit/",
            "text": "describe 'form', ->\n\n  it 'should automagically register a form when compiling a directive', ->\n\n    inject [\n      '$compile', '$rootScope', 'shrub-form'\n      ($compile, $rootScope, shrubForm) ->\n\n\n\n\nSanity\n\n\n        expect(shrubForm.forms.test).not.toBeDefined()\n\n        element = angular.element(\n          '<div data-shrub-form data-form=\"testAuto\"></div>'\n        )\n\n        scope = $rootScope.$new()\n        scope['testAuto'] = {}\n\n        $compile(element)(scope)\n        scope.$digest()\n\n\n\n\nRegistered.\n\n\n        expect(shrubForm.forms.testAuto).toBeDefined()\n\n    ]\n\n  it 'should generate correct form elements when compiled', ->\n\n    inject [\n      '$compile', '$rootScope'\n      ($compile, $rootScope) ->\n\n        element = angular.element(\n          '<div data-shrub-form data-form=\"testElements\"></div>'\n        )\n\n        scope = $rootScope.$new()\n\n        scope['testElements'] =\n\n          fields:\n\n            email:\n              type: 'email'\n              label: 'email'\n            password:\n              type: 'password'\n              label: 'password'\n              required: true\n            text:\n              value: 'test'\n              type: 'text'\n              label: 'text'\n\n        $compile(element)(scope)\n        scope.$digest()\n\n        $form = element.find 'form'\n\n\n\n\n exists\n\n\u0002wzxhzdk:3\u0003\n\n\nAssert actual input type.\n\n\n\u0002wzxhzdk:4\u0003\n\n\nCheck required fields.\n\n\n\u0002wzxhzdk:5\u0003\n\n\nCheck default values.\n\n\n\u0002wzxhzdk:6\u0003\n\n\nAll children present.\n\n\n\u0002wzxhzdk:7\u0003\n\n\nForm key generated.\n\n\n\u0002wzxhzdk:8\u0003\n\n\nForm was submitted with correct values.\n\n\n\u0002wzxhzdk:9\u0003\n\n\nRPC received correct data.\n\n\n\u0002wzxhzdk:10\u0003\n\n\nForm was submitted with correct values.\n\n\n\u0002wzxhzdk:11\u0003",
            "title": "test-unit.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/checkbox/",
            "text": "Form - checkbox\n\n\n_ = require 'lodash'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.change ?= ->\n          field.model ?= 'field.value'\n\n          field.$change = ($event) -> scope.$$postDigest ->\n            field.change field.value, $event\n\n          field.syncModel scope\n\n      template: '''\n\n<div class=\"checkbox\">\n\n  <label>\n\n    <input\n      name=\"{{field.name}}\"\n      type=\"checkbox\"\n\n      data-shrub-ui-attributes=\"field.attributes\"\n      data-ng-change=\"field.$change($event);\"\n      data-ng-true-value=\"{{field.trueValue || true}}\"\n      data-ng-false-value=\"{{field.falseValue || false}}\"\n      data-ng-model=\"field.value\"\n    >\n\n    {{field.label}}\n\n  </label>\n\n</div>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.prop 'checked', 'on' is value\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'checkbox'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-checkbox'\n\n    widgets",
            "title": "checkbox.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/checkbox/#form-checkbox",
            "text": "_ = require 'lodash'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.change ?= ->\n          field.model ?= 'field.value'\n\n          field.$change = ($event) -> scope.$$postDigest ->\n            field.change field.value, $event\n\n          field.syncModel scope\n\n      template: '''\n\n<div class=\"checkbox\">\n\n  <label>\n\n    <input\n      name=\"{{field.name}}\"\n      type=\"checkbox\"\n\n      data-shrub-ui-attributes=\"field.attributes\"\n      data-ng-change=\"field.$change($event);\"\n      data-ng-true-value=\"{{field.trueValue || true}}\"\n      data-ng-false-value=\"{{field.falseValue || false}}\"\n      data-ng-model=\"field.value\"\n    >\n\n    {{field.label}}\n\n  </label>\n\n</div>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.prop 'checked', 'on' is value  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'checkbox'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-checkbox'\n\n    widgets",
            "title": "Form - checkbox"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/checkboxes/",
            "text": "Form - checkboxes\n\n\n_ = require 'lodash'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope, element) ->\n\n        scope.$watchCollection(\n          -> scope.field.checkboxes\n          ->\n\n            for checkbox in scope.field.checkboxes\n              checkbox.childName ?= checkbox.name\n\n              checkbox.name = \"#{\n                scope.field.name\n              }[#{\n                checkbox.childName\n              }]\"\n\n              checkbox.type = 'checkbox'\n\n            return\n\n        )\n\n        scope.$watchCollection(\n          -> scope.field.checkboxes.map (checkbox) -> checkbox.value\n          ->\n\n            scope.field.value = {}\n\n            for checkbox in scope.field.checkboxes\n              scope.field.value[checkbox.childName] = checkbox.value\n\n            return\n\n        )\n\n      template: '''\n\n<div\n  class=\"checkboxes\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n>\n\n  <label\n    data-ng-bind=\"field.label\"\n  ></label>\n\n  <ul>\n\n    <li\n      data-ng-class=\"{first: $first}\"\n      data-ng-repeat=\"checkbox in field.checkboxes\"\n      data-shrub-form-widget-checkbox\n      data-field=\"checkbox\"\n    ></li>\n\n  </ul>\n\n</div>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) ->\n\n    for k, v of value\n\n      element.find('.checkbox input[name\"' + k + '\"]').prop 'checked', true\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'checkboxes'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-checkboxes'\n\n    widgets",
            "title": "checkboxes.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/checkboxes/#form-checkboxes",
            "text": "_ = require 'lodash'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope, element) ->\n\n        scope.$watchCollection(\n          -> scope.field.checkboxes\n          ->\n\n            for checkbox in scope.field.checkboxes\n              checkbox.childName ?= checkbox.name\n\n              checkbox.name = \"#{\n                scope.field.name\n              }[#{\n                checkbox.childName\n              }]\"\n\n              checkbox.type = 'checkbox'\n\n            return\n\n        )\n\n        scope.$watchCollection(\n          -> scope.field.checkboxes.map (checkbox) -> checkbox.value\n          ->\n\n            scope.field.value = {}\n\n            for checkbox in scope.field.checkboxes\n              scope.field.value[checkbox.childName] = checkbox.value\n\n            return\n\n        )\n\n      template: '''\n\n<div\n  class=\"checkboxes\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n>\n\n  <label\n    data-ng-bind=\"field.label\"\n  ></label>\n\n  <ul>\n\n    <li\n      data-ng-class=\"{first: $first}\"\n      data-ng-repeat=\"checkbox in field.checkboxes\"\n      data-shrub-form-widget-checkbox\n      data-field=\"checkbox\"\n    ></li>\n\n  </ul>\n\n</div>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) ->\n\n    for k, v of value\n\n      element.find('.checkbox input[name\"' + k + '\"]').prop 'checked', true  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'checkboxes'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-checkboxes'\n\n    widgets",
            "title": "Form - checkboxes"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/group/",
            "text": "Form - Group\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    '$compile', '$log', 'shrub-form'\n    ($compile, $log, formService) ->\n\n      scope: field: '=', form: '='\n\n      link: (scope, element) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.collapse ?= true\n          field.isVisible ?= -> true\n\n        scope.$watchCollection(\n          -> scope.field.fields\n          (fields) ->\n\n            element.empty()\n\n            for name, field of fields\n\n\n\n\nLook up the widget definition and warn if it doesn't exist.\n\n\n              unless (widget = formService.widgets[field.type])?\n\n                $log.warn \"Form `#{\n                  scope.form.key\n                }` contains a group `#{\n                  scope.field.name\n                }` with a non-existent field type `#{\n                  field.type\n                }`!\"\n                continue\n\n\n\n\nDefault name to the key.\n\n\n              field.name ?= name\n\n\n\n\nInherit method.\n\n\n              field.syncModel = scope.field.syncModel\n\n              markup = \"\"\"\n\n<div\n  data-#{widget.directive}\n  data-ng-show=\"field.isVisible()\"\n  data-field=\"field.fields['#{name}']\"\n  data-form=\"form\"\n  data-shrub-ui-attributes=\"field.attributes\"\n></div><span> </span>\n\n\"\"\"\n\n              element.append $compile(markup)(scope)\n\n            return\n\n        )\n\n      template: '''\n<div\n  data-shrub-ui-attributes=\"field.attributes\"\n></div>\n\n'''\n\n  ]\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'group'\n      directive: 'shrub-form-widget-group'\n      extractValues: (field, values, formService) ->\n\n        for name, subfield of field.fields\n          widget = formService.widgets[subfield.type]\n          if widget.extractValues?\n            widget.extractValues(\n              subfield\n              if field.collapse\n                values\n              else\n                values[field.name] ?= {}\n              formService\n            )\n          else\n            if field.collapse\n              values[subfield.name] = subfield.value\n            else\n              (values[field.name] ?= {})[subfield.name] = subfield.value\n\n    widgets",
            "title": "group.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/group/#form-group",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    '$compile', '$log', 'shrub-form'\n    ($compile, $log, formService) ->\n\n      scope: field: '=', form: '='\n\n      link: (scope, element) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.collapse ?= true\n          field.isVisible ?= -> true\n\n        scope.$watchCollection(\n          -> scope.field.fields\n          (fields) ->\n\n            element.empty()\n\n            for name, field of fields  Look up the widget definition and warn if it doesn't exist.                unless (widget = formService.widgets[field.type])?\n\n                $log.warn \"Form `#{\n                  scope.form.key\n                }` contains a group `#{\n                  scope.field.name\n                }` with a non-existent field type `#{\n                  field.type\n                }`!\"\n                continue  Default name to the key.                field.name ?= name  Inherit method.                field.syncModel = scope.field.syncModel\n\n              markup = \"\"\"\n\n<div\n  data-#{widget.directive}\n  data-ng-show=\"field.isVisible()\"\n  data-field=\"field.fields['#{name}']\"\n  data-form=\"form\"\n  data-shrub-ui-attributes=\"field.attributes\"\n></div><span> </span>\n\n\"\"\"\n\n              element.append $compile(markup)(scope)\n\n            return\n\n        )\n\n      template: '''\n<div\n  data-shrub-ui-attributes=\"field.attributes\"\n></div>\n\n'''\n\n  ]  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'group'\n      directive: 'shrub-form-widget-group'\n      extractValues: (field, values, formService) ->\n\n        for name, subfield of field.fields\n          widget = formService.widgets[subfield.type]\n          if widget.extractValues?\n            widget.extractValues(\n              subfield\n              if field.collapse\n                values\n              else\n                values[field.name] ?= {}\n              formService\n            )\n          else\n            if field.collapse\n              values[subfield.name] = subfield.value\n            else\n              (values[field.name] ?= {})[subfield.name] = subfield.value\n\n    widgets",
            "title": "Form - Group"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/hidden/",
            "text": "Form - Hidden element\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      template: '''\n\n<input\n  name=\"{{field.name}}\"\n  type=\"hidden\"\n  value=\"{{field.value}}\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.attr 'value', value\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'hidden'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-hidden'\n\n    widgets",
            "title": "hidden.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/hidden/#form-hidden-element",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      template: '''\n\n<input\n  name=\"{{field.name}}\"\n  type=\"hidden\"\n  value=\"{{field.value}}\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.attr 'value', value  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'hidden'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-hidden'\n\n    widgets",
            "title": "Form - Hidden element"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/markup/",
            "text": "Form - Markup\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    '$compile'\n    ($compile) ->\n\n      scope: field: '=', form: '='\n\n      link: (scope, element) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.model ?= 'field.value'\n\n          field.syncModel scope\n\n        scope.$watch 'field.value', (markup) ->\n\n          $container = element.find 'div'\n          $container.empty().append $compile(markup)(scope)\n\n      template: '''\n\n<div\n  class=\"markup\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n></div>\n\n'''\n\n  ]\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'markup'\n      assignToElement: ->\n      directive: 'shrub-form-widget-markup'\n\n    widgets",
            "title": "markup.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/markup/#form-markup",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    '$compile'\n    ($compile) ->\n\n      scope: field: '=', form: '='\n\n      link: (scope, element) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.model ?= 'field.value'\n\n          field.syncModel scope\n\n        scope.$watch 'field.value', (markup) ->\n\n          $container = element.find 'div'\n          $container.empty().append $compile(markup)(scope)\n\n      template: '''\n\n<div\n  class=\"markup\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n></div>\n\n'''\n\n  ]  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'markup'\n      assignToElement: ->\n      directive: 'shrub-form-widget-markup'\n\n    widgets",
            "title": "Form - Markup"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/radio/",
            "text": "Form - Radio\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.change ?= ->\n          field.selectedValue ?= true\n          field.model ?= 'field.value'\n\n          field.$change = ($event) -> scope.$$postDigest ->\n            field.change field.value, $event\n\n          field.syncModel scope\n\n      template: '''\n\n<div class=\"radio\">\n\n  <label>\n\n    <input\n      name=\"{{field.name}}\"\n      type=\"radio\"\n\n      data-shrub-ui-attributes=\"field.attributes\"\n      data-ng-change=\"field.$change($event);\"\n      data-ng-model=\"field.value\"\n      data-ng-value=\"field.selectedValue\"\n    >\n\n    {{field.label}}\n\n  </label>\n\n</div>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) ->\n\n    element.prop 'checked', true\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'radio'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-radio'\n\n    widgets",
            "title": "radio.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/radio/#form-radio",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.change ?= ->\n          field.selectedValue ?= true\n          field.model ?= 'field.value'\n\n          field.$change = ($event) -> scope.$$postDigest ->\n            field.change field.value, $event\n\n          field.syncModel scope\n\n      template: '''\n\n<div class=\"radio\">\n\n  <label>\n\n    <input\n      name=\"{{field.name}}\"\n      type=\"radio\"\n\n      data-shrub-ui-attributes=\"field.attributes\"\n      data-ng-change=\"field.$change($event);\"\n      data-ng-model=\"field.value\"\n      data-ng-value=\"field.selectedValue\"\n    >\n\n    {{field.label}}\n\n  </label>\n\n</div>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) ->\n\n    element.prop 'checked', true  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'radio'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-radio'\n\n    widgets",
            "title": "Form - Radio"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/radios/",
            "text": "Form - Radios\n\n\n_ = require 'lodash'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope, element) ->\n\n        scope.$watchCollection(\n          -> scope.field.radios\n          ->\n\n            for radio in scope.field.radios\n              radio.name = field.name\n              radio.type = 'radio'\n\n\n\n\nSync the radio value with field.value\n\n\n            $radios = angular.element('.radio input', element)\n            $radios.off 'change'\n            $radios.on 'change', ->\n              field.value = $radios.filter(':checked').val()\n\n            return\n\n        )\n\n      template: '''\n\n<div\n  class=\"radios\"\n  data-shrub-ui-attributes=\"field.attributes\"\n>\n\n  <label\n    data-ng-bind=\"field.label\"\n  ></label>\n\n  <ul>\n\n    <li\n      data-ng-class=\"{first: $first}\"\n      data-ng-repeat=\"radio in field.radios\"\n      data-shrub-form-widget-radio\n      data-field=\"radio\"\n    ></li>\n\n  </ul>\n\n</div>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) ->\n\n    for k, v of value\n\n      element.find('.radio input[name\"' + k + '\"]').prop 'checked', true\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'radios'\n      directive: 'shrub-form-widget-radios'\n\n    widgets",
            "title": "radios.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/radios/#form-radios",
            "text": "_ = require 'lodash'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope, element) ->\n\n        scope.$watchCollection(\n          -> scope.field.radios\n          ->\n\n            for radio in scope.field.radios\n              radio.name = field.name\n              radio.type = 'radio'  Sync the radio value with field.value              $radios = angular.element('.radio input', element)\n            $radios.off 'change'\n            $radios.on 'change', ->\n              field.value = $radios.filter(':checked').val()\n\n            return\n\n        )\n\n      template: '''\n\n<div\n  class=\"radios\"\n  data-shrub-ui-attributes=\"field.attributes\"\n>\n\n  <label\n    data-ng-bind=\"field.label\"\n  ></label>\n\n  <ul>\n\n    <li\n      data-ng-class=\"{first: $first}\"\n      data-ng-repeat=\"radio in field.radios\"\n      data-shrub-form-widget-radio\n      data-field=\"radio\"\n    ></li>\n\n  </ul>\n\n</div>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) ->\n\n    for k, v of value\n\n      element.find('.radio input[name\"' + k + '\"]').prop 'checked', true  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'radios'\n      directive: 'shrub-form-widget-radios'\n\n    widgets",
            "title": "Form - Radios"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/select/",
            "text": "Form - Select\n\n\n_ = require 'lodash'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n          scope.field.change ?= ->\n\n          scope.field.$change = ($event) -> scope.$$postDigest ->\n            scope.field.change scope.field.value, $event\n\n      template: '''\n\n<label\n  data-ng-bind=\"field.label\"\n></label>\n\n<select\n  class=\"form-control\"\n  name=\"{{field.name}}\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n  data-ng-change=\"field.$change($event);\"\n  data-ng-model=\"field.value\"\n  data-ng-required=\"field.required\"\n  data-ng-options=\"{{field.options}}\"\n></select>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) ->\n\n    element.find(\"option[value=\\\"#{value}\\\"]\").prop 'selected', true\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'select'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-select'\n\n    widgets",
            "title": "select.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/select/#form-select",
            "text": "_ = require 'lodash'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n          scope.field.change ?= ->\n\n          scope.field.$change = ($event) -> scope.$$postDigest ->\n            scope.field.change scope.field.value, $event\n\n      template: '''\n\n<label\n  data-ng-bind=\"field.label\"\n></label>\n\n<select\n  class=\"form-control\"\n  name=\"{{field.name}}\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n  data-ng-change=\"field.$change($event);\"\n  data-ng-model=\"field.value\"\n  data-ng-required=\"field.required\"\n  data-ng-options=\"{{field.options}}\"\n></select>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) ->\n\n    element.find(\"option[value=\\\"#{value}\\\"]\").prop 'selected', true  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'select'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-select'\n\n    widgets",
            "title": "Form - Select"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/submit/",
            "text": "Form - Submit\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.clicked = -> scope.form.$submitted = scope.field\n\n        scope.$watch 'field', (field) ->\n\n          field.value ?= 'Submit'\n\n      template: '''\n\n<input\n  class=\"btn btn-default\"\n  name=\"{{field.name}}\"\n  type=\"submit\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n  data-ng-click=\"clicked();\"\n  data-ng-value=\"field.value\"\n>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.val value\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'submit'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-submit'\n\n    widgets",
            "title": "submit.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/submit/#form-submit",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.clicked = -> scope.form.$submitted = scope.field\n\n        scope.$watch 'field', (field) ->\n\n          field.value ?= 'Submit'\n\n      template: '''\n\n<input\n  class=\"btn btn-default\"\n  name=\"{{field.name}}\"\n  type=\"submit\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n  data-ng-click=\"clicked();\"\n  data-ng-value=\"field.value\"\n>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.val value  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'submit'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-submit'\n\n    widgets",
            "title": "Form - Submit"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/text/",
            "text": "Form - Text\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.minLength ?= 0\n          field.maxLength ?= Infinity\n          field.pattern ?= /.*/\n          field.model ?= 'field.value'\n\n          field.syncModel scope\n\n      template: '''\n\n<label\n  data-ng-if=\"!!field.label\"\n  data-ng-bind=\"field.label\"\n></label>\n\n<input\n  class=\"form-control\"\n  name=\"{{field.name}}\"\n  type=\"{{field.type}}\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n  data-ng-model=\"field.value\"\n  data-ng-required=\"field.required\"\n  data-ng-minlength=\"{{field.minlength}}\"\n  data-ng-maxlength=\"{{field.maxlength}}\"\n  data-ng-pattern=\"field.pattern\"\n  data-ng-trim=\"{{field.trim}}\"\n>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.val value\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'email'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-text'\n\n    widgets.push\n\n      type: 'password'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-text'\n\n    widgets.push\n\n      type: 'text'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-text'\n\n    widgets",
            "title": "text.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/text/#form-text",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.minLength ?= 0\n          field.maxLength ?= Infinity\n          field.pattern ?= /.*/\n          field.model ?= 'field.value'\n\n          field.syncModel scope\n\n      template: '''\n\n<label\n  data-ng-if=\"!!field.label\"\n  data-ng-bind=\"field.label\"\n></label>\n\n<input\n  class=\"form-control\"\n  name=\"{{field.name}}\"\n  type=\"{{field.type}}\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n  data-ng-model=\"field.value\"\n  data-ng-required=\"field.required\"\n  data-ng-minlength=\"{{field.minlength}}\"\n  data-ng-maxlength=\"{{field.maxlength}}\"\n  data-ng-pattern=\"field.pattern\"\n  data-ng-trim=\"{{field.trim}}\"\n>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.val value  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'email'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-text'\n\n    widgets.push\n\n      type: 'password'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-text'\n\n    widgets.push\n\n      type: 'text'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-text'\n\n    widgets",
            "title": "Form - Text"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/textarea/",
            "text": "Form - Text\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.minLength ?= 0\n          field.maxLength ?= Infinity\n          field.pattern ?= /.*/\n          field.model ?= 'field.value'\n\n          field.syncModel scope\n\n      template: '''\n\n<label\n  data-ng-if=\"!!field.label\"\n  data-ng-bind=\"field.label\"\n></label>\n\n<textarea\n  class=\"form-control\"\n  name=\"{{field.name}}\"\n  type=\"{{field.type}}\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n  data-ng-keypress=\"field.keyPress($event)\"\n  data-ng-model=\"field.value\"\n  data-ng-required=\"field.required\"\n  data-ng-minlength=\"{{field.minlength}}\"\n  data-ng-maxlength=\"{{field.maxlength}}\"\n  data-ng-pattern=\"field.pattern\"\n  data-ng-trim=\"{{field.trim}}\"\n></textarea>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.val value\n\n\n\n\nImplements hook \nshrubFormWidgets\n\n\n  registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'textarea'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-textarea'\n\n    widgets",
            "title": "textarea.coffee"
        },
        {
            "location": "/source/packages/shrub-form/client/widget/textarea/#form-text",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    ->\n\n      scope: field: '=', form: '='\n\n      link: (scope) ->\n\n        scope.$watch 'field', (field) ->\n\n          field.minLength ?= 0\n          field.maxLength ?= Infinity\n          field.pattern ?= /.*/\n          field.model ?= 'field.value'\n\n          field.syncModel scope\n\n      template: '''\n\n<label\n  data-ng-if=\"!!field.label\"\n  data-ng-bind=\"field.label\"\n></label>\n\n<textarea\n  class=\"form-control\"\n  name=\"{{field.name}}\"\n  type=\"{{field.type}}\"\n\n  data-shrub-ui-attributes=\"field.attributes\"\n  data-ng-keypress=\"field.keyPress($event)\"\n  data-ng-model=\"field.value\"\n  data-ng-required=\"field.required\"\n  data-ng-minlength=\"{{field.minlength}}\"\n  data-ng-maxlength=\"{{field.maxlength}}\"\n  data-ng-pattern=\"field.pattern\"\n  data-ng-trim=\"{{field.trim}}\"\n></textarea>\n\n'''\n\n  ]\n\n  assignToElement = (element, value) -> element.val value  Implements hook  shrubFormWidgets    registrar.registerHook 'shrubFormWidgets', ->\n\n    widgets = []\n\n    widgets.push\n\n      type: 'textarea'\n      assignToElement: assignToElement\n      directive: 'shrub-form-widget-textarea'\n\n    widgets",
            "title": "Form - Text"
        },
        {
            "location": "/source/packages/shrub-form/",
            "text": "Form processing\n\n\nHandle form and method parsing, and submission of POST'ed data into the\nAngular sandbox.\n\n\nbodyParser = require 'body-parser'\nmethodOverride = require 'method-override'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularSandboxNavigationMiddleware\n\n\nIf the client made a POST request, inject that request into the Angular\nsandbox and let it do its thing.\n\n\n  registrar.registerHook 'shrubAngularSandboxNavigationMiddleware', ->\n\n    label: 'Handle form submission'\n    middleware: [\n\n      (req, next) ->\n\n        {body, sandbox} = req\n\n\n\n\nMake sure there's a formKey in the submission.\n\n\nTODO: CRSF check needed here.\n\n\n        return next() unless body.formKey?\n\n\n\n\nLookup the cached form.\n\n\n        formService = null\n\n        sandbox.inject [\n          'shrub-form'\n          (form) -> formService = form\n        ]\n\n        return next() unless (formCache = formService.forms[body.formKey])?\n\n        {element, scope} = formCache\n        widgets = formService.widgets\n\n        form = scope.form\n        for k, v of body\n          continue if 'formKey' is k\n\n          element = element.find \"[name='#{k}']\"\n\n          formService.widgets[form.fields[k].type].assignToElement(\n            element\n            v\n          )\n\n          element.trigger 'change'\n\n\n\n\nSubmit the form into Angular.\n\n\n        scope.$digest()\n        scope.$apply ->\n          scope.$shrubSubmit[body.formKey]().finally -> next()\n\n    ]\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\nParse POST submissions, and allow arbitrary method form attribute.\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    express = require 'express'\n\n    label: 'Parse form submissions'\n    middleware: [\n      bodyParser.urlencoded extended: true\n      methodOverride()\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-form/#form-processing",
            "text": "Handle form and method parsing, and submission of POST'ed data into the\nAngular sandbox.  bodyParser = require 'body-parser'\nmethodOverride = require 'method-override'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularSandboxNavigationMiddleware  If the client made a POST request, inject that request into the Angular\nsandbox and let it do its thing.    registrar.registerHook 'shrubAngularSandboxNavigationMiddleware', ->\n\n    label: 'Handle form submission'\n    middleware: [\n\n      (req, next) ->\n\n        {body, sandbox} = req  Make sure there's a formKey in the submission.  TODO: CRSF check needed here.          return next() unless body.formKey?  Lookup the cached form.          formService = null\n\n        sandbox.inject [\n          'shrub-form'\n          (form) -> formService = form\n        ]\n\n        return next() unless (formCache = formService.forms[body.formKey])?\n\n        {element, scope} = formCache\n        widgets = formService.widgets\n\n        form = scope.form\n        for k, v of body\n          continue if 'formKey' is k\n\n          element = element.find \"[name='#{k}']\"\n\n          formService.widgets[form.fields[k].type].assignToElement(\n            element\n            v\n          )\n\n          element.trigger 'change'  Submit the form into Angular.          scope.$digest()\n        scope.$apply ->\n          scope.$shrubSubmit[body.formKey]().finally -> next()\n\n    ]  Implements hook  shrubHttpMiddleware  Parse POST submissions, and allow arbitrary method form attribute.    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    express = require 'express'\n\n    label: 'Parse form submissions'\n    middleware: [\n      bodyParser.urlencoded extended: true\n      methodOverride()\n    ]",
            "title": "Form processing"
        },
        {
            "location": "/source/packages/shrub-grunt/dox/dynamic/",
            "text": "Grunt build process - Dynamic documentation\n\n\n{exec} = require 'child_process'\nfs = require 'fs'\npath = require 'path'\n{Transform} = require 'stream'\n\n_ = require 'lodash'\n{LineStream} = require 'byline'\nglob = require 'grunt/node_modules/glob'\nPromise = require 'bluebird'\n\n\n\n\nImplement a Transform stream to accumulate hook invocations from a source\nfile.\n\n\nclass HookInvocations extends Transform\n\n  constructor: ->\n    super\n\n    @list = []\n\n  _transform: (chunk, encoding, done) ->\n    line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# #### Invoke hook `([^`]+)`/\n      @list.push matches[1]\n\n    done()\n\n\n\n\nImplement a Transform stream to accumulate hook implementations from a\nsource file.\n\n\nclass HookImplementations extends Transform\n\n  constructor: ->\n    super\n\n    @list = []\n\n  _transform: (chunk, encoding, done) ->\n    line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# #### Implements hook `([^`]+)`/\n      @list.push matches[1]\n\n    done()\n\n\n\n\nImplement a Transform stream to accumulate TODOs from a source file. Also\ncaches lines to be able to build context around each TODO item.\n\n\nclass Todos extends Transform\n\n  @context = 4\n\n  constructor: ->\n    super\n\n    @lines = []\n    @todos = []\n\n  _transform: (chunk, encoding, done) ->\n    @lines.push line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# ###### TODO/\n      @todos.push @lines.length - 1\n\n    done()\n\n  withContext: ->\n\n    for todo in @todos\n\n      start = Math.max 0, todo - Todos.context\n      end = Math.min @lines.length - 1, todo + Todos.context\n\n      index: todo\n      lines: @lines.slice start, end\n\n\n\n\nImplement a Transform stream to parse title and description for a file.\n\n\nclass TitleAndDescription extends Transform\n\n  constructor: ->\n    super\n\n    @hasFinishedParsing = false\n\n    @title = ''\n    @description = ''\n\n  _transform: (chunk, encoding, done) ->\n\n    return done() if @hasFinishedParsing\n\n    line = chunk.toString('utf8').trim()\n    return done() if line.length is 0\n\n    if 35 is line.charCodeAt(0)\n\n      if 35 is line.charCodeAt(2)\n        @title = line.substr 4\n\n      else if 42 is line.charCodeAt(2)\n        @description = line.substr 2\n\n      else if @description?\n        @description += ' ' + line.substr 2\n\n      if 42 is @description.charCodeAt @description.length - 1\n        @hasFinishedParsing = true\n\n    else\n\n      @hasFinishedParsing = true\n\n    return done()\n\n\n\n\nImplement a transform stream to convert a .coffee file to .litcoffee\n\n\nclass LitcoffeeConversion extends Transform\n\n  constructor: (@filename) ->\n    super\n\n    @highlight = if @filename.match /\\.(?:lit)?coffee$/\n      'coffeescript'\n    else if @filename.match /\\.js$/\n      'javascript'\n    else\n      'no-highlight'\n\n    @hanging = []\n    @hasWrittenCode = false\n    @commenting = false\n\n    @on 'finish', => @unshift \"```\\n\" if @hasWrittenCode and not @commenting\n\n  _transform: (chunk, encoding, done) ->\n\n    line = chunk.toString 'utf8'\n\n\n\n\nComment.\n\n\n    if '#'.charCodeAt(0) is line.trim().charCodeAt(0)\n\n      @push \"```\\n\\n\" if @hasWrittenCode and not @commenting\n\n      comment = line.trim().substr 2\n\n      matches = comment.match /^#### (I(?:nvoke|mplements)) hook `([^`]+)`/\n      if matches\n\n        parts = path.dirname(@filename).split('/')\n        parts.push '' if 'index.coffee' isnt path.basename @filename\n        backpath = parts.map(-> '..').join '/'\n\n        @push \"#### #{\n          matches[1]\n        } hook [`#{\n          matches[2]\n        }`](#{\n          backpath\n        }/hooks##{\n          matches[2].toLowerCase()\n        })\\n\"\n\n      else\n\n        @push \"#{comment}\\n\"\n\n      @commenting = true\n\n    else\n\n      @hanging = [] if @commenting\n      @push \"\\n```#{@highlight}\\n\" if @commenting or not @hasWrittenCode\n\n      if line.length is 0\n        @hanging.push '' unless @commenting\n      else\n        @push \"\\n\" for blank in @hanging\n        @hanging = []\n        @push \"#{line}\\n\"\n\n      @commenting = false\n      @hasWrittenCode = true\n\n    done()\n\n\n\n\nGather all source files.\n\n\n_allSourceFiles = ->\n  new Promise (resolve, reject) ->\n    glob(\n      '{{client,custom,packages,server}/**/*.{coffee,litcoffee},*.{coffee,litcoffee},config/default.settings.yml}'\n      (error, files) ->\n        return reject error if error?\n        resolve files\n    )\n\n\n\n\nGenerate an HTML ID from a string.\n\n\n_idFromString = (string) -> string.replace(\n  /[/'']/g, ''\n).replace(\n  /\\[(.*)\\]\\(.*\\)/g, '$1'\n).replace(\n  /[^0-9A-Za-z-]+/g, '-'\n).replace(\n  /\\-+/g, '-'\n).toLowerCase()\n\n\n\n\nGet the source path from a filename. This removes the extension and any\n/index portion from the end of the filename.\n\n\n_sourcePath = (filename) ->\n\n    dirname = path.dirname filename\n    if dirname is '.' then dirname = '' else dirname += '/'\n    extname = path.extname filename\n    filename = \"#{dirname}#{path.basename filename, extname}\"\n\n    parts = filename.split '/'\n    parts.pop() if parts[parts.length - 1] is 'index'\n    return parts.join '/'\n\n\n\n\nCollate a list of files by type (client or server).\n\n\n_collateFilesByType = (files) ->\n\n  client = []\n  server = []\n\n  for file in files\n    parts = file.split '/'\n\n    if parts[0] is 'client'\n      client.push file\n    else if parts[0] is 'custom' and parts[2] is 'client'\n      client.push file\n    else if parts[0] is 'packages' and parts[2] is 'client'\n      client.push file\n    else\n      server.push file\n\n  client: client, server: server\n\n\n\n\nAdd all the source files to a generated mkdocs.yml\n\n\ngeneratedFilesPromise = _allSourceFiles().then (files) ->\n\n  promises = for file in files\n    parts = file.split '/'\n\n    for i in [0...parts.length]\n      try\n        fs.mkdirSync \"docs/source/#{parts.slice(0, i).join '/'}\"\n      catch error\n\n    fstream = fs.createReadStream file\n    fstream.pipe lineStream = new LineStream keepEmptyLines: true\n\n\n\n\nConvert to litcoffee.\n\n\n    lineStream.pipe litcoffeeConversion = new LitcoffeeConversion file\n    writeStream = fs.createWriteStream \"docs/source/#{file}\"\n    litcoffeeConversion.pipe writeStream\n\n    new Promise (resolve) -> do (file) ->\n\n      writeStream.on 'close', -> resolve file\n\n  Promise.all promises\n\n\n\n\nGather statistics for all files.\n\n\nfileStatsListPromise = generatedFilesPromise.then (allFiles) ->\n\n  allFilesPromises = for type, files of _collateFilesByType allFiles\n\n    typePromises = for file in files\n\n      do (type, file) -> new Promise (resolve, reject) ->\n\n        fstream = fs.createReadStream file\n        fstream.pipe lineStream = new LineStream keepEmptyLines: true\n\n\n\n\nPass all files through the Transform list to parse out relevant\ninformation.\n\n\n        lineStream.pipe hookImplementations = new HookImplementations()\n        lineStream.pipe hookInvocations = new HookInvocations()\n        lineStream.pipe todos = new Todos()\n        lineStream.pipe titleAndDescription = new TitleAndDescription()\n\n        fstream.on 'error', reject\n\n        fstream.on 'end', ->\n\n\n\n\nInclude all information from Transform streams in the statistics.\n\n\n          resolve(\n            type: type\n            file: file\n            implementations: hookImplementations.list\n            invocations: hookInvocations.list\n            todos: todos.withContext()\n            title: titleAndDescription.title\n            description: titleAndDescription.description\n          )\n\n    Promise.all typePromises\n\n  Promise.all(allFilesPromises).then (fileStatsLists) ->\n    _.flatten fileStatsLists\n\n\n\n\nMassage the statistics to help rendering the hooks page.\n\n\nfileStatsListPromise.then((fileStatsList) ->\n\n  hooksIndex = {}\n\n  indexes = {}\n  keys = ['implementations', 'invocations']\n\n  for fileStats in fileStatsList\n\n    parts = fileStats.file.split '/'\n    for remove in ['client', 'packages']\n      if ~(index = parts.indexOf remove)\n        parts.splice index, 1\n    mergeFile = parts.join '/'\n\n    for key in keys\n      indexes[key] ?= {}\n\n      for hook in fileStats[key]\n        indexes[key][hook] ?= {}\n\n        indexes[key][hook][mergeFile] ?= fullName: fileStats.file\n        (indexes[key][hook][mergeFile].types ?= []).push fileStats.type\n\n        hooksIndex[hook] = true\n\n  for key in keys\n    for hook, stats of indexes[key]\n      for file of stats\n        stats[file].types = _.sortedUniq stats[file].types.sort() ? []\n\n  hooks = (hook for hook of hooksIndex).sort()\n\n  hookFiles = {}\n  for hook in hooks\n    hookFiles[hook] = try\n      fs.readFileSync \"docs/hook/#{hook}.md\", 'utf8'\n    catch error\n      console.error \"Missing hook template for #{hook}\"\n      ''\n\n  O =\n    hookFiles: hookFiles\n    hooks: hooks\n\n  O[key] = indexes[key] for key in keys\n\n  return O\n\n\n\n\nRender the hooks page.\n\n\n).then((O) ->\n\n  {hookFiles, hooks} = O\n\n  keys = ['implementation', 'invocation']\n\n  wordingFor =\n    implementation: 'implements'\n    invocation: 'invoke'\n\n  render = fs.readFileSync 'docs/hooks.template.md', 'utf8'\n\n  for hook in hooks\n\n    render += \"## #{hook}\\n\\n\"\n    render += hookFiles[hook] + '\\n\\n' if hookFiles[hook]\n\n    for key in keys\n      pluralKey = \"#{key}s\"\n\n      if O[pluralKey][hook]?\n\n        count = 0\n        for file, {types} of O[pluralKey][hook]\n          count += types.length\n\n        render += '<div class=\"admonition note\">'\n        render += \"<p class=\\\"admonition-title\\\">#{count} #{key}\"\n        render += 's' if count > 1\n        render += '</p>\\n'\n        render += '  <table>\\n'\n\n        stripe = 0\n        instances = for file, {fullName, types} of O[pluralKey][hook]\n\n\n\n\nRemove client path part, only added when necessary.\n\n\n          parts = fullName.split '/'\n          for remove in ['client']\n            if ~(index = parts.indexOf remove)\n              parts.splice index, 1\n          fullName = parts.join '/'\n\n          parts = file.split '/'\n          for remove in ['client']\n            if ~(index = parts.indexOf remove)\n              parts.splice index, 1\n          file = parts.join '/'\n\n          addClientToFullPath = (isClient, path) ->\n\n            return path unless isClient\n            parts = path.split '/'\n            return path if parts[0] isnt 'packages'\n            parts.splice 2, 0, 'client'\n            parts.join '/'\n\n          do (fullName) -> types = types.map (type) ->\n            \"    <tr class=\\\"#{\n              if stripe++ % 2 then 'odd' else 'even'\n            }\\\"><td><a href=\\\"../source/#{\n              addClientToFullPath type is 'client', _sourcePath fullName\n            }\\\">#{\n              _sourcePath file\n            } (#{\n              type\n            })</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{\n              addClientToFullPath type is 'client', _sourcePath fullName\n            }##{\n              wordingFor[key]\n            }-hook-#{\n              _idFromString hook\n            }\\\">#{\n              key\n            }</a></td></tr>\"\n          types.join ''\n\n        render += instances.join ''\n\n        render += '  </table>\\n'\n        render += '</div>'\n        render += '\\n\\n'\n\n  new Promise (resolve, reject) ->\n    fs.writeFile 'docs/hooks.md', render, (error) ->\n      return reject error if error?\n      resolve()\n\n).done()\n\n\n\n\nRender the TODOs page.\n\n\nfileStatsListPromise.then((fileStatsList) ->\n\n  render = fs.readFileSync 'docs/todos.template.md', 'utf8'\n\n  for fileStats in fileStatsList\n\n\n\n\nKeep track of used IDs, it will be necessary to link to the correct\nlocation hash in the case of multiple TODO items with the same wording.\n\n\n    idMap = {}\n\n    for todo in fileStats.todos\n\n      filename = _sourcePath fileStats.file\n\n      highlight = if fileStats.file.match /\\.(?:lit)?coffee$/\n         'coffeescript'\n      else if fileStats.file.match /\\.js$/\n        'javascript'\n      else\n        'no-highlight'\n\n      render += \"\\n---\\n\\n```#{highlight}\\n\"\n\n      id = ''\n      for line, index in todo.lines\n\n\n\n\nIf this is the line with the TODO, parse the ID from the TODO item\ntext, and render it as h2 (TODO are h6) to increase visibility.\n\n\n        if index is Todos.context\n          id = _idFromString(line).slice 1, -1\n\n          render += \"```\\n\\n#{line.trim().slice 6}\\n\\n```#{highlight}\"\n        else\n          render += line\n        render += '\\n'\n\n      render += '```\\n\\n'\n\n\n\n\nKeep track of ID usage and modify the location hash for subsequent\nuses.\n\n\n      if idMap[id]?\n        idMap[id] += 1\n        id += \"_#{idMap[id]}\"\n      else\n        idMap[id] = 0\n\n      render += \"[the above found in #{\n        fileStats.file\n      }:#{\n        todo.index\n      }](source/#{\n        filename\n      }##{\n        id\n      })\\n\\n\"\n\n  new Promise (resolve, reject) ->\n    fs.writeFile 'docs/todos.md', render, (error) ->\n      return reject error if error?\n      resolve()\n\n).done()\n\n_allSourceFiles().then (files) ->\n\n  yml = fs.readFileSync 'docs/mkdocs.template.yml', 'utf8'\n\n  renderHierarchy = (output, hierarchy) ->\n\n    renderHierarchyInternal = (output, hierarchy, indent) ->\n\n      if _.isString hierarchy\n\n        output[output.length - 1] += \" '#{hierarchy}'\"\n\n      else\n\n        for k, v of hierarchy\n\n          output.push \"#{indent}- #{k}:\"\n          renderHierarchyInternal output, v, \"#{indent}    \"\n\n    renderHierarchyInternal output, hierarchy, ''\n\n  hierarchy = Source: {}\n  for file in files\n    walk = hierarchy.Source\n    parts = file.split '/'\n    for part, i in parts\n      if i is parts.length - 1\n        walk[part] = \"source/#{file}\"\n      else\n        walk[part] ?= {}\n        walk = walk[part]\n\n  output = []\n  renderHierarchy output, hierarchy\n  fs.writeFileSync 'mkdocs.yml', yml + output.join \"\\n\"\n\n\n\n\nRender the packages page.\n\n\nfileStatsListPromise.then((fileStatsList) ->\n\n\n\n\nSort by package name first.\n\n\n  newList = []\n\n  for fileStats in fileStatsList\n\n    parts = fileStats.file.split '/'\n    continue unless ~['custom', 'packages'].indexOf parts[0]\n\n    sourcePath = _sourcePath fileStats.file\n\n    parts = sourcePath.split '/'\n    pkg = parts.join '/'\n    fileStats.pkg = pkg.split('/').slice(1).join '/'\n\n    newList.push fileStats\n\n  newList.sort (l, r) ->\n    return -1 if l.type is 'client' and r.type is 'server'\n    return 1 if l.type is 'server' and r.type is 'client'\n    if l.pkg < r.pkg then -1 else if l.pkg > r.pkg then 1 else 0\n\n).then((fileStatsList) ->\n\n  render = fs.readFileSync 'docs/packages.template.md', 'utf8'\n  render += '\\n'\n\n  type = null\n\n  for fileStats in fileStatsList\n\n    if fileStats.type isnt type\n      type = fileStats.type\n\n      render += if type is 'client'\n        '## Client-side'\n      else\n        '## Server-side'\n\n      render += '\\n\\n'\n\n    pkgParts = fileStats.pkg.split '/'\n    isSubpackage = pkgParts.length isnt 1 and pkgParts.pop() isnt 'client'\n\n\n\n\nLink to the package.\n\n\n    sourcePath = _sourcePath fileStats.file\n\n    if isSubpackage\n      render += '> '\n      parts = fileStats.pkg.split '/'\n      parentPkg = parts.shift()\n      subPkg = parts.join '/'\n      render += \"## [<small>#{parentPkg}/</small>#{subPkg}](source/#{sourcePath})\"\n    else\n      render += \"## [#{fileStats.pkg}](source/#{sourcePath})\"\n\n    if fileStats.title?\n      render += '\\n\\n'\n      render += '> ' if isSubpackage\n      render += \"<span class=\\\"package-title\\\">#{fileStats.title}</span>\"\n\n    render += '\\n\\n'\n\n    if fileStats.description?\n      render += '> ' if isSubpackage\n      render += \"#{fileStats.description}\\n\\n\"\n\n    if fileStats.implementations.length > 0\n      render += '> ' if isSubpackage\n      render += '<div class=\"admonition note\">'\n      render += '<p class=\"admonition-title\">Implements hooks</p>'\n      render += '  <table>\\n'\n      render += fileStats.implementations.map((hook, index) ->\n        \"    <tr class=\\\"#{if index % 2 then 'odd' else 'even'}\\\"><td><a href=\\\"../hooks/##{_idFromString hook}\\\">#{hook}</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{sourcePath}#implements-hook-#{hook.toLowerCase()}\\\">implementation</a></td></tr>\\n\"\n      ).join ''\n      render += '  </table>\\n'\n      render += '</div>'\n      render += '\\n\\n'\n\n    if fileStats.invocations.length > 0\n\n\n\n\n  render += '> ' if isSubpackage\n  render += '<div class=\"admonition note\">'\n  render += '<p class=\"admonition-title\">Invokes hooks</p>'\n  render += '  <table>\\n'\n  render += fileStats.invocations.map((hook, index) ->\n    \"    <tr class=\\\"#{if index % 2 then 'odd' else 'even'}\\\"><td><a href=\\\"../hooks/##{_idFromString hook}\\\">#{hook}</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{sourcePath}#invoke-hook-#{hook.toLowerCase()}\\\">invocation</a></td></tr>\\n\"\n  ).join ''\n  render += '  </table>\\n'\n  render += '</div>'\n  render += '\\n\\n'\n\n\n\nfs.writeFileSync 'docs/packages.md', render\n\n\n)",
            "title": "dynamic.coffee"
        },
        {
            "location": "/source/packages/shrub-grunt/dox/dynamic/#grunt-build-process-dynamic-documentation",
            "text": "{exec} = require 'child_process'\nfs = require 'fs'\npath = require 'path'\n{Transform} = require 'stream'\n\n_ = require 'lodash'\n{LineStream} = require 'byline'\nglob = require 'grunt/node_modules/glob'\nPromise = require 'bluebird'  Implement a Transform stream to accumulate hook invocations from a source\nfile.  class HookInvocations extends Transform\n\n  constructor: ->\n    super\n\n    @list = []\n\n  _transform: (chunk, encoding, done) ->\n    line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# #### Invoke hook `([^`]+)`/\n      @list.push matches[1]\n\n    done()  Implement a Transform stream to accumulate hook implementations from a\nsource file.  class HookImplementations extends Transform\n\n  constructor: ->\n    super\n\n    @list = []\n\n  _transform: (chunk, encoding, done) ->\n    line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# #### Implements hook `([^`]+)`/\n      @list.push matches[1]\n\n    done()  Implement a Transform stream to accumulate TODOs from a source file. Also\ncaches lines to be able to build context around each TODO item.  class Todos extends Transform\n\n  @context = 4\n\n  constructor: ->\n    super\n\n    @lines = []\n    @todos = []\n\n  _transform: (chunk, encoding, done) ->\n    @lines.push line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# ###### TODO/\n      @todos.push @lines.length - 1\n\n    done()\n\n  withContext: ->\n\n    for todo in @todos\n\n      start = Math.max 0, todo - Todos.context\n      end = Math.min @lines.length - 1, todo + Todos.context\n\n      index: todo\n      lines: @lines.slice start, end  Implement a Transform stream to parse title and description for a file.  class TitleAndDescription extends Transform\n\n  constructor: ->\n    super\n\n    @hasFinishedParsing = false\n\n    @title = ''\n    @description = ''\n\n  _transform: (chunk, encoding, done) ->\n\n    return done() if @hasFinishedParsing\n\n    line = chunk.toString('utf8').trim()\n    return done() if line.length is 0\n\n    if 35 is line.charCodeAt(0)\n\n      if 35 is line.charCodeAt(2)\n        @title = line.substr 4\n\n      else if 42 is line.charCodeAt(2)\n        @description = line.substr 2\n\n      else if @description?\n        @description += ' ' + line.substr 2\n\n      if 42 is @description.charCodeAt @description.length - 1\n        @hasFinishedParsing = true\n\n    else\n\n      @hasFinishedParsing = true\n\n    return done()  Implement a transform stream to convert a .coffee file to .litcoffee  class LitcoffeeConversion extends Transform\n\n  constructor: (@filename) ->\n    super\n\n    @highlight = if @filename.match /\\.(?:lit)?coffee$/\n      'coffeescript'\n    else if @filename.match /\\.js$/\n      'javascript'\n    else\n      'no-highlight'\n\n    @hanging = []\n    @hasWrittenCode = false\n    @commenting = false\n\n    @on 'finish', => @unshift \"```\\n\" if @hasWrittenCode and not @commenting\n\n  _transform: (chunk, encoding, done) ->\n\n    line = chunk.toString 'utf8'  Comment.      if '#'.charCodeAt(0) is line.trim().charCodeAt(0)\n\n      @push \"```\\n\\n\" if @hasWrittenCode and not @commenting\n\n      comment = line.trim().substr 2\n\n      matches = comment.match /^#### (I(?:nvoke|mplements)) hook `([^`]+)`/\n      if matches\n\n        parts = path.dirname(@filename).split('/')\n        parts.push '' if 'index.coffee' isnt path.basename @filename\n        backpath = parts.map(-> '..').join '/'\n\n        @push \"#### #{\n          matches[1]\n        } hook [`#{\n          matches[2]\n        }`](#{\n          backpath\n        }/hooks##{\n          matches[2].toLowerCase()\n        })\\n\"\n\n      else\n\n        @push \"#{comment}\\n\"\n\n      @commenting = true\n\n    else\n\n      @hanging = [] if @commenting\n      @push \"\\n```#{@highlight}\\n\" if @commenting or not @hasWrittenCode\n\n      if line.length is 0\n        @hanging.push '' unless @commenting\n      else\n        @push \"\\n\" for blank in @hanging\n        @hanging = []\n        @push \"#{line}\\n\"\n\n      @commenting = false\n      @hasWrittenCode = true\n\n    done()  Gather all source files.  _allSourceFiles = ->\n  new Promise (resolve, reject) ->\n    glob(\n      '{{client,custom,packages,server}/**/*.{coffee,litcoffee},*.{coffee,litcoffee},config/default.settings.yml}'\n      (error, files) ->\n        return reject error if error?\n        resolve files\n    )  Generate an HTML ID from a string.  _idFromString = (string) -> string.replace(\n  /[/'']/g, ''\n).replace(\n  /\\[(.*)\\]\\(.*\\)/g, '$1'\n).replace(\n  /[^0-9A-Za-z-]+/g, '-'\n).replace(\n  /\\-+/g, '-'\n).toLowerCase()  Get the source path from a filename. This removes the extension and any\n/index portion from the end of the filename.  _sourcePath = (filename) ->\n\n    dirname = path.dirname filename\n    if dirname is '.' then dirname = '' else dirname += '/'\n    extname = path.extname filename\n    filename = \"#{dirname}#{path.basename filename, extname}\"\n\n    parts = filename.split '/'\n    parts.pop() if parts[parts.length - 1] is 'index'\n    return parts.join '/'  Collate a list of files by type (client or server).  _collateFilesByType = (files) ->\n\n  client = []\n  server = []\n\n  for file in files\n    parts = file.split '/'\n\n    if parts[0] is 'client'\n      client.push file\n    else if parts[0] is 'custom' and parts[2] is 'client'\n      client.push file\n    else if parts[0] is 'packages' and parts[2] is 'client'\n      client.push file\n    else\n      server.push file\n\n  client: client, server: server  Add all the source files to a generated mkdocs.yml  generatedFilesPromise = _allSourceFiles().then (files) ->\n\n  promises = for file in files\n    parts = file.split '/'\n\n    for i in [0...parts.length]\n      try\n        fs.mkdirSync \"docs/source/#{parts.slice(0, i).join '/'}\"\n      catch error\n\n    fstream = fs.createReadStream file\n    fstream.pipe lineStream = new LineStream keepEmptyLines: true  Convert to litcoffee.      lineStream.pipe litcoffeeConversion = new LitcoffeeConversion file\n    writeStream = fs.createWriteStream \"docs/source/#{file}\"\n    litcoffeeConversion.pipe writeStream\n\n    new Promise (resolve) -> do (file) ->\n\n      writeStream.on 'close', -> resolve file\n\n  Promise.all promises  Gather statistics for all files.  fileStatsListPromise = generatedFilesPromise.then (allFiles) ->\n\n  allFilesPromises = for type, files of _collateFilesByType allFiles\n\n    typePromises = for file in files\n\n      do (type, file) -> new Promise (resolve, reject) ->\n\n        fstream = fs.createReadStream file\n        fstream.pipe lineStream = new LineStream keepEmptyLines: true  Pass all files through the Transform list to parse out relevant\ninformation.          lineStream.pipe hookImplementations = new HookImplementations()\n        lineStream.pipe hookInvocations = new HookInvocations()\n        lineStream.pipe todos = new Todos()\n        lineStream.pipe titleAndDescription = new TitleAndDescription()\n\n        fstream.on 'error', reject\n\n        fstream.on 'end', ->  Include all information from Transform streams in the statistics.            resolve(\n            type: type\n            file: file\n            implementations: hookImplementations.list\n            invocations: hookInvocations.list\n            todos: todos.withContext()\n            title: titleAndDescription.title\n            description: titleAndDescription.description\n          )\n\n    Promise.all typePromises\n\n  Promise.all(allFilesPromises).then (fileStatsLists) ->\n    _.flatten fileStatsLists  Massage the statistics to help rendering the hooks page.  fileStatsListPromise.then((fileStatsList) ->\n\n  hooksIndex = {}\n\n  indexes = {}\n  keys = ['implementations', 'invocations']\n\n  for fileStats in fileStatsList\n\n    parts = fileStats.file.split '/'\n    for remove in ['client', 'packages']\n      if ~(index = parts.indexOf remove)\n        parts.splice index, 1\n    mergeFile = parts.join '/'\n\n    for key in keys\n      indexes[key] ?= {}\n\n      for hook in fileStats[key]\n        indexes[key][hook] ?= {}\n\n        indexes[key][hook][mergeFile] ?= fullName: fileStats.file\n        (indexes[key][hook][mergeFile].types ?= []).push fileStats.type\n\n        hooksIndex[hook] = true\n\n  for key in keys\n    for hook, stats of indexes[key]\n      for file of stats\n        stats[file].types = _.sortedUniq stats[file].types.sort() ? []\n\n  hooks = (hook for hook of hooksIndex).sort()\n\n  hookFiles = {}\n  for hook in hooks\n    hookFiles[hook] = try\n      fs.readFileSync \"docs/hook/#{hook}.md\", 'utf8'\n    catch error\n      console.error \"Missing hook template for #{hook}\"\n      ''\n\n  O =\n    hookFiles: hookFiles\n    hooks: hooks\n\n  O[key] = indexes[key] for key in keys\n\n  return O  Render the hooks page.  ).then((O) ->\n\n  {hookFiles, hooks} = O\n\n  keys = ['implementation', 'invocation']\n\n  wordingFor =\n    implementation: 'implements'\n    invocation: 'invoke'\n\n  render = fs.readFileSync 'docs/hooks.template.md', 'utf8'\n\n  for hook in hooks\n\n    render += \"## #{hook}\\n\\n\"\n    render += hookFiles[hook] + '\\n\\n' if hookFiles[hook]\n\n    for key in keys\n      pluralKey = \"#{key}s\"\n\n      if O[pluralKey][hook]?\n\n        count = 0\n        for file, {types} of O[pluralKey][hook]\n          count += types.length\n\n        render += '<div class=\"admonition note\">'\n        render += \"<p class=\\\"admonition-title\\\">#{count} #{key}\"\n        render += 's' if count > 1\n        render += '</p>\\n'\n        render += '  <table>\\n'\n\n        stripe = 0\n        instances = for file, {fullName, types} of O[pluralKey][hook]  Remove client path part, only added when necessary.            parts = fullName.split '/'\n          for remove in ['client']\n            if ~(index = parts.indexOf remove)\n              parts.splice index, 1\n          fullName = parts.join '/'\n\n          parts = file.split '/'\n          for remove in ['client']\n            if ~(index = parts.indexOf remove)\n              parts.splice index, 1\n          file = parts.join '/'\n\n          addClientToFullPath = (isClient, path) ->\n\n            return path unless isClient\n            parts = path.split '/'\n            return path if parts[0] isnt 'packages'\n            parts.splice 2, 0, 'client'\n            parts.join '/'\n\n          do (fullName) -> types = types.map (type) ->\n            \"    <tr class=\\\"#{\n              if stripe++ % 2 then 'odd' else 'even'\n            }\\\"><td><a href=\\\"../source/#{\n              addClientToFullPath type is 'client', _sourcePath fullName\n            }\\\">#{\n              _sourcePath file\n            } (#{\n              type\n            })</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{\n              addClientToFullPath type is 'client', _sourcePath fullName\n            }##{\n              wordingFor[key]\n            }-hook-#{\n              _idFromString hook\n            }\\\">#{\n              key\n            }</a></td></tr>\"\n          types.join ''\n\n        render += instances.join ''\n\n        render += '  </table>\\n'\n        render += '</div>'\n        render += '\\n\\n'\n\n  new Promise (resolve, reject) ->\n    fs.writeFile 'docs/hooks.md', render, (error) ->\n      return reject error if error?\n      resolve()\n\n).done()  Render the TODOs page.  fileStatsListPromise.then((fileStatsList) ->\n\n  render = fs.readFileSync 'docs/todos.template.md', 'utf8'\n\n  for fileStats in fileStatsList  Keep track of used IDs, it will be necessary to link to the correct\nlocation hash in the case of multiple TODO items with the same wording.      idMap = {}\n\n    for todo in fileStats.todos\n\n      filename = _sourcePath fileStats.file\n\n      highlight = if fileStats.file.match /\\.(?:lit)?coffee$/\n         'coffeescript'\n      else if fileStats.file.match /\\.js$/\n        'javascript'\n      else\n        'no-highlight'\n\n      render += \"\\n---\\n\\n```#{highlight}\\n\"\n\n      id = ''\n      for line, index in todo.lines  If this is the line with the TODO, parse the ID from the TODO item\ntext, and render it as h2 (TODO are h6) to increase visibility.          if index is Todos.context\n          id = _idFromString(line).slice 1, -1\n\n          render += \"```\\n\\n#{line.trim().slice 6}\\n\\n```#{highlight}\"\n        else\n          render += line\n        render += '\\n'\n\n      render += '```\\n\\n'  Keep track of ID usage and modify the location hash for subsequent\nuses.        if idMap[id]?\n        idMap[id] += 1\n        id += \"_#{idMap[id]}\"\n      else\n        idMap[id] = 0\n\n      render += \"[the above found in #{\n        fileStats.file\n      }:#{\n        todo.index\n      }](source/#{\n        filename\n      }##{\n        id\n      })\\n\\n\"\n\n  new Promise (resolve, reject) ->\n    fs.writeFile 'docs/todos.md', render, (error) ->\n      return reject error if error?\n      resolve()\n\n).done()\n\n_allSourceFiles().then (files) ->\n\n  yml = fs.readFileSync 'docs/mkdocs.template.yml', 'utf8'\n\n  renderHierarchy = (output, hierarchy) ->\n\n    renderHierarchyInternal = (output, hierarchy, indent) ->\n\n      if _.isString hierarchy\n\n        output[output.length - 1] += \" '#{hierarchy}'\"\n\n      else\n\n        for k, v of hierarchy\n\n          output.push \"#{indent}- #{k}:\"\n          renderHierarchyInternal output, v, \"#{indent}    \"\n\n    renderHierarchyInternal output, hierarchy, ''\n\n  hierarchy = Source: {}\n  for file in files\n    walk = hierarchy.Source\n    parts = file.split '/'\n    for part, i in parts\n      if i is parts.length - 1\n        walk[part] = \"source/#{file}\"\n      else\n        walk[part] ?= {}\n        walk = walk[part]\n\n  output = []\n  renderHierarchy output, hierarchy\n  fs.writeFileSync 'mkdocs.yml', yml + output.join \"\\n\"  Render the packages page.  fileStatsListPromise.then((fileStatsList) ->  Sort by package name first.    newList = []\n\n  for fileStats in fileStatsList\n\n    parts = fileStats.file.split '/'\n    continue unless ~['custom', 'packages'].indexOf parts[0]\n\n    sourcePath = _sourcePath fileStats.file\n\n    parts = sourcePath.split '/'\n    pkg = parts.join '/'\n    fileStats.pkg = pkg.split('/').slice(1).join '/'\n\n    newList.push fileStats\n\n  newList.sort (l, r) ->\n    return -1 if l.type is 'client' and r.type is 'server'\n    return 1 if l.type is 'server' and r.type is 'client'\n    if l.pkg < r.pkg then -1 else if l.pkg > r.pkg then 1 else 0\n\n).then((fileStatsList) ->\n\n  render = fs.readFileSync 'docs/packages.template.md', 'utf8'\n  render += '\\n'\n\n  type = null\n\n  for fileStats in fileStatsList\n\n    if fileStats.type isnt type\n      type = fileStats.type\n\n      render += if type is 'client'\n        '## Client-side'\n      else\n        '## Server-side'\n\n      render += '\\n\\n'\n\n    pkgParts = fileStats.pkg.split '/'\n    isSubpackage = pkgParts.length isnt 1 and pkgParts.pop() isnt 'client'  Link to the package.      sourcePath = _sourcePath fileStats.file\n\n    if isSubpackage\n      render += '> '\n      parts = fileStats.pkg.split '/'\n      parentPkg = parts.shift()\n      subPkg = parts.join '/'\n      render += \"## [<small>#{parentPkg}/</small>#{subPkg}](source/#{sourcePath})\"\n    else\n      render += \"## [#{fileStats.pkg}](source/#{sourcePath})\"\n\n    if fileStats.title?\n      render += '\\n\\n'\n      render += '> ' if isSubpackage\n      render += \"<span class=\\\"package-title\\\">#{fileStats.title}</span>\"\n\n    render += '\\n\\n'\n\n    if fileStats.description?\n      render += '> ' if isSubpackage\n      render += \"#{fileStats.description}\\n\\n\"\n\n    if fileStats.implementations.length > 0\n      render += '> ' if isSubpackage\n      render += '<div class=\"admonition note\">'\n      render += '<p class=\"admonition-title\">Implements hooks</p>'\n      render += '  <table>\\n'\n      render += fileStats.implementations.map((hook, index) ->\n        \"    <tr class=\\\"#{if index % 2 then 'odd' else 'even'}\\\"><td><a href=\\\"../hooks/##{_idFromString hook}\\\">#{hook}</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{sourcePath}#implements-hook-#{hook.toLowerCase()}\\\">implementation</a></td></tr>\\n\"\n      ).join ''\n      render += '  </table>\\n'\n      render += '</div>'\n      render += '\\n\\n'\n\n    if fileStats.invocations.length > 0    render += '> ' if isSubpackage\n  render += '<div class=\"admonition note\">'\n  render += '<p class=\"admonition-title\">Invokes hooks</p>'\n  render += '  <table>\\n'\n  render += fileStats.invocations.map((hook, index) ->\n    \"    <tr class=\\\"#{if index % 2 then 'odd' else 'even'}\\\"><td><a href=\\\"../hooks/##{_idFromString hook}\\\">#{hook}</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{sourcePath}#invoke-hook-#{hook.toLowerCase()}\\\">invocation</a></td></tr>\\n\"\n  ).join ''\n  render += '  </table>\\n'\n  render += '</div>'\n  render += '\\n\\n'  fs.writeFileSync 'docs/packages.md', render  )",
            "title": "Grunt build process - Dynamic documentation"
        },
        {
            "location": "/source/packages/shrub-grunt/dox/",
            "text": "Grunt build process - Documentation\n\n\nBuild the documentation in \ngh-pages\n.\n\n\n{fork, spawn} = require 'child_process'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig, grunt) ->\n\n    gruntConfig.configureTask 'clean', 'dox', [\n      'mkdocs.yml'\n      'docs/source'\n      'docs/{hooks,packages,todos}.md'\n      'gh-pages/*'\n      '!gh-pages/.git'\n      '!gh-pages/.gitignore'\n    ]\n\n    gruntConfig.registerTask 'dox:prepareDirectory', ->\n      grunt.file.mkdir 'gh-pages'\n\n    gruntConfig.registerTask 'dox:dynamic', ->\n      done = @async()\n\n      fork(\"#{__dirname}/dynamic.coffee\").on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Dynamic documentation generation failed', code\n\n    gruntConfig.registerTask 'dox:mkdocs', ->\n      done = @async()\n\n      spawn('mkdocs', ['build']).on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Running `mkdocs build` failed', code\n\n    gruntConfig.registerTask 'dox', [\n       'dox:prepareDirectory'\n       'dox:dynamic'\n       'dox:mkdocs'\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-grunt/dox/#grunt-build-process-documentation",
            "text": "Build the documentation in  gh-pages .  {fork, spawn} = require 'child_process'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig, grunt) ->\n\n    gruntConfig.configureTask 'clean', 'dox', [\n      'mkdocs.yml'\n      'docs/source'\n      'docs/{hooks,packages,todos}.md'\n      'gh-pages/*'\n      '!gh-pages/.git'\n      '!gh-pages/.gitignore'\n    ]\n\n    gruntConfig.registerTask 'dox:prepareDirectory', ->\n      grunt.file.mkdir 'gh-pages'\n\n    gruntConfig.registerTask 'dox:dynamic', ->\n      done = @async()\n\n      fork(\"#{__dirname}/dynamic.coffee\").on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Dynamic documentation generation failed', code\n\n    gruntConfig.registerTask 'dox:mkdocs', ->\n      done = @async()\n\n      spawn('mkdocs', ['build']).on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Running `mkdocs build` failed', code\n\n    gruntConfig.registerTask 'dox', [\n       'dox:prepareDirectory'\n       'dox:dynamic'\n       'dox:mkdocs'\n    ]",
            "title": "Grunt build process - Documentation"
        },
        {
            "location": "/source/packages/shrub-grunt/",
            "text": "Grunt build process\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAssetsMiddleware\n\n\n  registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Livereload'\n    middleware: [\n\n      (assets, next) ->\n\n        return next() if 'production' is config.get 'NODE_ENV'\n\n        hostname = config.get 'packageConfig:shrub-core:siteHostname'\n        [hostname] = hostname.split ':'\n        assets.scripts.push \"http://#{hostname}:35729/livereload.js\"\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubConfigClientAlter\n\n\n  registrar.registerHook 'shrubConfigClientAlter', (req, config_) ->\n    return unless req.grunt?\n\n    config_.set 'packageConfig:shrub-socket', manager: module: 'shrub-socket/dummy'\n    config_.set 'packageConfig:shrub-user', name: 'Anonymous'\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig, grunt) ->\n\n    gruntConfig.configureTask 'clean', 'shrub', [\n      'app'\n      'build'\n    ]\n\n    gruntConfig.configureTask 'concat', 'shrub', files: [\n      src: [\n        'build/js/app/{app-bundled,modules}.js'\n      ]\n      dest: 'app/lib/shrub/shrub.js'\n    ]\n\n    gruntConfig.configureTask 'uglify', 'shrub', files: [\n      src: [\n        'app/lib/shrub/shrub.js'\n      ]\n      dest: 'app/lib/shrub/shrub.min.js'\n    ]\n\n    gruntConfig.registerTask 'executeFunction:shrub', ->\n      done = @async()\n\n\n\n\nPass arguments to the child process.\n\n\n      args = process.argv.slice 2\n\n\n\n\nPass the environment to the child process.\n\n\n      options = env: process.env\n\n\n\n\nFork it.\n\n\n      {fork} = require 'child_process'\n      child = fork \"#{__dirname}/../../server.coffee\", args, options\n      child.on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Server process failed', code\n\n    gruntConfig.registerTask 'build:shrub', [\n      'concat:shrub'\n    ]\n\n    gruntConfig.registerTask 'production:shrub', [\n      'newer:uglify:shrub'\n    ]\n\n    gruntConfig.registerTask 'execute', [\n      'buildOnce'\n      'executeFunction:shrub'\n    ]\n\n    gruntConfig.loadNpmTasks [\n      'grunt-browserify'\n      'grunt-contrib-clean'\n      'grunt-contrib-coffee'\n      'grunt-contrib-concat'\n      'grunt-contrib-copy'\n      'grunt-contrib-uglify'\n      'grunt-contrib-watch'\n      'grunt-newer'\n      'grunt-wrap'\n    ]\n\n\n\n\nImplements hook \nshrubGruntConfigAlter\n\n\n  registrar.registerHook 'shrubGruntConfigAlter', (gruntConfig) ->\n\n    gruntConfig.registerTask 'build', [\n      'build:shrub'\n    ]\n\n    gruntConfig.registerTask 'production', [\n      'production:shrub'\n    ]\n\n  registrar.recur [\n    'dox', 'lint', 'modules', 'tests'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-grunt/#grunt-build-process",
            "text": "config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAssetsMiddleware    registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Livereload'\n    middleware: [\n\n      (assets, next) ->\n\n        return next() if 'production' is config.get 'NODE_ENV'\n\n        hostname = config.get 'packageConfig:shrub-core:siteHostname'\n        [hostname] = hostname.split ':'\n        assets.scripts.push \"http://#{hostname}:35729/livereload.js\"\n\n        next()\n\n    ]  Implements hook  shrubConfigClientAlter    registrar.registerHook 'shrubConfigClientAlter', (req, config_) ->\n    return unless req.grunt?\n\n    config_.set 'packageConfig:shrub-socket', manager: module: 'shrub-socket/dummy'\n    config_.set 'packageConfig:shrub-user', name: 'Anonymous'  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig, grunt) ->\n\n    gruntConfig.configureTask 'clean', 'shrub', [\n      'app'\n      'build'\n    ]\n\n    gruntConfig.configureTask 'concat', 'shrub', files: [\n      src: [\n        'build/js/app/{app-bundled,modules}.js'\n      ]\n      dest: 'app/lib/shrub/shrub.js'\n    ]\n\n    gruntConfig.configureTask 'uglify', 'shrub', files: [\n      src: [\n        'app/lib/shrub/shrub.js'\n      ]\n      dest: 'app/lib/shrub/shrub.min.js'\n    ]\n\n    gruntConfig.registerTask 'executeFunction:shrub', ->\n      done = @async()  Pass arguments to the child process.        args = process.argv.slice 2  Pass the environment to the child process.        options = env: process.env  Fork it.        {fork} = require 'child_process'\n      child = fork \"#{__dirname}/../../server.coffee\", args, options\n      child.on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Server process failed', code\n\n    gruntConfig.registerTask 'build:shrub', [\n      'concat:shrub'\n    ]\n\n    gruntConfig.registerTask 'production:shrub', [\n      'newer:uglify:shrub'\n    ]\n\n    gruntConfig.registerTask 'execute', [\n      'buildOnce'\n      'executeFunction:shrub'\n    ]\n\n    gruntConfig.loadNpmTasks [\n      'grunt-browserify'\n      'grunt-contrib-clean'\n      'grunt-contrib-coffee'\n      'grunt-contrib-concat'\n      'grunt-contrib-copy'\n      'grunt-contrib-uglify'\n      'grunt-contrib-watch'\n      'grunt-newer'\n      'grunt-wrap'\n    ]  Implements hook  shrubGruntConfigAlter    registrar.registerHook 'shrubGruntConfigAlter', (gruntConfig) ->\n\n    gruntConfig.registerTask 'build', [\n      'build:shrub'\n    ]\n\n    gruntConfig.registerTask 'production', [\n      'production:shrub'\n    ]\n\n  registrar.recur [\n    'dox', 'lint', 'modules', 'tests'\n  ]",
            "title": "Grunt build process"
        },
        {
            "location": "/source/packages/shrub-grunt/lint/",
            "text": "Grunt build process - (de)Linting\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.configureTask(\n      'coffeelint', 'shrub'\n\n      files: [\n        src: [\n          '**/*.{coffee,litcoffee}'\n          '!node_modules/**/*.{coffee,litcoffee}'\n        ]\n      ]\n      options:\n\n        arrow_spacing: level: 'error'\n\n        camel_case_classes: level: 'error'\n\n        coffeescript_error: level: 'error'\n\n        colon_assignment_spacing:\n          level: 'error'\n          spacing:\n            left: 0\n            right: 1\n\n        cyclomatic_complexity:\n          value: 10\n          level: 'ignore'\n\n        duplicate_key: level: 'error'\n\n        empty_constructor_needs_parens: level: 'ignore'\n\n        ensure_comprehensions: level: 'warn'\n\n        line_endings:\n          level: 'ignore'\n          value: 'unix'\n\n        max_line_length:\n          value: 80\n          level: 'ignore'\n          limitcOmments: true\n\n        missing_fat_arrows:\n          level: 'ignore'\n\n        newlines_after_classes:\n          value: 3\n          level: 'ignore'\n\n        no_backticks: level: 'warn'\n\n        no_debugger: level: 'warn'\n\n        no_empty_functions: level: 'ignore'\n\n        no_empty_param_list: level: 'error'\n\n        no_implicit_braces:\n          level: 'ignore'\n          strict: true\n\n        no_implicit_parens:\n          strict: true\n          level: 'ignore'\n\n        no_interpolation_in_single_quotes: level: 'ignore'\n\n        no_plusplus: level: 'ignore'\n\n        no_stand_alone_at: level: 'error'\n\n        no_throwing_strings: level: 'error'\n\n        no_trailing_semicolons: level: 'error'\n\n        no_trailing_whitespace:\n          level: 'error'\n          allowed_in_comments: false\n          allowed_in_empty_lines: true\n\n        no_unnecessary_double_quotes: level: 'warn'\n\n        no_unnecessary_fat_arrows: level: 'error'\n\n        non_empty_constructor_needs_parens: level: 'ignore'\n\n        prefer_english_operator:\n          level: 'error'\n          doubleNotLevel: 'ignore'\n\n        space_operators: level: 'error'\n\n        spacing_after_comma: level: 'error'\n\n        transform_messes_up_line_numbers: level: 'warn'\n\n    )\n\n    gruntConfig.registerTask 'lint', [\n      'coffeelint:shrub'\n    ]\n\n    gruntConfig.loadNpmTasks ['grunt-coffeelint']",
            "title": "lint.coffee"
        },
        {
            "location": "/source/packages/shrub-grunt/lint/#grunt-build-process-delinting",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.configureTask(\n      'coffeelint', 'shrub'\n\n      files: [\n        src: [\n          '**/*.{coffee,litcoffee}'\n          '!node_modules/**/*.{coffee,litcoffee}'\n        ]\n      ]\n      options:\n\n        arrow_spacing: level: 'error'\n\n        camel_case_classes: level: 'error'\n\n        coffeescript_error: level: 'error'\n\n        colon_assignment_spacing:\n          level: 'error'\n          spacing:\n            left: 0\n            right: 1\n\n        cyclomatic_complexity:\n          value: 10\n          level: 'ignore'\n\n        duplicate_key: level: 'error'\n\n        empty_constructor_needs_parens: level: 'ignore'\n\n        ensure_comprehensions: level: 'warn'\n\n        line_endings:\n          level: 'ignore'\n          value: 'unix'\n\n        max_line_length:\n          value: 80\n          level: 'ignore'\n          limitcOmments: true\n\n        missing_fat_arrows:\n          level: 'ignore'\n\n        newlines_after_classes:\n          value: 3\n          level: 'ignore'\n\n        no_backticks: level: 'warn'\n\n        no_debugger: level: 'warn'\n\n        no_empty_functions: level: 'ignore'\n\n        no_empty_param_list: level: 'error'\n\n        no_implicit_braces:\n          level: 'ignore'\n          strict: true\n\n        no_implicit_parens:\n          strict: true\n          level: 'ignore'\n\n        no_interpolation_in_single_quotes: level: 'ignore'\n\n        no_plusplus: level: 'ignore'\n\n        no_stand_alone_at: level: 'error'\n\n        no_throwing_strings: level: 'error'\n\n        no_trailing_semicolons: level: 'error'\n\n        no_trailing_whitespace:\n          level: 'error'\n          allowed_in_comments: false\n          allowed_in_empty_lines: true\n\n        no_unnecessary_double_quotes: level: 'warn'\n\n        no_unnecessary_fat_arrows: level: 'error'\n\n        non_empty_constructor_needs_parens: level: 'ignore'\n\n        prefer_english_operator:\n          level: 'error'\n          doubleNotLevel: 'ignore'\n\n        space_operators: level: 'error'\n\n        spacing_after_comma: level: 'error'\n\n        transform_messes_up_line_numbers: level: 'warn'\n\n    )\n\n    gruntConfig.registerTask 'lint', [\n      'coffeelint:shrub'\n    ]\n\n    gruntConfig.loadNpmTasks ['grunt-coffeelint']",
            "title": "Grunt build process - (de)Linting"
        },
        {
            "location": "/source/packages/shrub-grunt/modules/",
            "text": "Grunt build process - Modules\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.configureTask 'browserify', 'shrub-debug', {\n      src: ['node_modules/debug/browser.js']\n      dest: 'build/js/app/modules/debug.js'\n      options: browserifyOptions: standalone: 'debug'\n    }\n\n    gruntConfig.configureTask 'browserify', 'shrub-inflection', {\n      src: ['node_modules/inflection/lib/inflection.js']\n      dest: 'build/js/app/modules/inflection.js'\n      options: browserifyOptions: standalone: 'inflection'\n    }\n\n    gruntConfig.configureTask 'browserify', 'shrub-path', {\n      src: ['node_modules/path-browserify/index.js']\n      dest: 'build/js/app/modules/path.js'\n      options: browserifyOptions: standalone: 'path'\n    }\n\n    gruntConfig.configureTask 'coffee', 'modules', files: [\n      cwd: 'client'\n      src: [\n        'packages.coffee'\n        'require.coffee'\n        'modules/**/*.{coffee,litcoffee}'\n      ]\n      dest: 'build/js/app'\n      expand: true\n      ext: '.js'\n    ,\n      src: [\n        '{custom,packages}/*/client/**/*.{coffee,litcoffee}'\n      ]\n      dest: 'build/js/app'\n      expand: true\n      ext: '.js'\n    ]\n\n    gruntConfig.configureTask 'concat', 'modules', files: [\n      src: [\n        'build/js/app/{modules,packages,require}.js'\n      ]\n      dest: 'build/js/app/modules.js'\n    ]\n\n    gruntConfig.configureTask 'copy', 'modules', files: [\n      expand: true\n      cwd: 'client/modules'\n      src: ['**/*.js']\n      dest: 'build/js/app/modules'\n    ,\n      expand: true\n      src: ['{custom,packages}/*/client/**/*.js']\n      dest: 'build/js/app'\n    ,\n      src: ['node_modules/bluebird/js/browser/bluebird.js']\n      dest: 'build/js/app/modules/bluebird.js'\n    ,\n      src: ['node_modules/lodash/lodash.js']\n      dest: 'build/js/app/modules/lodash.js'\n    ,\n      src: ['node_modules/marked/lib/marked.js']\n      dest: 'build/js/app/modules/marked.js'\n    ]\n\n    gruntConfig.configureTask(\n      'watch', 'modules'\n\n      files: [\n        'client/{packages,require}.coffee'\n        'client/modules/**/*.{coffee,litcoffee}'\n        '{custom,packages}/*/client/**/*.{coffee,litcoffee}'\n        'custom/*/client/**/*.js'\n      ]\n      tasks: [\n        'build:modules', 'build:shrub'\n      ]\n      options: livereload: true\n    )\n\n    gruntConfig.configureTask(\n      'wrap', 'modules'\n\n      files: [\n        src: [\n          'build/js/app/modules/**/*.js'\n          'build/js/app/{custom,packages}/*/client/**/*.js'\n        ]\n        dest: 'build/js/app/modules.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: (filepath) ->\n\n          path = require 'path'\n\n          matches = filepath.match /build\\/js\\/app\\/([^/]+)\\/(.*)/\n\n          switch matches[1]\n\n            when 'modules'\n\n              moduleName = matches[2]\n\n            when 'custom', 'packages'\n\n              parts = matches[2].split '/'\n              parts.splice 1, 1\n              moduleName = parts.join '/'\n\n          dirname = path.dirname moduleName\n          if dirname is '.' then dirname = '' else dirname += '/'\n\n          extname = path.extname moduleName\n\n          moduleName = \"#{dirname}#{path.basename moduleName, extname}\"\n\n          if moduleName?\n            [\n              \"requires_['#{moduleName}'] = function(module, exports, require, __dirname, __filename) {\\n\\n\"\n              '\\n};\\n'\n            ]\n          else\n            ['', '']\n\n    )\n\n    gruntConfig.configureTask(\n      'wrap', 'modulesAll'\n\n      files: ['build/js/app/modules.js'].map (file) -> src: file, dest: file\n      options:\n        indent: '  '\n        wrapper: [\n          '(function() {\\n\\n  var requires_ = {};\\n\\n'\n          '\\n\\n})();\\n\\n'\n        ]\n\n    )\n\n    gruntConfig.registerTask 'shrub-browserify', [\n      'newer:browserify:shrub-debug'\n      'newer:browserify:shrub-inflection'\n      'newer:browserify:shrub-path'\n    ]\n\n    gruntConfig.registerTask 'build:modules', [\n      'newer:coffee:modules'\n      'newer:copy:modules'\n      'shrub-browserify'\n      'wrap:modules'\n      'concat:modules'\n      'newer:wrap:modulesAll'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:modules']",
            "title": "modules.coffee"
        },
        {
            "location": "/source/packages/shrub-grunt/modules/#grunt-build-process-modules",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.configureTask 'browserify', 'shrub-debug', {\n      src: ['node_modules/debug/browser.js']\n      dest: 'build/js/app/modules/debug.js'\n      options: browserifyOptions: standalone: 'debug'\n    }\n\n    gruntConfig.configureTask 'browserify', 'shrub-inflection', {\n      src: ['node_modules/inflection/lib/inflection.js']\n      dest: 'build/js/app/modules/inflection.js'\n      options: browserifyOptions: standalone: 'inflection'\n    }\n\n    gruntConfig.configureTask 'browserify', 'shrub-path', {\n      src: ['node_modules/path-browserify/index.js']\n      dest: 'build/js/app/modules/path.js'\n      options: browserifyOptions: standalone: 'path'\n    }\n\n    gruntConfig.configureTask 'coffee', 'modules', files: [\n      cwd: 'client'\n      src: [\n        'packages.coffee'\n        'require.coffee'\n        'modules/**/*.{coffee,litcoffee}'\n      ]\n      dest: 'build/js/app'\n      expand: true\n      ext: '.js'\n    ,\n      src: [\n        '{custom,packages}/*/client/**/*.{coffee,litcoffee}'\n      ]\n      dest: 'build/js/app'\n      expand: true\n      ext: '.js'\n    ]\n\n    gruntConfig.configureTask 'concat', 'modules', files: [\n      src: [\n        'build/js/app/{modules,packages,require}.js'\n      ]\n      dest: 'build/js/app/modules.js'\n    ]\n\n    gruntConfig.configureTask 'copy', 'modules', files: [\n      expand: true\n      cwd: 'client/modules'\n      src: ['**/*.js']\n      dest: 'build/js/app/modules'\n    ,\n      expand: true\n      src: ['{custom,packages}/*/client/**/*.js']\n      dest: 'build/js/app'\n    ,\n      src: ['node_modules/bluebird/js/browser/bluebird.js']\n      dest: 'build/js/app/modules/bluebird.js'\n    ,\n      src: ['node_modules/lodash/lodash.js']\n      dest: 'build/js/app/modules/lodash.js'\n    ,\n      src: ['node_modules/marked/lib/marked.js']\n      dest: 'build/js/app/modules/marked.js'\n    ]\n\n    gruntConfig.configureTask(\n      'watch', 'modules'\n\n      files: [\n        'client/{packages,require}.coffee'\n        'client/modules/**/*.{coffee,litcoffee}'\n        '{custom,packages}/*/client/**/*.{coffee,litcoffee}'\n        'custom/*/client/**/*.js'\n      ]\n      tasks: [\n        'build:modules', 'build:shrub'\n      ]\n      options: livereload: true\n    )\n\n    gruntConfig.configureTask(\n      'wrap', 'modules'\n\n      files: [\n        src: [\n          'build/js/app/modules/**/*.js'\n          'build/js/app/{custom,packages}/*/client/**/*.js'\n        ]\n        dest: 'build/js/app/modules.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: (filepath) ->\n\n          path = require 'path'\n\n          matches = filepath.match /build\\/js\\/app\\/([^/]+)\\/(.*)/\n\n          switch matches[1]\n\n            when 'modules'\n\n              moduleName = matches[2]\n\n            when 'custom', 'packages'\n\n              parts = matches[2].split '/'\n              parts.splice 1, 1\n              moduleName = parts.join '/'\n\n          dirname = path.dirname moduleName\n          if dirname is '.' then dirname = '' else dirname += '/'\n\n          extname = path.extname moduleName\n\n          moduleName = \"#{dirname}#{path.basename moduleName, extname}\"\n\n          if moduleName?\n            [\n              \"requires_['#{moduleName}'] = function(module, exports, require, __dirname, __filename) {\\n\\n\"\n              '\\n};\\n'\n            ]\n          else\n            ['', '']\n\n    )\n\n    gruntConfig.configureTask(\n      'wrap', 'modulesAll'\n\n      files: ['build/js/app/modules.js'].map (file) -> src: file, dest: file\n      options:\n        indent: '  '\n        wrapper: [\n          '(function() {\\n\\n  var requires_ = {};\\n\\n'\n          '\\n\\n})();\\n\\n'\n        ]\n\n    )\n\n    gruntConfig.registerTask 'shrub-browserify', [\n      'newer:browserify:shrub-debug'\n      'newer:browserify:shrub-inflection'\n      'newer:browserify:shrub-path'\n    ]\n\n    gruntConfig.registerTask 'build:modules', [\n      'newer:coffee:modules'\n      'newer:copy:modules'\n      'shrub-browserify'\n      'wrap:modules'\n      'concat:modules'\n      'newer:wrap:modulesAll'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:modules']",
            "title": "Grunt build process - Modules"
        },
        {
            "location": "/source/packages/shrub-grunt/tests/build/",
            "text": "Grunt build process - Build tests\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.configureTask 'coffee', 'testsE2e', files: [\n      src: [\n        'client/modules/**/test-e2e.coffee'\n        '{custom,packages}/*/client/**/test-e2e.coffee'\n      ]\n      dest: 'build/js/tests'\n      expand: true\n      ext: '.js'\n    ]\n\n    gruntConfig.configureTask 'coffee', 'testsE2eExtensions', files: [\n      src: [\n        'test/e2e/extensions/**/*.coffee'\n      ]\n      dest: 'build/js/tests'\n      expand: true\n      ext: '.js'\n    ]\n\n    gruntConfig.configureTask 'coffee', 'testsUnit', files: [\n      src: [\n        'client/modules/**/test-unit.coffee'\n        '{custom,packages}/*/client/**/test-unit.coffee'\n      ]\n      dest: 'build/js/tests'\n      expand: true\n      ext: '.js'\n    ]\n\n    gruntConfig.configureTask 'concat', 'testsE2e', files: [\n      src: [\n        'build/js/tests/**/test-e2e.js'\n      ]\n      dest: 'build/js/tests/test/scenarios-raw.js'\n    ]\n\n    gruntConfig.configureTask 'concat', 'testsE2eExtensions', files: [\n      src: [\n        'build/js/tests/test/e2e/extensions/**/*.js'\n      ]\n      dest: 'test/e2e/extensions.js'\n    ]\n\n    gruntConfig.configureTask 'concat', 'testsUnit', files: [\n      src: [\n        'build/js/tests/**/test-unit.js'\n      ]\n      dest: 'build/js/tests/test/tests-raw.js'\n    ]\n\n    gruntConfig.configureTask 'copy', 'testsE2e', files: [\n      src: [\n        'client/modules/**/test-e2e.js'\n        '{custom,packages}/*/client/**/test-e2e.js'\n      ]\n      dest: 'build/js/tests'\n    ]\n\n    gruntConfig.configureTask 'copy', 'testsUnit', files: [\n      src: [\n        'client/modules/**/test-unit.js'\n        '{custom,packages}/*/client/**/test-unit.js'\n      ]\n      dest: 'build/js/tests'\n    ]\n\n    gruntConfig.configureTask(\n      'watch', 'testsE2e'\n\n      files: [\n        'client/modules/**/test-e2e.coffee'\n        '{custom,packages}/*/client/**/test-e2e.coffee'\n      ]\n      tasks: ['build:testsE2e']\n    )\n\n    gruntConfig.configureTask(\n      'watch', 'testsE2eExtensions'\n\n      files: [\n        'test/e2e/extensions/**/*.coffee'\n      ]\n      tasks: ['build:testsE2eExtensions']\n    )\n\n    gruntConfig.configureTask(\n      'watch', 'testsUnit'\n\n      files: [\n        'client/modules/**/test-unit.coffee'\n        '{custom,packages}/*/client/**/test-unit.coffee'\n      ]\n      tasks: ['build:testsUnit']\n    )\n\n    gruntConfig.configureTask(\n      'wrap', 'testsE2e'\n\n      files: [\n        src: [\n          'build/js/tests/test/scenarios-raw.js'\n        ]\n        dest: 'test/e2e/scenarios.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: [\n          \"describe('#{gruntConfig.pkg.name}', function() {\\n\\n\\n\"\n          '\\n});\\n'\n        ]\n    )\n\n    gruntConfig.configureTask(\n      'wrap', 'testsUnit'\n\n      files: [\n        src: [\n          'build/js/tests/test/tests-raw.js'\n        ]\n        dest: 'test/unit/tests.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: [\n          \"describe('#{gruntConfig.pkg.name}', function() {\\n\\n  beforeEach(function() {\\n    module('shrub.core');\\n  });\\n\\n\"\n          '\\n});\\n'\n        ]\n    )\n\n    gruntConfig.registerTask 'build:testsE2e', [\n      'newer:coffee:testsE2e'\n      'newer:copy:testsE2e'\n      'concat:testsE2e'\n      'wrap:testsE2e'\n    ]\n\n    gruntConfig.registerTask 'build:testsE2eExtensions', [\n      'newer:coffee:testsE2eExtensions'\n      'concat:testsE2eExtensions'\n    ]\n\n    gruntConfig.registerTask 'build:testsUnit', [\n      'newer:coffee:testsUnit'\n      'newer:copy:testsUnit'\n      'concat:testsUnit'\n      'wrap:testsUnit'\n    ]\n\n    gruntConfig.registerTask 'build:tests', [\n      'build:testsE2e'\n      'build:testsE2eExtensions'\n      'build:testsUnit'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:tests']\n\n\n\n\nImplements hook \nshrubGruntConfigAlter\n\n\n  registrar.registerHook 'shrubGruntConfigAlter', (gruntConfig) ->\n\n    ignoreFiles = (array, directory) ->\n      array.push \"!#{directory}/**/#{spec}\" for spec in [\n        'test-{e2e,unit}.coffee'\n        '*.spec.coffee'\n      ]\n\n    coffeeConfig = gruntConfig.taskConfiguration 'coffee', 'modules'\n    ignoreFiles coffeeConfig.files[0].src, 'modules'\n    ignoreFiles coffeeConfig.files[1].src, 'custom/*/client'\n    ignoreFiles coffeeConfig.files[1].src, 'packages/*/client'\n\n    watchConfig = gruntConfig.taskConfiguration 'watch', 'modules'\n    ignoreFiles watchConfig.files, directory for directory in [\n      'client/modules'\n      '{custom,packages}/*/client'\n    ]",
            "title": "build.coffee"
        },
        {
            "location": "/source/packages/shrub-grunt/tests/build/#grunt-build-process-build-tests",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.configureTask 'coffee', 'testsE2e', files: [\n      src: [\n        'client/modules/**/test-e2e.coffee'\n        '{custom,packages}/*/client/**/test-e2e.coffee'\n      ]\n      dest: 'build/js/tests'\n      expand: true\n      ext: '.js'\n    ]\n\n    gruntConfig.configureTask 'coffee', 'testsE2eExtensions', files: [\n      src: [\n        'test/e2e/extensions/**/*.coffee'\n      ]\n      dest: 'build/js/tests'\n      expand: true\n      ext: '.js'\n    ]\n\n    gruntConfig.configureTask 'coffee', 'testsUnit', files: [\n      src: [\n        'client/modules/**/test-unit.coffee'\n        '{custom,packages}/*/client/**/test-unit.coffee'\n      ]\n      dest: 'build/js/tests'\n      expand: true\n      ext: '.js'\n    ]\n\n    gruntConfig.configureTask 'concat', 'testsE2e', files: [\n      src: [\n        'build/js/tests/**/test-e2e.js'\n      ]\n      dest: 'build/js/tests/test/scenarios-raw.js'\n    ]\n\n    gruntConfig.configureTask 'concat', 'testsE2eExtensions', files: [\n      src: [\n        'build/js/tests/test/e2e/extensions/**/*.js'\n      ]\n      dest: 'test/e2e/extensions.js'\n    ]\n\n    gruntConfig.configureTask 'concat', 'testsUnit', files: [\n      src: [\n        'build/js/tests/**/test-unit.js'\n      ]\n      dest: 'build/js/tests/test/tests-raw.js'\n    ]\n\n    gruntConfig.configureTask 'copy', 'testsE2e', files: [\n      src: [\n        'client/modules/**/test-e2e.js'\n        '{custom,packages}/*/client/**/test-e2e.js'\n      ]\n      dest: 'build/js/tests'\n    ]\n\n    gruntConfig.configureTask 'copy', 'testsUnit', files: [\n      src: [\n        'client/modules/**/test-unit.js'\n        '{custom,packages}/*/client/**/test-unit.js'\n      ]\n      dest: 'build/js/tests'\n    ]\n\n    gruntConfig.configureTask(\n      'watch', 'testsE2e'\n\n      files: [\n        'client/modules/**/test-e2e.coffee'\n        '{custom,packages}/*/client/**/test-e2e.coffee'\n      ]\n      tasks: ['build:testsE2e']\n    )\n\n    gruntConfig.configureTask(\n      'watch', 'testsE2eExtensions'\n\n      files: [\n        'test/e2e/extensions/**/*.coffee'\n      ]\n      tasks: ['build:testsE2eExtensions']\n    )\n\n    gruntConfig.configureTask(\n      'watch', 'testsUnit'\n\n      files: [\n        'client/modules/**/test-unit.coffee'\n        '{custom,packages}/*/client/**/test-unit.coffee'\n      ]\n      tasks: ['build:testsUnit']\n    )\n\n    gruntConfig.configureTask(\n      'wrap', 'testsE2e'\n\n      files: [\n        src: [\n          'build/js/tests/test/scenarios-raw.js'\n        ]\n        dest: 'test/e2e/scenarios.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: [\n          \"describe('#{gruntConfig.pkg.name}', function() {\\n\\n\\n\"\n          '\\n});\\n'\n        ]\n    )\n\n    gruntConfig.configureTask(\n      'wrap', 'testsUnit'\n\n      files: [\n        src: [\n          'build/js/tests/test/tests-raw.js'\n        ]\n        dest: 'test/unit/tests.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: [\n          \"describe('#{gruntConfig.pkg.name}', function() {\\n\\n  beforeEach(function() {\\n    module('shrub.core');\\n  });\\n\\n\"\n          '\\n});\\n'\n        ]\n    )\n\n    gruntConfig.registerTask 'build:testsE2e', [\n      'newer:coffee:testsE2e'\n      'newer:copy:testsE2e'\n      'concat:testsE2e'\n      'wrap:testsE2e'\n    ]\n\n    gruntConfig.registerTask 'build:testsE2eExtensions', [\n      'newer:coffee:testsE2eExtensions'\n      'concat:testsE2eExtensions'\n    ]\n\n    gruntConfig.registerTask 'build:testsUnit', [\n      'newer:coffee:testsUnit'\n      'newer:copy:testsUnit'\n      'concat:testsUnit'\n      'wrap:testsUnit'\n    ]\n\n    gruntConfig.registerTask 'build:tests', [\n      'build:testsE2e'\n      'build:testsE2eExtensions'\n      'build:testsUnit'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:tests']  Implements hook  shrubGruntConfigAlter    registrar.registerHook 'shrubGruntConfigAlter', (gruntConfig) ->\n\n    ignoreFiles = (array, directory) ->\n      array.push \"!#{directory}/**/#{spec}\" for spec in [\n        'test-{e2e,unit}.coffee'\n        '*.spec.coffee'\n      ]\n\n    coffeeConfig = gruntConfig.taskConfiguration 'coffee', 'modules'\n    ignoreFiles coffeeConfig.files[0].src, 'modules'\n    ignoreFiles coffeeConfig.files[1].src, 'custom/*/client'\n    ignoreFiles coffeeConfig.files[1].src, 'packages/*/client'\n\n    watchConfig = gruntConfig.taskConfiguration 'watch', 'modules'\n    ignoreFiles watchConfig.files, directory for directory in [\n      'client/modules'\n      '{custom,packages}/*/client'\n    ]",
            "title": "Grunt build process - Build tests"
        },
        {
            "location": "/source/packages/shrub-grunt/tests/",
            "text": "Grunt build process - Tests\n\n\nBuild and run the tests.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n  registrar.recur [\n    'build', 'run'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-grunt/tests/#grunt-build-process-tests",
            "text": "Build and run the tests.  exports.pkgmanRegister = (registrar) ->\n\n  registrar.recur [\n    'build', 'run'\n  ]",
            "title": "Grunt build process - Tests"
        },
        {
            "location": "/source/packages/shrub-grunt/tests/run/",
            "text": "Grunt build process - Run tests\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig, grunt) ->\n\n    {fork, spawn} = require 'child_process'\n\n    gruntConfig.configureTask(\n      'karma', 'testsUnit'\n\n      options:\n\n        basePath: \"#{__dirname}/../../..\"\n\n        files: [\n          'app/lib/angular/angular.js'\n          'app/lib/angular/angular-*.js'\n          'test/lib/angular/angular-mocks.js'\n          'app/lib/shrub/shrub.js'\n          'test/unit/config.js'\n          'test/unit/tests.js'\n        ]\n\n        exclude: [\n          'app/lib/angular/angular-loader.js'\n          'app/lib/angular/*.min.js'\n          'app/lib/angular/angular-scenario.js'\n        ]\n\n        frameworks: [\n          'jasmine'\n        ]\n\n        browsers: [\n          'Chrome'\n        ]\n\n        plugins: [\n          'karma-junit-reporter'\n          'karma-chrome-launcher'\n          'karma-firefox-launcher'\n          'karma-jasmine'\n        ]\n\n        singleRun: true\n\n        junitReporter:\n\n          outputFile: 'test_out/unit.xml'\n          suite: 'unit'\n\n    )\n\n    gruntConfig.configureTask(\n      'protractor', 'testsE2e'\n\n      options:\n        configFile: 'config/protractor.conf.js'\n        keepAlive: false\n        noColor: true\n\n    )\n\n    e2eServerChild = null\n\n    gruntConfig.registerTask 'tests:e2eServerUp', ->\n\n      done = @async()\n\n      openServerPort().then (port) ->\n\n\n\n\nPass arguments to the child process.\n\n\n        args = process.argv.slice 2\n\n\n\n\nPass the environment to the child process.\n\n\n        options = env: process.env\n        options.env['E2E'] = 'true'\n        options.env['packageConfig:shrub-http:port'] = port\n\n\n\n\nFork it.\n\n\n        e2eServerChild = fork(\n          \"#{__dirname}/../../../node_modules/coffee-script/bin/coffee\"\n          [\"#{__dirname}/../../../server.coffee\"]\n          options\n        )\n\n\n\n\nInject the port configuration.\n\n\n        protractorConfig = gruntConfig.taskConfiguration(\n          'protractor', 'testsE2e'\n        )\n        baseUrl = \"http://localhost:#{port}/\"\n        protractorConfig.options.args = baseUrl: baseUrl\n\n\n\n\nWait for the server to come up.\n\n\n        grunt.log.write 'Waiting for E2E server to come up...'\n        require('tcp-port-used').waitUntilUsed(port, 400, 30000).then(\n\n          ->\n            grunt.task.run 'protractor:testsE2e'\n            done()\n\n          (error) -> grunt.fail.fatal 'E2E server never came up after 30 seconds!'\n        )\n\n    openServerPort = ->\n      new (require 'bluebird') (resolve, reject) ->\n        server = require('net').createServer()\n\n        server.listen 0, ->\n          {port} = server.address()\n          server.close -> resolve port\n\n        server.on 'error', reject\n\n    gruntConfig.registerTask 'tests:e2eServerDown', ->\n      e2eServerChild.on 'close', @async()\n      e2eServerChild.kill()\n\n    gruntConfig.registerTask 'tests:e2e', [\n      'buildOnce'\n      'tests:e2eServerUp'\n      'tests:e2eServerDown'\n    ]\n\n    gruntConfig.registerTask 'tests:unitConfig', ->\n      done = @async()\n\n      req = new require('http').IncomingMessage\n      req.grunt = true\n\n      require('shrub-config').renderPackageConfig(req).then (code) ->\n\n        grunt.file.write 'test/unit/config.js', code\n\n        done()\n\n    gruntConfig.registerTask 'tests:unit', [\n      'buildOnce'\n      'tests:unitConfig'\n      'karma:testsUnit'\n    ]\n\n    gruntConfig.registerTask 'tests:jasmineFunction', ->\n\n      done = @async()\n\n\n\n\nSpawn node Jasmine.\n\n\n      spawn(\n        'node'\n        [\n          \"#{__dirname}/../../../node_modules/jasmine-node/lib/jasmine-node/cli.js\"\n          '--coffee', 'client', 'packages', 'custom'\n        ]\n        stdio: 'inherit'\n      ).on 'close', (code) ->\n        return done() if code is 0\n        grunt.fail.fatal 'Jasmine tests not passing!'\n\n    gruntConfig.registerTask 'tests:jasmine', [\n      'buildOnce'\n      'tests:jasmineFunction'\n    ]\n\n    gruntConfig.registerTask 'tests', [\n       'tests:jasmine'\n       'tests:unit'\n       'tests:e2e'\n    ]\n\n    gruntConfig.loadNpmTasks [\n      'grunt-karma'\n      'grunt-protractor-runner'\n    ]",
            "title": "run.coffee"
        },
        {
            "location": "/source/packages/shrub-grunt/tests/run/#grunt-build-process-run-tests",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig, grunt) ->\n\n    {fork, spawn} = require 'child_process'\n\n    gruntConfig.configureTask(\n      'karma', 'testsUnit'\n\n      options:\n\n        basePath: \"#{__dirname}/../../..\"\n\n        files: [\n          'app/lib/angular/angular.js'\n          'app/lib/angular/angular-*.js'\n          'test/lib/angular/angular-mocks.js'\n          'app/lib/shrub/shrub.js'\n          'test/unit/config.js'\n          'test/unit/tests.js'\n        ]\n\n        exclude: [\n          'app/lib/angular/angular-loader.js'\n          'app/lib/angular/*.min.js'\n          'app/lib/angular/angular-scenario.js'\n        ]\n\n        frameworks: [\n          'jasmine'\n        ]\n\n        browsers: [\n          'Chrome'\n        ]\n\n        plugins: [\n          'karma-junit-reporter'\n          'karma-chrome-launcher'\n          'karma-firefox-launcher'\n          'karma-jasmine'\n        ]\n\n        singleRun: true\n\n        junitReporter:\n\n          outputFile: 'test_out/unit.xml'\n          suite: 'unit'\n\n    )\n\n    gruntConfig.configureTask(\n      'protractor', 'testsE2e'\n\n      options:\n        configFile: 'config/protractor.conf.js'\n        keepAlive: false\n        noColor: true\n\n    )\n\n    e2eServerChild = null\n\n    gruntConfig.registerTask 'tests:e2eServerUp', ->\n\n      done = @async()\n\n      openServerPort().then (port) ->  Pass arguments to the child process.          args = process.argv.slice 2  Pass the environment to the child process.          options = env: process.env\n        options.env['E2E'] = 'true'\n        options.env['packageConfig:shrub-http:port'] = port  Fork it.          e2eServerChild = fork(\n          \"#{__dirname}/../../../node_modules/coffee-script/bin/coffee\"\n          [\"#{__dirname}/../../../server.coffee\"]\n          options\n        )  Inject the port configuration.          protractorConfig = gruntConfig.taskConfiguration(\n          'protractor', 'testsE2e'\n        )\n        baseUrl = \"http://localhost:#{port}/\"\n        protractorConfig.options.args = baseUrl: baseUrl  Wait for the server to come up.          grunt.log.write 'Waiting for E2E server to come up...'\n        require('tcp-port-used').waitUntilUsed(port, 400, 30000).then(\n\n          ->\n            grunt.task.run 'protractor:testsE2e'\n            done()\n\n          (error) -> grunt.fail.fatal 'E2E server never came up after 30 seconds!'\n        )\n\n    openServerPort = ->\n      new (require 'bluebird') (resolve, reject) ->\n        server = require('net').createServer()\n\n        server.listen 0, ->\n          {port} = server.address()\n          server.close -> resolve port\n\n        server.on 'error', reject\n\n    gruntConfig.registerTask 'tests:e2eServerDown', ->\n      e2eServerChild.on 'close', @async()\n      e2eServerChild.kill()\n\n    gruntConfig.registerTask 'tests:e2e', [\n      'buildOnce'\n      'tests:e2eServerUp'\n      'tests:e2eServerDown'\n    ]\n\n    gruntConfig.registerTask 'tests:unitConfig', ->\n      done = @async()\n\n      req = new require('http').IncomingMessage\n      req.grunt = true\n\n      require('shrub-config').renderPackageConfig(req).then (code) ->\n\n        grunt.file.write 'test/unit/config.js', code\n\n        done()\n\n    gruntConfig.registerTask 'tests:unit', [\n      'buildOnce'\n      'tests:unitConfig'\n      'karma:testsUnit'\n    ]\n\n    gruntConfig.registerTask 'tests:jasmineFunction', ->\n\n      done = @async()  Spawn node Jasmine.        spawn(\n        'node'\n        [\n          \"#{__dirname}/../../../node_modules/jasmine-node/lib/jasmine-node/cli.js\"\n          '--coffee', 'client', 'packages', 'custom'\n        ]\n        stdio: 'inherit'\n      ).on 'close', (code) ->\n        return done() if code is 0\n        grunt.fail.fatal 'Jasmine tests not passing!'\n\n    gruntConfig.registerTask 'tests:jasmine', [\n      'buildOnce'\n      'tests:jasmineFunction'\n    ]\n\n    gruntConfig.registerTask 'tests', [\n       'tests:jasmine'\n       'tests:unit'\n       'tests:e2e'\n    ]\n\n    gruntConfig.loadNpmTasks [\n      'grunt-karma'\n      'grunt-protractor-runner'\n    ]",
            "title": "Grunt build process - Run tests"
        },
        {
            "location": "/source/packages/shrub-html5-audio/client/",
            "text": "HTML5 audio\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n  registrar.registerHook 'shrubAngularProvider', -> [\n\n    ->\n\n      audioFiles = config.get 'packageConfig:shrub-html5-audio:files'\n\n      _deferred = {}\n\n      provider = {}\n\n      provider.isFileDeferred = (filename) -> _deferred[filename]?\n\n      provider.setFileDeferred = (filename) -> _deferred[filename] = true\n\n      provider.$get = [\n        '$q', '$window'\n        ($q, $window) ->\n\n          service = {}\n\n\n\n\nTODO: Configure filetype priorities per browser.\n\n\n          service.loadFile = (filename) ->\n\n            unless audioFiles[filename]?\n              return $q.reject new Error \"Tried to load an audio file `#{filename}', but it wasn't registered.\"\n\n            unless angular.isArray extsOrPromise = audioFiles[filename]\n              return extsOrPromise\n\n            audioFiles[filename] = new $q (resolve, reject) ->\n\n              audio = $window.document.createElement 'audio'\n              audio.src = \"/audio/#{filename}.#{extsOrPromise[0]}\"\n              audio.onerror = (e) -> reject e ? $window.error\n              audio.addEventListener 'loadeddata', -> resolve audio\n\n          service.playFile = (filename) ->\n            @loadFile(filename).then (audio) -> audio.play()\n\n\n\n\nLoad audio files that aren't marked as deferred.\n\n\n          for filename, extensions of audioFiles\n            continue if provider.isFileDeferred filename\n            service.loadFile filename\n\n          return service\n\n      ]\n\n      return provider\n\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-html5-audio/client/#html5-audio",
            "text": "config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n  registrar.registerHook 'shrubAngularProvider', -> [\n\n    ->\n\n      audioFiles = config.get 'packageConfig:shrub-html5-audio:files'\n\n      _deferred = {}\n\n      provider = {}\n\n      provider.isFileDeferred = (filename) -> _deferred[filename]?\n\n      provider.setFileDeferred = (filename) -> _deferred[filename] = true\n\n      provider.$get = [\n        '$q', '$window'\n        ($q, $window) ->\n\n          service = {}  TODO: Configure filetype priorities per browser.            service.loadFile = (filename) ->\n\n            unless audioFiles[filename]?\n              return $q.reject new Error \"Tried to load an audio file `#{filename}', but it wasn't registered.\"\n\n            unless angular.isArray extsOrPromise = audioFiles[filename]\n              return extsOrPromise\n\n            audioFiles[filename] = new $q (resolve, reject) ->\n\n              audio = $window.document.createElement 'audio'\n              audio.src = \"/audio/#{filename}.#{extsOrPromise[0]}\"\n              audio.onerror = (e) -> reject e ? $window.error\n              audio.addEventListener 'loadeddata', -> resolve audio\n\n          service.playFile = (filename) ->\n            @loadFile(filename).then (audio) -> audio.play()  Load audio files that aren't marked as deferred.            for filename, extensions of audioFiles\n            continue if provider.isFileDeferred filename\n            service.loadFile filename\n\n          return service\n\n      ]\n\n      return provider\n\n  ]",
            "title": "HTML5 audio"
        },
        {
            "location": "/source/packages/shrub-html5-audio/",
            "text": "HTML5 audio\n\n\nfs = require 'fs'\npath = require 'path'\npkgman = require 'pkgman'\n\naudioFiles = null\n\ngatherAudioFiles = ->\n\n  unless audioFiles?\n    audioFiles = {}\n    for pkg, globs of pkgman.invoke 'shrubHtml5Audio'\n      audioFiles[pkg] = globs ? ['audio']\n\n  return audioFiles\n\nexports.pkgmanRegister = (registrar) ->\n\n  registrar.registerHook 'shrubConfigClient', ->\n\n    simpleGlob = require 'simple-glob'\n\n    qualifiedFiles = {}\n    for pkg, globs of gatherAudioFiles()\n      for glob in globs\n        directory = \"#{path.dirname require.resolve pkg}/#{glob}\"\n        for filename in simpleGlob \"#{directory}/**/*\"\n          stats = fs.statSync filename\n          continue if stats.isDirectory()\n          filename = filename.slice directory.length\n          filedir = path.dirname filename\n          filedir += '/' if filedir isnt '/'\n          fileext = path.extname filename\n          filebase = path.basename filename, fileext\n          fileext = fileext.slice 1\n          filename = \"#{pkg}/#{filedir.slice 1}#{filebase}\"\n          (qualifiedFiles[filename] ?= []).push fileext\n\n    files: qualifiedFiles\n\n  registrar.registerHook 'shrubHtml5Audio', ->\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    tasks = []\n\n    for pkg, globs of gatherAudioFiles()\n      for glob in globs\n\n        task = \"shrub-html5-audio-#{pkg}\"\n        tasks.push task\n\n        gruntConfig.copyAppFiles(\n          \"#{path.dirname require.resolve pkg}/#{glob}\"\n          task\n          \"app/audio/#{pkg}\"\n        )\n\n    tasks = tasks.map (task) -> \"newer:copy:#{task}\"\n    gruntConfig.registerTask 'build:shrub-html5-audio', tasks\n    gruntConfig.registerTask 'build', ['build:shrub-html5-audio']\n\n    return",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-html5-audio/#html5-audio",
            "text": "fs = require 'fs'\npath = require 'path'\npkgman = require 'pkgman'\n\naudioFiles = null\n\ngatherAudioFiles = ->\n\n  unless audioFiles?\n    audioFiles = {}\n    for pkg, globs of pkgman.invoke 'shrubHtml5Audio'\n      audioFiles[pkg] = globs ? ['audio']\n\n  return audioFiles\n\nexports.pkgmanRegister = (registrar) ->\n\n  registrar.registerHook 'shrubConfigClient', ->\n\n    simpleGlob = require 'simple-glob'\n\n    qualifiedFiles = {}\n    for pkg, globs of gatherAudioFiles()\n      for glob in globs\n        directory = \"#{path.dirname require.resolve pkg}/#{glob}\"\n        for filename in simpleGlob \"#{directory}/**/*\"\n          stats = fs.statSync filename\n          continue if stats.isDirectory()\n          filename = filename.slice directory.length\n          filedir = path.dirname filename\n          filedir += '/' if filedir isnt '/'\n          fileext = path.extname filename\n          filebase = path.basename filename, fileext\n          fileext = fileext.slice 1\n          filename = \"#{pkg}/#{filedir.slice 1}#{filebase}\"\n          (qualifiedFiles[filename] ?= []).push fileext\n\n    files: qualifiedFiles\n\n  registrar.registerHook 'shrubHtml5Audio', ->\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    tasks = []\n\n    for pkg, globs of gatherAudioFiles()\n      for glob in globs\n\n        task = \"shrub-html5-audio-#{pkg}\"\n        tasks.push task\n\n        gruntConfig.copyAppFiles(\n          \"#{path.dirname require.resolve pkg}/#{glob}\"\n          task\n          \"app/audio/#{pkg}\"\n        )\n\n    tasks = tasks.map (task) -> \"newer:copy:#{task}\"\n    gruntConfig.registerTask 'build:shrub-html5-audio', tasks\n    gruntConfig.registerTask 'build', ['build:shrub-html5-audio']\n\n    return",
            "title": "HTML5 audio"
        },
        {
            "location": "/source/packages/shrub-html5-local-storage/client/",
            "text": "HTML5 local storage\n\n\nProvide an Angular service to consume the HTML5 localStorage API.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularAppConfig\n\n\n  registrar.registerHook 'shrubAngularAppConfig', -> [\n    'shrub-html5-local-storageProvider'\n    (localStorageProvider) ->\n\n\n\n\nSet a default prefix and turn off all notification.\n\n\n      localStorageProvider.setPrefix 'shrub'\n      localStorageProvider.setNotify false, false\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularProvider\n\n\n  registrar.registerHook 'shrubAngularProvider', -> [\n    'localStorageServiceProvider'\n    (localStorageServiceProvider) ->\n\n      provider = {}\n\n\n\n\nForward all methods.\n\n\n      for staticMethod in [\n        'setPrefix', 'setStorageType', 'setStorageCookie'\n        'setStorageCookieDomain', 'setNotify'\n      ]\n        do (staticMethod) -> provider[staticMethod] = ->\n          localStorageServiceProvider[staticMethod] arguments...\n\n      provider.$get = [\n        'localStorageService'\n        (localStorageService) ->\n\n          service = {}\n\n          for method in [\n            'isSupported', 'getStorageType', 'set', 'add', 'get'\n            'keys', 'remove', 'clearAll', 'bind', 'deriveKey'\n            'length'\n          ]\n            do (method) -> service[method] = ->\n              localStorageService[method] arguments...\n\n          service.cookie = {}\n          for cookieMethod in [\n            'isSupported', 'set', 'get', 'add', 'remove'\n            'clearAll'\n          ]\n            do (method) -> service.cookie[method] = ->\n              localStorageService.cookie[method] arguments...\n\n          service\n      ]\n\n      provider\n\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-html5-local-storage/client/#html5-local-storage",
            "text": "Provide an Angular service to consume the HTML5 localStorage API.  exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularAppConfig    registrar.registerHook 'shrubAngularAppConfig', -> [\n    'shrub-html5-local-storageProvider'\n    (localStorageProvider) ->  Set a default prefix and turn off all notification.        localStorageProvider.setPrefix 'shrub'\n      localStorageProvider.setNotify false, false\n\n  ]  Implements hook  shrubAngularProvider    registrar.registerHook 'shrubAngularProvider', -> [\n    'localStorageServiceProvider'\n    (localStorageServiceProvider) ->\n\n      provider = {}  Forward all methods.        for staticMethod in [\n        'setPrefix', 'setStorageType', 'setStorageCookie'\n        'setStorageCookieDomain', 'setNotify'\n      ]\n        do (staticMethod) -> provider[staticMethod] = ->\n          localStorageServiceProvider[staticMethod] arguments...\n\n      provider.$get = [\n        'localStorageService'\n        (localStorageService) ->\n\n          service = {}\n\n          for method in [\n            'isSupported', 'getStorageType', 'set', 'add', 'get'\n            'keys', 'remove', 'clearAll', 'bind', 'deriveKey'\n            'length'\n          ]\n            do (method) -> service[method] = ->\n              localStorageService[method] arguments...\n\n          service.cookie = {}\n          for cookieMethod in [\n            'isSupported', 'set', 'get', 'add', 'remove'\n            'clearAll'\n          ]\n            do (method) -> service.cookie[method] = ->\n              localStorageService.cookie[method] arguments...\n\n          service\n      ]\n\n      provider\n\n  ]",
            "title": "HTML5 local storage"
        },
        {
            "location": "/source/packages/shrub-html5-local-storage/",
            "text": "HTML5 local storage\n\n\nBuild and serve the HTML5 localStorage support.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-html5-local-storage'\n\n    gruntConfig.registerTask 'build:shrub-html5-local-storage', [\n      'newer:copy:shrub-html5-local-storage'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-html5-local-storage']\n\n\n\n\nImplements hook \nshrubAssetsMiddleware\n\n\n  registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    config = require 'config'\n\n    label: 'Angular HTML5 local storage'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n          assets.scripts.push '/lib/angular/angular-local-storage.min.js'\n        else\n          assets.scripts.push '/lib/angular/angular-local-storage.js'\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubAngularPackageDependencies\n\n\n  registrar.registerHook 'shrubAngularPackageDependencies', -> [\n    'LocalStorageModule'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-html5-local-storage/#html5-local-storage",
            "text": "Build and serve the HTML5 localStorage support.  exports.pkgmanRegister = (registrar) ->  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-html5-local-storage'\n\n    gruntConfig.registerTask 'build:shrub-html5-local-storage', [\n      'newer:copy:shrub-html5-local-storage'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-html5-local-storage']  Implements hook  shrubAssetsMiddleware    registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    config = require 'config'\n\n    label: 'Angular HTML5 local storage'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n          assets.scripts.push '/lib/angular/angular-local-storage.min.js'\n        else\n          assets.scripts.push '/lib/angular/angular-local-storage.js'\n\n        next()\n\n    ]  Implements hook  shrubAngularPackageDependencies    registrar.registerHook 'shrubAngularPackageDependencies', -> [\n    'LocalStorageModule'\n  ]",
            "title": "HTML5 local storage"
        },
        {
            "location": "/source/packages/shrub-html5-notification/client/",
            "text": "HTML5 notifications\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularAppConfig\n\n\n  registrar.registerHook 'shrubAngularAppConfig', -> [\n    'shrub-html5-notificationProvider'\n    (notificationProvider) ->\n\n\n\n\nShrub defaults.\n\n\n      notificationProvider.setOptions(\n        icon: '/img/shrub.png'\n        lang: 'en'\n      )\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularProvider\n\n\n  registrar.registerHook 'shrubAngularProvider', -> [\n    'NotificationProvider'\n    (NotificationProvider) ->\n\n      provider = {}\n\n\n\n\nForward.\n\n\n      provider.setOptions = (options) ->\n        NotificationProvider.setOptions options\n\n\n\n\nI am not really a fan of using new as an API here.\n\n\n      provider.$get = [\n        'Notification'\n        (Notification) ->\n\n          service = {}\n\n          service.create = (title, options) ->\n            new Notification title, options\n\n          service\n      ]\n\n      provider\n\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-html5-notification/client/#html5-notifications",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularAppConfig    registrar.registerHook 'shrubAngularAppConfig', -> [\n    'shrub-html5-notificationProvider'\n    (notificationProvider) ->  Shrub defaults.        notificationProvider.setOptions(\n        icon: '/img/shrub.png'\n        lang: 'en'\n      )\n\n  ]  Implements hook  shrubAngularProvider    registrar.registerHook 'shrubAngularProvider', -> [\n    'NotificationProvider'\n    (NotificationProvider) ->\n\n      provider = {}  Forward.        provider.setOptions = (options) ->\n        NotificationProvider.setOptions options  I am not really a fan of using new as an API here.        provider.$get = [\n        'Notification'\n        (Notification) ->\n\n          service = {}\n\n          service.create = (title, options) ->\n            new Notification title, options\n\n          service\n      ]\n\n      provider\n\n  ]",
            "title": "HTML5 notifications"
        },
        {
            "location": "/source/packages/shrub-html5-notification/",
            "text": "HTML5 notification\n\n\nBuild and serve the HTML5 notification support.\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-html5-notification'\n\n    gruntConfig.registerTask 'build:shrub-html5-notification', [\n      'newer:copy:shrub-html5-notification'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-html5-notification']\n\n\n\n\nImplements hook \nshrubAssetsMiddleware\n\n\n  registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Angular HTML5 notifications'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n          assets.scripts.push '/lib/angular/angular-notification.min.js'\n        else\n          assets.scripts.push '/lib/angular/angular-notification.js'\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubAngularPackageDependencies\n\n\n  registrar.registerHook 'shrubAngularPackageDependencies', -> [\n    'notification'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-html5-notification/#html5-notification",
            "text": "Build and serve the HTML5 notification support.  config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-html5-notification'\n\n    gruntConfig.registerTask 'build:shrub-html5-notification', [\n      'newer:copy:shrub-html5-notification'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-html5-notification']  Implements hook  shrubAssetsMiddleware    registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    label: 'Angular HTML5 notifications'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n          assets.scripts.push '/lib/angular/angular-notification.min.js'\n        else\n          assets.scripts.push '/lib/angular/angular-notification.js'\n\n        next()\n\n    ]  Implements hook  shrubAngularPackageDependencies    registrar.registerHook 'shrubAngularPackageDependencies', -> [\n    'notification'\n  ]",
            "title": "HTML5 notification"
        },
        {
            "location": "/source/packages/shrub-http-express/errors/",
            "text": "Express - error handler\n\n\nerrorHandler = require 'errorhandler'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    express = require 'express'\n    config = require 'config'\n\n    errors = require 'errors'\n    logging = require 'logging'\n\n    logger = logging.create file: filename: 'logs/error.log'\n\n    label: 'Error handling'\n    middleware: [\n\n\n\n\nIn production, we'll just log the error and continue.\n\n\n      if 'production' is config.get 'NODE_ENV'\n\n        (error, req, res, next) ->\n\n          logger.error errors.stack error\n          next error\n\n\n\n\nOtherwise, we'll let Express format the error all pretty-like.\n\n\n      else\n\n        errorHandler.title = 'Shrub'\n        errorHandler()\n\n    ]",
            "title": "errors.coffee"
        },
        {
            "location": "/source/packages/shrub-http-express/errors/#express-error-handler",
            "text": "errorHandler = require 'errorhandler'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubHttpMiddleware    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    express = require 'express'\n    config = require 'config'\n\n    errors = require 'errors'\n    logging = require 'logging'\n\n    logger = logging.create file: filename: 'logs/error.log'\n\n    label: 'Error handling'\n    middleware: [  In production, we'll just log the error and continue.        if 'production' is config.get 'NODE_ENV'\n\n        (error, req, res, next) ->\n\n          logger.error errors.stack error\n          next error  Otherwise, we'll let Express format the error all pretty-like.        else\n\n        errorHandler.title = 'Shrub'\n        errorHandler()\n\n    ]",
            "title": "Express - error handler"
        },
        {
            "location": "/source/packages/shrub-http-express/",
            "text": "Express\n\n\nAn \nExpress\n HTTP server implementation, with\nmiddleware for sessions, routing, logging, etc.\n\n\nconfig = require 'config'\n\n{routeSentinel} = require './routes'\n\nhttp = null\n\nexpress = null\nsticky = null\n\nPromise = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    http = require 'http'\n\n    express = require 'express'\n    sticky = require 'sticky-session'\n\n    Promise = require 'bluebird'\n\n\n\n\nImplements hook \nshrubRpcRoutesAlter\n\n\nPatch in express-specific variables that will be required by middleware.\n\n\n  registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    expressMiddleware = (req, res, next) ->\n\n      req.headers = req.socket.request.headers\n      req.originalUrl = req.socket.request.originalUrl\n\n      next()\n\n    expressMiddleware.weight = -9999\n\n    for path, route of routes\n\n      route.middleware.unshift expressMiddleware\n\n    return\n\n  registrar.recur [\n    'errors', 'logger', 'routes', 'session', 'static'\n  ]\n\n\n\n\nAn implementation of \nHttpManager\n using the Express\nframework.\n\n\n{Manager: HttpManager} = require '../shrub-http/manager'\nexports.Manager = class Express extends HttpManager\n\n\n\n\nconstructor\n\n\nCreate the server.\n\n\n  constructor: ->\n    super\n\n\n\n\nCreate the Express instance.\n\n\n    @_app = express()\n\n\n\n\nRegister middleware.\n\n\n    @registerMiddleware()\n\n    @_routes = []\n\n\n\n\nSpin up an HTTP server.\n\n\n    @_server = http.createServer @_app\n\n\n\n\nExpress#addRoute\n\n\nAdd HTTP routes.\n\n\n  addRoute: (route) -> @_routes.push route\n\n\n\n\nExpress#cluster\n\n\nSpawn workers and tie them together into a cluster.\n\n\n  cluster: ->\n\n    coreConfig = config.get 'packageConfig:shrub-core'\n    @_server = sticky(\n      num: coreConfig.workers\n      trustedAddresses: coreConfig.trustedProxies\n      @_server\n    )\n\n    return\n\n  initialize: ->\n    listenPromise = super\n\n\n\n\nConnect (no pun) Express's middleware system to ours.\n\n\n    for fn in @_middleware._middleware\n      if fn is routeSentinel\n        for {verb, path, receiver} in @_routes\n          @_app[verb] path, receiver\n\n      else\n        @_app.use fn\n\n    return listenPromise\n\n\n\n\nExpress#listener\n\n\nListen for HTTP connections.\n\n\n  listener: ->\n\n    new Promise (resolve, reject) =>\n\n      @_server.on 'error', reject\n\n      @_server.once 'listening', =>\n        @_server.removeListener 'error', reject\n        resolve()\n\n\n\n\n} Bind to the listen port.\n\n\n      @_server.listen @port()\n\n\n\n\nExpress#server\n\n\nThe node HTTP server instance.\n\n\n  server: -> @_server\n\n\n\n\nExpress#trustProxy\n\n\nSet IP addresses as trusted proxies.\n\n\n  trustProxy: (proxyList) -> @_app.set 'trust proxy', proxyList",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-http-express/#express",
            "text": "An  Express  HTTP server implementation, with\nmiddleware for sessions, routing, logging, etc.  config = require 'config'\n\n{routeSentinel} = require './routes'\n\nhttp = null\n\nexpress = null\nsticky = null\n\nPromise = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    http = require 'http'\n\n    express = require 'express'\n    sticky = require 'sticky-session'\n\n    Promise = require 'bluebird'  Implements hook  shrubRpcRoutesAlter  Patch in express-specific variables that will be required by middleware.    registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    expressMiddleware = (req, res, next) ->\n\n      req.headers = req.socket.request.headers\n      req.originalUrl = req.socket.request.originalUrl\n\n      next()\n\n    expressMiddleware.weight = -9999\n\n    for path, route of routes\n\n      route.middleware.unshift expressMiddleware\n\n    return\n\n  registrar.recur [\n    'errors', 'logger', 'routes', 'session', 'static'\n  ]  An implementation of  HttpManager  using the Express\nframework.  {Manager: HttpManager} = require '../shrub-http/manager'\nexports.Manager = class Express extends HttpManager",
            "title": "Express"
        },
        {
            "location": "/source/packages/shrub-http-express/#constructor",
            "text": "Create the server.    constructor: ->\n    super  Create the Express instance.      @_app = express()  Register middleware.      @registerMiddleware()\n\n    @_routes = []  Spin up an HTTP server.      @_server = http.createServer @_app",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-http-express/#expressaddroute",
            "text": "Add HTTP routes.    addRoute: (route) -> @_routes.push route",
            "title": "Express#addRoute"
        },
        {
            "location": "/source/packages/shrub-http-express/#expresscluster",
            "text": "Spawn workers and tie them together into a cluster.    cluster: ->\n\n    coreConfig = config.get 'packageConfig:shrub-core'\n    @_server = sticky(\n      num: coreConfig.workers\n      trustedAddresses: coreConfig.trustedProxies\n      @_server\n    )\n\n    return\n\n  initialize: ->\n    listenPromise = super  Connect (no pun) Express's middleware system to ours.      for fn in @_middleware._middleware\n      if fn is routeSentinel\n        for {verb, path, receiver} in @_routes\n          @_app[verb] path, receiver\n\n      else\n        @_app.use fn\n\n    return listenPromise",
            "title": "Express#cluster"
        },
        {
            "location": "/source/packages/shrub-http-express/#expresslistener",
            "text": "Listen for HTTP connections.    listener: ->\n\n    new Promise (resolve, reject) =>\n\n      @_server.on 'error', reject\n\n      @_server.once 'listening', =>\n        @_server.removeListener 'error', reject\n        resolve()  } Bind to the listen port.        @_server.listen @port()",
            "title": "Express#listener"
        },
        {
            "location": "/source/packages/shrub-http-express/#expressserver",
            "text": "The node HTTP server instance.    server: -> @_server",
            "title": "Express#server"
        },
        {
            "location": "/source/packages/shrub-http-express/#expresstrustproxy",
            "text": "Set IP addresses as trusted proxies.    trustProxy: (proxyList) -> @_app.set 'trust proxy', proxyList",
            "title": "Express#trustProxy"
        },
        {
            "location": "/source/packages/shrub-http-express/logger/",
            "text": "Express - logger\n\n\nmorgan = require 'morgan'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\nLog requests, differentiating between client and sandbox requests.\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    express = require 'express'\n\n    logging = require 'logging'\n\n\n\n\nDifferentiate between remote clients and our own sandbox clients.\n\n\n    remoteRequestLogger = logging.create(\n      file: filename: 'logs/express.remote.log', level: 'info'\n    )\n    sandboxRequestLogger = logging.create(\n      file: filename: 'logs/express.sandbox.log', level: 'info'\n    )\n\n    label: 'Log requests'\n    middleware: [\n\n      morgan 'combined', stream:\n        write: (message, encoding) ->\n\n          logger = if message.match /(http:\\/\\/localhost:|node-XMLHttpRequest)/\n            sandboxRequestLogger\n          else\n            remoteRequestLogger\n\n          logger.info message\n\n    ]",
            "title": "logger.coffee"
        },
        {
            "location": "/source/packages/shrub-http-express/logger/#express-logger",
            "text": "morgan = require 'morgan'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubHttpMiddleware  Log requests, differentiating between client and sandbox requests.    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    express = require 'express'\n\n    logging = require 'logging'  Differentiate between remote clients and our own sandbox clients.      remoteRequestLogger = logging.create(\n      file: filename: 'logs/express.remote.log', level: 'info'\n    )\n    sandboxRequestLogger = logging.create(\n      file: filename: 'logs/express.sandbox.log', level: 'info'\n    )\n\n    label: 'Log requests'\n    middleware: [\n\n      morgan 'combined', stream:\n        write: (message, encoding) ->\n\n          logger = if message.match /(http:\\/\\/localhost:|node-XMLHttpRequest)/\n            sandboxRequestLogger\n          else\n            remoteRequestLogger\n\n          logger.info message\n\n    ]",
            "title": "Express - logger"
        },
        {
            "location": "/source/packages/shrub-http-express/routes/",
            "text": "Express - routes\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\nServe Express routes.\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Serve routes'\n    middleware: [\n      exports.routeSentinel\n    ]\n\nexports.routeSentinel = ->",
            "title": "routes.coffee"
        },
        {
            "location": "/source/packages/shrub-http-express/routes/#express-routes",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubHttpMiddleware  Serve Express routes.    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Serve routes'\n    middleware: [\n      exports.routeSentinel\n    ]\n\nexports.routeSentinel = ->",
            "title": "Express - routes"
        },
        {
            "location": "/source/packages/shrub-http-express/session/",
            "text": "Express - routes\n\n\nCookieParser = require 'cookie-parser'\nExpressSession = require 'express-session'\n\nexpress = null\n\nconfig = require 'config'\n{Middleware} = require 'middleware'\n\ncookieParser = null\nsessionStore = null\nsignature = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    label: 'Bootstrap session handling'\n    middleware: [\n\n      (next) ->\n\n        express = require 'express'\n        signature = require 'cookie-signature'\n\n        {cookie} = config.get(\n          'packageConfig:shrub-session'\n        )\n\n        cookieParser = CookieParser cookie.cryptoKey\n\n        OrmStore = require('shrub-session/store') express\n        sessionStore = new OrmStore()\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\nParse cookies and load any session.\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Load session from cookie'\n    middleware: sessionMiddleware()\n\n\n\n\nImplements hook \nshrubRpcRoutesAlter\n\n\n  registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    {spliceRouteMiddleware} = require 'shrub-rpc'\n\n    loadSessionMiddleware = (req, res, next) ->\n\n      req.loadSession = (done) ->\n\n        sessionMiddleware_ = new Middleware()\n        for fn in sessionMiddleware()\n          sessionMiddleware_.use fn\n\n        sessionMiddleware_.dispatch req, res, (error) ->\n          return next error if error?\n          done()\n\n      next()\n\n    loadSessionMiddleware.weight = -5000\n\n    for path, route of routes\n      route.middleware.unshift loadSessionMiddleware\n      spliceRouteMiddleware(\n        route, 'shrub-http-express/session', sessionMiddleware()\n      )\n\n    return\n\n\n\n\nImplements hook \nshrubSocketConnectionMiddleware\n\n\n  registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Load session from cookie'\n    middleware: sessionMiddleware()\n\nsessionMiddleware = ->\n\n  {cookie, key} = config.get 'packageConfig:shrub-session'\n\n  return [\n\n\n\n\nExpress cookie parser.\n\n\n    cookieParser\n\n\n\n\nSession reification.\n\n\n    ExpressSession(\n      cookie: cookie\n      key: key\n      resave: false\n      saveUninitialized: true\n      secret: cookie.cryptoKey\n      store: sessionStore\n    )\n\n  ]",
            "title": "session.coffee"
        },
        {
            "location": "/source/packages/shrub-http-express/session/#express-routes",
            "text": "CookieParser = require 'cookie-parser'\nExpressSession = require 'express-session'\n\nexpress = null\n\nconfig = require 'config'\n{Middleware} = require 'middleware'\n\ncookieParser = null\nsessionStore = null\nsignature = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    label: 'Bootstrap session handling'\n    middleware: [\n\n      (next) ->\n\n        express = require 'express'\n        signature = require 'cookie-signature'\n\n        {cookie} = config.get(\n          'packageConfig:shrub-session'\n        )\n\n        cookieParser = CookieParser cookie.cryptoKey\n\n        OrmStore = require('shrub-session/store') express\n        sessionStore = new OrmStore()\n\n        next()\n\n    ]  Implements hook  shrubHttpMiddleware  Parse cookies and load any session.    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Load session from cookie'\n    middleware: sessionMiddleware()  Implements hook  shrubRpcRoutesAlter    registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    {spliceRouteMiddleware} = require 'shrub-rpc'\n\n    loadSessionMiddleware = (req, res, next) ->\n\n      req.loadSession = (done) ->\n\n        sessionMiddleware_ = new Middleware()\n        for fn in sessionMiddleware()\n          sessionMiddleware_.use fn\n\n        sessionMiddleware_.dispatch req, res, (error) ->\n          return next error if error?\n          done()\n\n      next()\n\n    loadSessionMiddleware.weight = -5000\n\n    for path, route of routes\n      route.middleware.unshift loadSessionMiddleware\n      spliceRouteMiddleware(\n        route, 'shrub-http-express/session', sessionMiddleware()\n      )\n\n    return  Implements hook  shrubSocketConnectionMiddleware    registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Load session from cookie'\n    middleware: sessionMiddleware()\n\nsessionMiddleware = ->\n\n  {cookie, key} = config.get 'packageConfig:shrub-session'\n\n  return [  Express cookie parser.      cookieParser  Session reification.      ExpressSession(\n      cookie: cookie\n      key: key\n      resave: false\n      saveUninitialized: true\n      secret: cookie.cryptoKey\n      store: sessionStore\n    )\n\n  ]",
            "title": "Express - routes"
        },
        {
            "location": "/source/packages/shrub-http-express/static/",
            "text": "Express - static files\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\nServe static files.\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    express = require 'express'\n\n    config = require 'config'\n\n    label: 'Serve static files'\n    middleware: [\n      express.static config.get 'packageConfig:shrub-http:path'\n    ]",
            "title": "static.coffee"
        },
        {
            "location": "/source/packages/shrub-http-express/static/#express-static-files",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubHttpMiddleware  Serve static files.    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    express = require 'express'\n\n    config = require 'config'\n\n    label: 'Serve static files'\n    middleware: [\n      express.static config.get 'packageConfig:shrub-http:path'\n    ]",
            "title": "Express - static files"
        },
        {
            "location": "/source/packages/shrub-http/",
            "text": "HTTP\n\n\nManage HTTP connections.\n\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'shrub:http'\n\nhttpManager = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    label: 'Bootstrap HTTP server'\n    middleware: [\n\n      (next) ->\n\n        {manager, port} = config.get 'packageConfig:shrub-http'\n\n        {Manager} = require manager.module\n\n\n\n\nSpin up the HTTP server, and initialize it.\n\n\n        httpManager = new Manager()\n\n\n\n\nSpawn workers into a cluster.\n\n\n        httpManager.cluster()\n\n\n\n\nTrust prox(y|ies).\n\n\n        httpManager.trustProxy(\n          config.get 'packageConfig:shrub-core:trustedProxies'\n        )\n\n        httpManager.initialize().then(->\n\n          debug \"Shrub HTTP server up and running on port #{port}!\"\n          next()\n\n        ).catch next\n\n    ]\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\n  registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Finalize HTTP request'\n    middleware: [\n\n      (req, res, next) ->\n\n        if req.delivery?\n\n          res.send req.delivery\n\n        else\n\n          res.status 501\n          res.end '<h1>501 Internal Server Error</h1>'\n\n    ]\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n    manager:\n\n\n\n\nModule implementing the socket manager.\n\n\n      module: 'shrub-http-express'\n\n    middleware: [\n      'shrub-http-express/static'\n      'shrub-core'\n      'shrub-socket/factory'\n      'shrub-http-express/session'\n      'shrub-passport'\n      'shrub-http-express/logger'\n      'shrub-villiany'\n      'shrub-form'\n      'shrub-http-express/routes'\n      'shrub-config'\n      'shrub-skin/path'\n      'shrub-assets'\n      'shrub-skin/render'\n      'shrub-http-express/errors'\n    ]\n\n    path: \"#{config.get 'path'}/app\"\n\n    port: 4201\n\nexports.manager = -> httpManager",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-http/#http",
            "text": "Manage HTTP connections.  config = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'shrub:http'\n\nhttpManager = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    label: 'Bootstrap HTTP server'\n    middleware: [\n\n      (next) ->\n\n        {manager, port} = config.get 'packageConfig:shrub-http'\n\n        {Manager} = require manager.module  Spin up the HTTP server, and initialize it.          httpManager = new Manager()  Spawn workers into a cluster.          httpManager.cluster()  Trust prox(y|ies).          httpManager.trustProxy(\n          config.get 'packageConfig:shrub-core:trustedProxies'\n        )\n\n        httpManager.initialize().then(->\n\n          debug \"Shrub HTTP server up and running on port #{port}!\"\n          next()\n\n        ).catch next\n\n    ]  Implements hook  shrubHttpMiddleware    registrar.registerHook 'shrubHttpMiddleware', (http) ->\n\n    label: 'Finalize HTTP request'\n    middleware: [\n\n      (req, res, next) ->\n\n        if req.delivery?\n\n          res.send req.delivery\n\n        else\n\n          res.status 501\n          res.end '<h1>501 Internal Server Error</h1>'\n\n    ]  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->\n\n    manager:  Module implementing the socket manager.        module: 'shrub-http-express'\n\n    middleware: [\n      'shrub-http-express/static'\n      'shrub-core'\n      'shrub-socket/factory'\n      'shrub-http-express/session'\n      'shrub-passport'\n      'shrub-http-express/logger'\n      'shrub-villiany'\n      'shrub-form'\n      'shrub-http-express/routes'\n      'shrub-config'\n      'shrub-skin/path'\n      'shrub-assets'\n      'shrub-skin/render'\n      'shrub-http-express/errors'\n    ]\n\n    path: \"#{config.get 'path'}/app\"\n\n    port: 4201\n\nexports.manager = -> httpManager",
            "title": "HTTP"
        },
        {
            "location": "/source/packages/shrub-http/manager/",
            "text": "HTTP Manager\n\n\nManage an HTTP server instance.\n\n\nPromise = require 'bluebird'\n\nconfig = require 'config'\npkgman = require 'pkgman'\nPromise = require 'bluebird'\n\nmiddleware = require 'middleware'\n\nhttpDebug = require('debug') 'shrub:http'\nhttpDebugSilly = require('debug') 'shrub-silly:http'\nhttpMiddlewareDebug = require('debug') 'shrub-silly:http:middleware'\n\n\n\n\nHttpManager\n\n\nAn abstract interface to be implemented by an HTTP server (e.g.\n\nExpress\n).\n\n\nexports.Manager = class HttpManager\n\n\n\n\nconstructor\n\n\nCreate the server.\n\n\n  constructor: ->\n\n\n\n\nTODO: Keeping a reference here means HTTP stuff can't be updated at run-time.\n\n\n    @_config = config.get 'packageConfig:shrub-http'\n\n    @_middleware = null\n\n\n\n\nHttpManager#initialize\n\n\nInitialize the server.\n\n\n  initialize: ->\n\n\n\n\nInvoke hook \nshrubHttpRoutes\n\n\n    httpDebugSilly '- Registering routes...'\n    for routeList in pkgman.invokeFlat 'shrubHttpRoutes', this\n\n      for route in routeList\n        route.verb ?= 'get'\n\n        httpDebugSilly \"- - #{route.verb.toUpperCase()} #{route.path}\"\n\n        @addRoute route\n    httpDebugSilly '- Routes registered.'\n\n\n\n\nStart listening.\n\n\n    @listen()\n\n\n\n\nHttpManager#listen\n\n\nListen for HTTP connections.\n\n\n  listen: ->\n    self = this\n\n    new Promise (resolve, reject) ->\n\n      do tryListener = ->\n\n        self.listener().done(\n          resolve\n\n          (error) ->\n            return reject error unless 'EADDRINUSE' is error.code\n\n            httpDebug 'HTTP port in use... retrying in 2 seconds'\n            setTimeout tryListener, 2000\n\n        )\n\n\n\n\nHttpManager#path\n\n\nThe path where static files are served from.\n\n\n  path: -> @_config.path\n\n\n\n\nHttpManager#port\n\n\nGet the port this server (is|will be) listening on.\n\n\n  port: -> @_config.port\n\n\n\n\nHttpManager#registerMiddleware\n\n\nGather and initialize HTTP middleware.\n\n\n  registerMiddleware: ->\n\n    httpMiddlewareDebug '- Loading HTTP middleware...'\n\n    httpMiddleware = @_config.middleware.concat()\n\n\n\n\nMake absolutely sure the requests are finalized.\n\n\n    httpMiddleware.push 'shrub-http'\n\n\n\n\nInvoke hook \nshrubHttpMiddleware\n\n\nInvoked every time an HTTP connection is established.\n\n\n    @_middleware = middleware.fromHook(\n      'shrubHttpMiddleware', httpMiddleware, this\n    )\n\n    httpMiddlewareDebug '- HTTP middleware loaded.'\n\n\n\n\nEnsure any subclass implements these \"pure virtual\" methods.\n\n\n  this::[method] = (-> throw new ReferenceError(\n    \"HttpManager::#{method} is a pure virtual method!\"\n  )) for method in [\n    'addRoute', 'cluster', 'listener', 'server', 'trustProxy'\n  ]",
            "title": "manager.coffee"
        },
        {
            "location": "/source/packages/shrub-http/manager/#http-manager",
            "text": "Manage an HTTP server instance.  Promise = require 'bluebird'\n\nconfig = require 'config'\npkgman = require 'pkgman'\nPromise = require 'bluebird'\n\nmiddleware = require 'middleware'\n\nhttpDebug = require('debug') 'shrub:http'\nhttpDebugSilly = require('debug') 'shrub-silly:http'\nhttpMiddlewareDebug = require('debug') 'shrub-silly:http:middleware'",
            "title": "HTTP Manager"
        },
        {
            "location": "/source/packages/shrub-http/manager/#httpmanager",
            "text": "An abstract interface to be implemented by an HTTP server (e.g. Express ).  exports.Manager = class HttpManager",
            "title": "HttpManager"
        },
        {
            "location": "/source/packages/shrub-http/manager/#constructor",
            "text": "Create the server.    constructor: ->  TODO: Keeping a reference here means HTTP stuff can't be updated at run-time.      @_config = config.get 'packageConfig:shrub-http'\n\n    @_middleware = null",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-http/manager/#httpmanagerinitialize",
            "text": "Initialize the server.    initialize: ->  Invoke hook  shrubHttpRoutes      httpDebugSilly '- Registering routes...'\n    for routeList in pkgman.invokeFlat 'shrubHttpRoutes', this\n\n      for route in routeList\n        route.verb ?= 'get'\n\n        httpDebugSilly \"- - #{route.verb.toUpperCase()} #{route.path}\"\n\n        @addRoute route\n    httpDebugSilly '- Routes registered.'  Start listening.      @listen()",
            "title": "HttpManager#initialize"
        },
        {
            "location": "/source/packages/shrub-http/manager/#httpmanagerlisten",
            "text": "Listen for HTTP connections.    listen: ->\n    self = this\n\n    new Promise (resolve, reject) ->\n\n      do tryListener = ->\n\n        self.listener().done(\n          resolve\n\n          (error) ->\n            return reject error unless 'EADDRINUSE' is error.code\n\n            httpDebug 'HTTP port in use... retrying in 2 seconds'\n            setTimeout tryListener, 2000\n\n        )",
            "title": "HttpManager#listen"
        },
        {
            "location": "/source/packages/shrub-http/manager/#httpmanagerpath",
            "text": "The path where static files are served from.    path: -> @_config.path",
            "title": "HttpManager#path"
        },
        {
            "location": "/source/packages/shrub-http/manager/#httpmanagerport",
            "text": "Get the port this server (is|will be) listening on.    port: -> @_config.port",
            "title": "HttpManager#port"
        },
        {
            "location": "/source/packages/shrub-http/manager/#httpmanagerregistermiddleware",
            "text": "Gather and initialize HTTP middleware.    registerMiddleware: ->\n\n    httpMiddlewareDebug '- Loading HTTP middleware...'\n\n    httpMiddleware = @_config.middleware.concat()  Make absolutely sure the requests are finalized.      httpMiddleware.push 'shrub-http'  Invoke hook  shrubHttpMiddleware  Invoked every time an HTTP connection is established.      @_middleware = middleware.fromHook(\n      'shrubHttpMiddleware', httpMiddleware, this\n    )\n\n    httpMiddlewareDebug '- HTTP middleware loaded.'  Ensure any subclass implements these \"pure virtual\" methods.    this::[method] = (-> throw new ReferenceError(\n    \"HttpManager::#{method} is a pure virtual method!\"\n  )) for method in [\n    'addRoute', 'cluster', 'listener', 'server', 'trustProxy'\n  ]",
            "title": "HttpManager#registerMiddleware"
        },
        {
            "location": "/source/packages/shrub-install/",
            "text": "Installation\n\n\nInstall shrub if it hasn't been done so yet. This is essentially a hack for\nnow, but will be fleshed out as we go.\n\n\n{defaultLogger} = require 'logging'\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', (context) ->\n\n    orm = require 'shrub-orm'\n\n    label: 'Installation'\n    middleware: [\n\n      (next) ->\n\n\n\n\nNo superuser? Install...\n\n\nTODO: There should be a more robust check than just 'is there a superuser?'.\n\n\n        User = orm.collection 'shrub-user'\n        User.findOne(id: 1).then((user) ->\n          return if user?\n\n          reinstall()\n\n        ).then(-> next()).catch next\n\n    ]\n\n\n\n\nImplements hook \nshrubReplContext\n\n\n  registrar.registerHook 'shrubReplContext', (context) ->\n\n    context.install = reinstall\n\nreinstall = (name = 'admin', email = 'admin@example.com', password = 'admin') ->\n\n  Promise = require 'bluebird'\n\n  orm = require 'shrub-orm'\n\n\n\n\nRefresh all collections.\n\n\n  Promise.all(\n\n\n\n\nDrop all collections and data.\n\n\n    for identity, collection of orm.collections()\n      new Promise (resolve, reject) ->\n        collection.drop (error) ->\n          return reject error if error?\n          resolve()\n\n  ).then(->\n\n\n\n\nTeardown the schema.\n\n\n    new Promise (resolve, reject) ->\n      orm.teardown (error) ->\n        return reject error if error?\n        resolve()\n\n  ).then(->\n\n\n\n\nRebuild the schema.\n\n\n    new Promise (resolve, reject) ->\n      orm.initialize (error) ->\n        return reject error if error?\n        resolve()\n\n  ).then(->\n\n    {\n      'shrub-group': Group\n      'shrub-user': User\n      'shrub-user-local': UserLocal\n    } = orm.collections()\n\n    Promise.all [\n\n\n\n\nCreate groups.\n\n\n      Group.create name: 'Anonymous'\n      Group.create name: 'Authenticated'\n      Group.create name: 'Administrator'\n\n\n\n\nCreate superuser.\n\n\n      UserLocal.register(name, email, password).bind({}).then((@localUser) ->\n\n        User.create()\n\n      ).then (user) ->\n\n        user.instances.add(\n          model: 'shrub-user-local'\n          modelId: @localUser.id\n        )\n\n        return user\n\n    ]\n\n  ).then(([groups..., user]) ->\n\n    user.groups.add group: groups[2].id\n    user.save()\n\n  ).then(->\n\n    defaultLogger.error \"No site installed, so installed one.\"\n\n  ).catch console.error",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-install/#installation",
            "text": "Install shrub if it hasn't been done so yet. This is essentially a hack for\nnow, but will be fleshed out as we go.  {defaultLogger} = require 'logging'\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', (context) ->\n\n    orm = require 'shrub-orm'\n\n    label: 'Installation'\n    middleware: [\n\n      (next) ->  No superuser? Install...  TODO: There should be a more robust check than just 'is there a superuser?'.          User = orm.collection 'shrub-user'\n        User.findOne(id: 1).then((user) ->\n          return if user?\n\n          reinstall()\n\n        ).then(-> next()).catch next\n\n    ]  Implements hook  shrubReplContext    registrar.registerHook 'shrubReplContext', (context) ->\n\n    context.install = reinstall\n\nreinstall = (name = 'admin', email = 'admin@example.com', password = 'admin') ->\n\n  Promise = require 'bluebird'\n\n  orm = require 'shrub-orm'  Refresh all collections.    Promise.all(  Drop all collections and data.      for identity, collection of orm.collections()\n      new Promise (resolve, reject) ->\n        collection.drop (error) ->\n          return reject error if error?\n          resolve()\n\n  ).then(->  Teardown the schema.      new Promise (resolve, reject) ->\n      orm.teardown (error) ->\n        return reject error if error?\n        resolve()\n\n  ).then(->  Rebuild the schema.      new Promise (resolve, reject) ->\n      orm.initialize (error) ->\n        return reject error if error?\n        resolve()\n\n  ).then(->\n\n    {\n      'shrub-group': Group\n      'shrub-user': User\n      'shrub-user-local': UserLocal\n    } = orm.collections()\n\n    Promise.all [  Create groups.        Group.create name: 'Anonymous'\n      Group.create name: 'Authenticated'\n      Group.create name: 'Administrator'  Create superuser.        UserLocal.register(name, email, password).bind({}).then((@localUser) ->\n\n        User.create()\n\n      ).then (user) ->\n\n        user.instances.add(\n          model: 'shrub-user-local'\n          modelId: @localUser.id\n        )\n\n        return user\n\n    ]\n\n  ).then(([groups..., user]) ->\n\n    user.groups.add group: groups[2].id\n    user.save()\n\n  ).then(->\n\n    defaultLogger.error \"No site installed, so installed one.\"\n\n  ).catch console.error",
            "title": "Installation"
        },
        {
            "location": "/source/packages/shrub-limiter/client/",
            "text": "Limiter\n\n\nDefine a TransmittableError for the limiter.\n\n\n{TransmittableError} = require 'errors'\n\n\n\n\nImplement a TransmittableError to inform the user of limiter threshold\npassing.\n\n\nclass LimiterThresholdError extends TransmittableError\n\n  constructor: (message, @time) -> super\n\n  errorType: 'limiterThreshold'\n  template: ':message You may try again :time.'\n  toJSON: -> [@errorType, @message, @time]\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubTransmittableErrors\n\n\n  registrar.registerHook 'shrubTransmittableErrors', exports.shrubTransmittableErrors\n\nexports.shrubTransmittableErrors = -> [\n  LimiterThresholdError\n]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-limiter/client/#limiter",
            "text": "Define a TransmittableError for the limiter.  {TransmittableError} = require 'errors'  Implement a TransmittableError to inform the user of limiter threshold\npassing.  class LimiterThresholdError extends TransmittableError\n\n  constructor: (message, @time) -> super\n\n  errorType: 'limiterThreshold'\n  template: ':message You may try again :time.'\n  toJSON: -> [@errorType, @message, @time]\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubTransmittableErrors    registrar.registerHook 'shrubTransmittableErrors', exports.shrubTransmittableErrors\n\nexports.shrubTransmittableErrors = -> [\n  LimiterThresholdError\n]",
            "title": "Limiter"
        },
        {
            "location": "/source/packages/shrub-limiter/",
            "text": "Rate limiter\n\n\nLimits the rate at which clients can do certain operations, like call RPC\nroutes.\n\n\norm = null\npkgman = require 'pkgman'\n\n\n\n\nExported symbol to allow implementations to skip limiter checks.\n\n\nexports.SKIP = SKIP = {}\n\n\n\n\nA limiter on a route is defined like:\n\n\n\nregistrar.registerHook('shrubRpcRoutes', function() {\n\n  var shrubLimiter = require('shrub-limiter');\n  var Limiter = shrubLimiter.Limiter;\n  var LimiterMiddleware = shrubLimiter.LimiterMiddleware;\n\n  var routes = [];\n\n  routes.push({\n\n    path: 'my-package/route',\n\n    middleware: [\n\n      ...\n\n      'shrub-villiany', // Include if limit infractions lead to eventual ban\n\n      new LimiterMiddleware(\n        [[limiterDefinitionObject]]\n      ),\n\n      ...\n\n    ]\n\n  });\n\n  return routes;\n});\n\n\n\n\nWhere \n[[limiterDefinitionObject]]\n above is defined as an object with the\nfollowing properties:\n\n\n\n\n\n\nthreshold\n: The \nthreshold\n for this limiter.\n\n\n\n\n\n\nmessage\n: The message returned to the client when the threshold is\npassed.\n\n\n\n\n\n\nignoreKeys\n: The \nfingerprint keys\n to ignore\nwhen determining the total limit.\n\n\n\n\n\n\nvillianyScore\n: The score accumulated when this limit is crossed.\n\n\n\n\n\n\nLimiterMiddleware\n\n\nexports.LimiterMiddleware = class LimiterMiddleware\n\n  constructor: (@config) ->\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    orm = require 'shrub-orm'\n\n\n\n\nImplements hook \nshrubOrmCollections\n\n\n  registrar.registerHook 'shrubOrmCollections', ->\n\n    _ = require 'lodash'\n\n    Limit =\n\n      autoPK: false\n\n      associations: [\n        alias: 'scores'\n      ]\n\n      attributes:\n\n\n\n\nLimit#key\n\n\nThe limiter key.\n\n\n        key:\n          type: 'string'\n          primaryKey: true\n\n\n\n\nLimit#scores\n\n\nScores accrued for this limit.\n\n\n        scores:\n          collection: 'shrub-limit-score'\n          via: 'limit'\n\n\n\n\nLimit#accrue\n\n\n\n\n(Number) \nscore\n - The numeric score to accrue.\n\n\n\n\nAccrue a score for this limit.\n\n\n        accrue: (score) ->\n          @scores.add score: score\n\n          return this\n\n\n\n\nLimit#passed\n\n\n\n\n(Number) \nthreshold\n - The threshold duration in seconds.\n\n\n\n\nCheck whether a limit has passed the time threshold.\n\n\n        passed: (threshold) -> 0 >= @ttl threshold\n\n\n\n\nLimit#reset\n\n\nReset scores and created time.\n\n\n        reset: ->\n\n          ShrubLimitScore = orm.collection 'shrub-limit-score'\n\n          for id in _.map @scores, 'id'\n            @scores.remove id\n            ShrubLimitScore.destroy(id: id).exec ->\n\n          @createdAt = new Date()\n\n          return this\n\n\n\n\nLimit#score\n\n\nGet the sum of all scores for this limit.\n\n\n        score: ->\n          _.map(@scores, 'score').reduce ((l, r) -> l + r), 0\n\n\n\n\nLimit#ttl\n\n\n\n\n(Number) \nthreshold\n - The threshold duration in seconds.\n\n\n\n\nGet the current time-to-live for this limit.\n\n\n        ttl: (threshold) ->\n          diff = (Date.now() - @createdAt.getTime()) / 1000\n          Math.ceil threshold - diff\n\n    LimitScore =\n\n      attributes:\n\n        score: 'integer'\n\n        limit: model: 'shrub-limit'\n\n    'shrub-limit': Limit\n    'shrub-limit-score': LimitScore\n\n\n\n\nImplements hook \nshrubRpcRoutesAlter\n\n\nAllow RPC routes definitions to specify rate limiters.\n\n\n  registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    Promise = require 'bluebird'\n    moment = require 'moment'\n\n    errors = require 'errors'\n\n\n\n\nCheck all routes' middleware for limiter definitions.\n\n\n    Object.keys(routes).forEach (path) ->\n      route = routes[path]\n\n      Fingerprint = require 'fingerprint'\n\n      for fn, index in route.middleware\n        continue unless fn instanceof exports.LimiterMiddleware\n\n        route.limiter = fn.config\n\n\n\n\nCreate a limiter based on the threshold defined.\n\n\n        route.limiter.instance = new Limiter(\n          \"rpc://#{path}\", route.limiter.threshold\n        )\n\n\n\n\nSet defaults.\n\n\n        route.limiter.excludedKeys ?= []\n        route.limiter.message ?= 'You are doing that too much.'\n        route.limiter.villianyScore ?= 20\n\n\n\n\nAdd a validator, where we'll check the threshold.\n\n\n        route.middleware[index] = (req, res, next) ->\n\n          {\n            excludedKeys\n            instance\n            message\n            villianyScore\n          } = route.limiter\n\n\n\n\nAllow packages to check and optionally skip the limiter.\n\n\nInvoke hook \nshrubLimiterCheck\n\n\n          for rule in pkgman.invokeFlat 'shrubLimiterCheck', req\n            continue unless rule?\n            return next() if SKIP is rule\n\n          fingerprint = new Fingerprint req\n\n          inlineKeys = fingerprint.inlineKeys excludedKeys\n\n\n\n\nBuild a nice error message for the client, so they hopefully will\nstop doing that.\n\n\n          sendLimiterError = ->\n            instance.ttl(inlineKeys).then (ttl) ->\n              next errors.instantiate(\n                'limiterThreshold'\n                message\n                moment().add('seconds', ttl).fromNow()\n              )\n\n\n\n\nAccrue a hit and check the threshold.\n\n\n          instance.accrueAndCheckThreshold(inlineKeys).then((isLimited) ->\n            return next() unless isLimited\n\n\n\n\nInvoke hook \nshrubVillianyReport\n\n\n            Promise.all(\n              pkgman.invokeFlat(\n                'shrubVillianyReport'\n                req\n                villianyScore\n                \"rpc://#{path}:limiter\"\n                excludedKeys\n              )\n\n            ).then (reports) ->\n\n\n\n\nOnly send an error if the user wasn't banned for this.\n\n\n              if reports.filter((isBanned) -> !!isBanned).length is 0\n                sendLimiterError()\n\n          ).catch next\n\n\n\n\nImplements hook \nshrubTransmittableErrors\n\n\nJust defer to client, where the error is defined.\n\n\n  registrar.registerHook 'shrubTransmittableErrors', require('./client').shrubTransmittableErrors\n\nexports.Limiter = Limiter = require './limiter'",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-limiter/#rate-limiter",
            "text": "Limits the rate at which clients can do certain operations, like call RPC\nroutes.  orm = null\npkgman = require 'pkgman'  Exported symbol to allow implementations to skip limiter checks.  exports.SKIP = SKIP = {}  A limiter on a route is defined like:  \nregistrar.registerHook('shrubRpcRoutes', function() {\n\n  var shrubLimiter = require('shrub-limiter');\n  var Limiter = shrubLimiter.Limiter;\n  var LimiterMiddleware = shrubLimiter.LimiterMiddleware;\n\n  var routes = [];\n\n  routes.push({\n\n    path: 'my-package/route',\n\n    middleware: [\n\n      ...\n\n      'shrub-villiany', // Include if limit infractions lead to eventual ban\n\n      new LimiterMiddleware(\n        [[limiterDefinitionObject]]\n      ),\n\n      ...\n\n    ]\n\n  });\n\n  return routes;\n});  Where  [[limiterDefinitionObject]]  above is defined as an object with the\nfollowing properties:    threshold : The  threshold  for this limiter.    message : The message returned to the client when the threshold is\npassed.    ignoreKeys : The  fingerprint keys  to ignore\nwhen determining the total limit.    villianyScore : The score accumulated when this limit is crossed.    LimiterMiddleware  exports.LimiterMiddleware = class LimiterMiddleware\n\n  constructor: (@config) ->\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    orm = require 'shrub-orm'  Implements hook  shrubOrmCollections    registrar.registerHook 'shrubOrmCollections', ->\n\n    _ = require 'lodash'\n\n    Limit =\n\n      autoPK: false\n\n      associations: [\n        alias: 'scores'\n      ]\n\n      attributes:",
            "title": "Rate limiter"
        },
        {
            "location": "/source/packages/shrub-limiter/#limitkey",
            "text": "The limiter key.          key:\n          type: 'string'\n          primaryKey: true",
            "title": "Limit#key"
        },
        {
            "location": "/source/packages/shrub-limiter/#limitscores",
            "text": "Scores accrued for this limit.          scores:\n          collection: 'shrub-limit-score'\n          via: 'limit'",
            "title": "Limit#scores"
        },
        {
            "location": "/source/packages/shrub-limiter/#limitaccrue",
            "text": "(Number)  score  - The numeric score to accrue.   Accrue a score for this limit.          accrue: (score) ->\n          @scores.add score: score\n\n          return this",
            "title": "Limit#accrue"
        },
        {
            "location": "/source/packages/shrub-limiter/#limitpassed",
            "text": "(Number)  threshold  - The threshold duration in seconds.   Check whether a limit has passed the time threshold.          passed: (threshold) -> 0 >= @ttl threshold",
            "title": "Limit#passed"
        },
        {
            "location": "/source/packages/shrub-limiter/#limitreset",
            "text": "Reset scores and created time.          reset: ->\n\n          ShrubLimitScore = orm.collection 'shrub-limit-score'\n\n          for id in _.map @scores, 'id'\n            @scores.remove id\n            ShrubLimitScore.destroy(id: id).exec ->\n\n          @createdAt = new Date()\n\n          return this",
            "title": "Limit#reset"
        },
        {
            "location": "/source/packages/shrub-limiter/#limitscore",
            "text": "Get the sum of all scores for this limit.          score: ->\n          _.map(@scores, 'score').reduce ((l, r) -> l + r), 0",
            "title": "Limit#score"
        },
        {
            "location": "/source/packages/shrub-limiter/#limitttl",
            "text": "(Number)  threshold  - The threshold duration in seconds.   Get the current time-to-live for this limit.          ttl: (threshold) ->\n          diff = (Date.now() - @createdAt.getTime()) / 1000\n          Math.ceil threshold - diff\n\n    LimitScore =\n\n      attributes:\n\n        score: 'integer'\n\n        limit: model: 'shrub-limit'\n\n    'shrub-limit': Limit\n    'shrub-limit-score': LimitScore  Implements hook  shrubRpcRoutesAlter  Allow RPC routes definitions to specify rate limiters.    registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    Promise = require 'bluebird'\n    moment = require 'moment'\n\n    errors = require 'errors'  Check all routes' middleware for limiter definitions.      Object.keys(routes).forEach (path) ->\n      route = routes[path]\n\n      Fingerprint = require 'fingerprint'\n\n      for fn, index in route.middleware\n        continue unless fn instanceof exports.LimiterMiddleware\n\n        route.limiter = fn.config  Create a limiter based on the threshold defined.          route.limiter.instance = new Limiter(\n          \"rpc://#{path}\", route.limiter.threshold\n        )  Set defaults.          route.limiter.excludedKeys ?= []\n        route.limiter.message ?= 'You are doing that too much.'\n        route.limiter.villianyScore ?= 20  Add a validator, where we'll check the threshold.          route.middleware[index] = (req, res, next) ->\n\n          {\n            excludedKeys\n            instance\n            message\n            villianyScore\n          } = route.limiter  Allow packages to check and optionally skip the limiter.  Invoke hook  shrubLimiterCheck            for rule in pkgman.invokeFlat 'shrubLimiterCheck', req\n            continue unless rule?\n            return next() if SKIP is rule\n\n          fingerprint = new Fingerprint req\n\n          inlineKeys = fingerprint.inlineKeys excludedKeys  Build a nice error message for the client, so they hopefully will\nstop doing that.            sendLimiterError = ->\n            instance.ttl(inlineKeys).then (ttl) ->\n              next errors.instantiate(\n                'limiterThreshold'\n                message\n                moment().add('seconds', ttl).fromNow()\n              )  Accrue a hit and check the threshold.            instance.accrueAndCheckThreshold(inlineKeys).then((isLimited) ->\n            return next() unless isLimited  Invoke hook  shrubVillianyReport              Promise.all(\n              pkgman.invokeFlat(\n                'shrubVillianyReport'\n                req\n                villianyScore\n                \"rpc://#{path}:limiter\"\n                excludedKeys\n              )\n\n            ).then (reports) ->  Only send an error if the user wasn't banned for this.                if reports.filter((isBanned) -> !!isBanned).length is 0\n                sendLimiterError()\n\n          ).catch next  Implements hook  shrubTransmittableErrors  Just defer to client, where the error is defined.    registrar.registerHook 'shrubTransmittableErrors', require('./client').shrubTransmittableErrors\n\nexports.Limiter = Limiter = require './limiter'",
            "title": "Limit#ttl"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/",
            "text": "Limiter\n\n\nORM-backed limit handling. Accrue and check scores, and check Time-to-live\nacross multiple \nfingerprint keys\n.\n\n\nPromise = null\n\norm = null\n\n\n\n\nLimiter\n\n\nProvides methods to tally scores, and compare them against a threshold of\ntime. The \nlimiter\n package implements hook\n\nshrubRpcRoutesAlter\n to allow RPC routes to\nlimit consumers to a specified number of requests per time period. For\ninstance, by default the \nuser login\n route\nlimits the number of logins a user may attempt to 3 every 30 seconds.\n\n\nmodule.exports = class Limiter\n\n\n\n\nLimiter.threshold\n\n\nExpose a factory method for constructing Threshold instances. A Threshold\nis defined like: \nvar Limiter = require('shrub-limiter').Limiter;\nLimiter.threshold(4).every(20).minutes();\n Which means that the\nthreshold represents the allowance of a score of 4 to accumulate over the\nperiod of 20 minutes. If more score is accrued during that window, then\nthe threshold is said to be crossed.\n\n\n  @threshold: (score) -> new ThresholdBase score\n\n\n\n\nconstructor\n\n\n\n\n(string) \nkey\n - A unique key for this limiter, e.g.\n\n\n\n\n\"rpc://shrub-user/login:limiter\"\n\n\n\n\n(Threshold) \nthreshold\n - A threshold, see below for details.\n\n\n\n\nCreate a limiter.\n\n\n  constructor: (key, @threshold, @excluded = []) ->\n\n\n\n\nEnsure it's a threshold.\n\n\n    throw new TypeError(\n      \"Limiter(#{key}) must be constructed with a valid threshold!\"\n    ) unless @threshold instanceof ThresholdFinal\n\n    Promise ?= require 'bluebird'\n\n    orm ?= require 'shrub-orm'\n\n\n\n\nCreate the low-level limiter.\n\n\n    @limiter = new LimiterManager key, @threshold.calculateSeconds()\n\n\n\n\nLimiter#add\n\n\n\n\n(array) \nkeys\n - An array of keys, e.g. a flattened array of keys from\n\n\n\n\nFingerprint.inlineKeys\n\n\n\n\n(Number) \nscore\n - The score to add. Defaults to 1.\n\n\n\n\nAccrue score for a limiter.\n\n\n  accrue: (keys, score = 1) ->\n    Promise.all (@limiter.accrue key, score for key in keys)\n\n\n\n\nLimiter#accrueAndCheckThreshold\n\n\n\n\n(array) \nkeys\n - An array of keys, e.g. a flattened array of keys from\n\n\n\n\nFingerprint.inlineKeys\n\n\n\n\n(integer) \nscore\n - The score to add. Defaults to 1.\n\n\n\n\nAdd score to a limiter, and check it against the threshold.\n\n\n  accrueAndCheckThreshold: (keys, score = 1) ->\n    @accrue(keys, score).then => @checkThreshold keys\n\n\n\n\nLimiter#score\n\n\n\n\n(array) \nkeys\n - An array of keys, e.g. a flattened array of keys from\n\n\n\n\nFingerprint.inlineKeys\n\n\nCheck score for a limiter.\n\n\n  score: (keys) -> @_largest keys, 'score'\n\n\n\n\nLimiter#ttl\n\n\n\n\n(array) \nkeys\n - An array of keys, e.g. a flattened array of keys from\n\n\n\n\nFingerprint.inlineKeys\n\n\nTime-to-live for a limiter.\n\n\n  ttl: (keys) -> @_largest keys, 'ttl'\n\n\n\n\nLimiter#checkThreshold\n\n\n\n\n(array) \nkeys\n - An array of keys, e.g. a flattened array of keys from\n\n\n\n\nFingerprint.inlineKeys\n\n\nCheck the current limiter score against the threshold.\n\n\n  checkThreshold: (keys) ->\n    @score(keys).then (score) => score > @threshold.score()\n\n\n\n\nLimiter#_largest\n\n\nFind the largest result from a group of results.\n\n\n  _largest: (keys, index) ->\n    Promise.all(\n      @limiter[index] key for key in keys\n\n    ).then (reduction) ->\n      reduction.reduce ((l, r) -> if l > r then l else r), -Infinity\n\nclass LimiterManager\n\n\n\n\nconstructor\n\n\n\n\n(string) \nkey\n - A unique key for this limiter, e.g.\n\n\n\n\n\"rpc://shrub-user/login:limiter\"\n\n\n\n\n(Threshold) \nthreshold\n - A threshold, see below for details.\n\n\n\n\n...\n\n\n  constructor: (@key, @threshold) ->\n\n\n\n\nLimiterManager#add\n\n\n\n\n\n\n(string) \nid\n - The ID of the limiter.\n\n\n\n\n\n\n(Number) \nscore\n - The score to add. Defaults to 1.\n\n\n\n\n\n\nAdd score to a limiter.\n\n\n  accrue: (id, score = 1) ->\n    key = \"#{@key}:#{id}\"\n\n    Limit = orm.collection 'shrub-limit'\n    Limit.findOrCreate(\n      key: key\n    ,\n      key: key\n    ).populateAll().then((limit) =>\n\n\n\n\nReset if it's expired.\n\n\n      limit.reset() if 0 >= limit.ttl @threshold\n\n      return limit\n\n    ).then (limit) -> limit.accrue(parseInt score).save()\n\n\n\n\nLimiterManager#score\n\n\n\n\n(string) \nid\n - The ID of the limiter.\n\n\n\n\nCheck score for a limiter.\n\n\n  score: (id) ->\n\n\n\n\nGet all scores for this limiter.\n\n\n    Limit = orm.collection 'shrub-limit'\n    Limit.findOne(key: \"#{@key}:#{id}\").populateAll().then (limit) =>\n      return 0 unless limit?\n      return limit.score() if 0 < limit.ttl @threshold\n\n\n\n\nReset if it's expired.\n\n\n      limit.reset().save().then -> 0\n\n\n\n\nLimiterManager#ttl\n\n\n\n\n(string) \nid\n - The ID of the limiter.\n\n\n\n\nTime-to-live for a limiter.\n\n\n  ttl: (id) ->\n\n    Limit = orm.collection 'shrub-limit'\n    Limit.findOne(key: \"#{@key}:#{id}\").then (limit) =>\n      return 0 unless limit?\n      return ttl if 0 < ttl = limit.ttl @threshold\n\n\n\n\nReset if it's expired.\n\n\n      limit.reset().save().then -> 0\n\n\n\n\nThresholdBase\n\n\nThe base class used to define a threshold.\n\n\nclass ThresholdBase\n\n\n\n\nconstructor\n\n\n\n\n(Number) \nscore\n - The maximum score allowed to accrue.\n\n\n\n\nCreate a threshold base object.\n\n\n  constructor: (@_score) ->\n\n\n\n\nThresholdBase#every\n\n\n\n\n(Number) \namount\n - The quantity of time units this threshold concerns\ne.g,\n\n\n\n\nif the threshold is every 5 minutes, this will be \n5\n. \nDefine the\nquantity of time this threshold concerns.\n\n\n  every: (amount) -> new ThresholdMultiplier @_score, amount\n\n\n\n\nThresholdMultiplier\n\n\nA threshold class to collect the multiplier.\n\n\nclass ThresholdMultiplier\n\n\n\n\nconstructor\n\n\n\n\n\n\n(Number) \nscore\n - Passed along from ThresholdBase.\n\n\n\n\n\n\n(Number) \namount\n - Passed along from ThresholdBase.\n\n\n\n\n\n\nCreate a threshold.\n\n\n  constructor: (@_score, @_amount) ->\n\n    @_multiplier = 1\n\n\n\n\nThresholdMultiplier#milliseconds\n\n\nThresholdMultiplier#seconds\n\n\nThresholdMultiplier#minutes\n\n\nAdd a method for each multipler. This is this way just to DRY things up.\n\n\n  multipliers =\n    milliseconds: 1 / 1000\n    seconds: 1\n    minutes: 60\n\n  for key, multiplier of multipliers\n    do (key, multiplier) ->\n      ThresholdMultiplier::[key] = ->\n        @_multiplier = multiplier\n\n\n\n\nReturn a finalized threshold.\n\n\n        new ThresholdFinal @_score, @_amount, @_multiplier\n\n\n\n\nThresholdFinal\n\n\nA finalized threshold definition.\n\n\nclass ThresholdFinal\n\n\n\n\nconstructor\n\n\n\n\n\n\n(Number) \nscore\n - Passed along from ThresholdMultiplier.\n\n\n\n\n\n\n(Number) \namount\n - Passed along from ThresholdMultiplier.\n\n\n\n\n\n\n(Number) \nmultiplier\n - Passed along from ThresholdMultiplier.\n\n\n\n\n\n\nCreate a threshold.\n\n\n  constructor: (score, amount, multiplier) ->\n\n    @calculateSeconds = -> amount * multiplier\n    @score = -> score",
            "title": "limiter.coffee"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limiter",
            "text": "ORM-backed limit handling. Accrue and check scores, and check Time-to-live\nacross multiple  fingerprint keys .  Promise = null\n\norm = null",
            "title": "Limiter"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limiter_1",
            "text": "Provides methods to tally scores, and compare them against a threshold of\ntime. The  limiter  package implements hook shrubRpcRoutesAlter  to allow RPC routes to\nlimit consumers to a specified number of requests per time period. For\ninstance, by default the  user login  route\nlimits the number of logins a user may attempt to 3 every 30 seconds.  module.exports = class Limiter",
            "title": "Limiter"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limiterthreshold",
            "text": "Expose a factory method for constructing Threshold instances. A Threshold\nis defined like:  var Limiter = require('shrub-limiter').Limiter;\nLimiter.threshold(4).every(20).minutes();  Which means that the\nthreshold represents the allowance of a score of 4 to accumulate over the\nperiod of 20 minutes. If more score is accrued during that window, then\nthe threshold is said to be crossed.    @threshold: (score) -> new ThresholdBase score",
            "title": "Limiter.threshold"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#constructor",
            "text": "(string)  key  - A unique key for this limiter, e.g.   \"rpc://shrub-user/login:limiter\"   (Threshold)  threshold  - A threshold, see below for details.   Create a limiter.    constructor: (key, @threshold, @excluded = []) ->  Ensure it's a threshold.      throw new TypeError(\n      \"Limiter(#{key}) must be constructed with a valid threshold!\"\n    ) unless @threshold instanceof ThresholdFinal\n\n    Promise ?= require 'bluebird'\n\n    orm ?= require 'shrub-orm'  Create the low-level limiter.      @limiter = new LimiterManager key, @threshold.calculateSeconds()",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limiteradd",
            "text": "(array)  keys  - An array of keys, e.g. a flattened array of keys from   Fingerprint.inlineKeys   (Number)  score  - The score to add. Defaults to 1.   Accrue score for a limiter.    accrue: (keys, score = 1) ->\n    Promise.all (@limiter.accrue key, score for key in keys)",
            "title": "Limiter#add"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limiteraccrueandcheckthreshold",
            "text": "(array)  keys  - An array of keys, e.g. a flattened array of keys from   Fingerprint.inlineKeys   (integer)  score  - The score to add. Defaults to 1.   Add score to a limiter, and check it against the threshold.    accrueAndCheckThreshold: (keys, score = 1) ->\n    @accrue(keys, score).then => @checkThreshold keys",
            "title": "Limiter#accrueAndCheckThreshold"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limiterscore",
            "text": "(array)  keys  - An array of keys, e.g. a flattened array of keys from   Fingerprint.inlineKeys  Check score for a limiter.    score: (keys) -> @_largest keys, 'score'",
            "title": "Limiter#score"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limiterttl",
            "text": "(array)  keys  - An array of keys, e.g. a flattened array of keys from   Fingerprint.inlineKeys  Time-to-live for a limiter.    ttl: (keys) -> @_largest keys, 'ttl'",
            "title": "Limiter#ttl"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limitercheckthreshold",
            "text": "(array)  keys  - An array of keys, e.g. a flattened array of keys from   Fingerprint.inlineKeys  Check the current limiter score against the threshold.    checkThreshold: (keys) ->\n    @score(keys).then (score) => score > @threshold.score()",
            "title": "Limiter#checkThreshold"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limiter_largest",
            "text": "Find the largest result from a group of results.    _largest: (keys, index) ->\n    Promise.all(\n      @limiter[index] key for key in keys\n\n    ).then (reduction) ->\n      reduction.reduce ((l, r) -> if l > r then l else r), -Infinity\n\nclass LimiterManager",
            "title": "Limiter#_largest"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#constructor_1",
            "text": "(string)  key  - A unique key for this limiter, e.g.   \"rpc://shrub-user/login:limiter\"   (Threshold)  threshold  - A threshold, see below for details.   ...    constructor: (@key, @threshold) ->",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limitermanageradd",
            "text": "(string)  id  - The ID of the limiter.    (Number)  score  - The score to add. Defaults to 1.    Add score to a limiter.    accrue: (id, score = 1) ->\n    key = \"#{@key}:#{id}\"\n\n    Limit = orm.collection 'shrub-limit'\n    Limit.findOrCreate(\n      key: key\n    ,\n      key: key\n    ).populateAll().then((limit) =>  Reset if it's expired.        limit.reset() if 0 >= limit.ttl @threshold\n\n      return limit\n\n    ).then (limit) -> limit.accrue(parseInt score).save()",
            "title": "LimiterManager#add"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limitermanagerscore",
            "text": "(string)  id  - The ID of the limiter.   Check score for a limiter.    score: (id) ->  Get all scores for this limiter.      Limit = orm.collection 'shrub-limit'\n    Limit.findOne(key: \"#{@key}:#{id}\").populateAll().then (limit) =>\n      return 0 unless limit?\n      return limit.score() if 0 < limit.ttl @threshold  Reset if it's expired.        limit.reset().save().then -> 0",
            "title": "LimiterManager#score"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#limitermanagerttl",
            "text": "(string)  id  - The ID of the limiter.   Time-to-live for a limiter.    ttl: (id) ->\n\n    Limit = orm.collection 'shrub-limit'\n    Limit.findOne(key: \"#{@key}:#{id}\").then (limit) =>\n      return 0 unless limit?\n      return ttl if 0 < ttl = limit.ttl @threshold  Reset if it's expired.        limit.reset().save().then -> 0",
            "title": "LimiterManager#ttl"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#thresholdbase",
            "text": "The base class used to define a threshold.  class ThresholdBase",
            "title": "ThresholdBase"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#constructor_2",
            "text": "(Number)  score  - The maximum score allowed to accrue.   Create a threshold base object.    constructor: (@_score) ->",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#thresholdbaseevery",
            "text": "(Number)  amount  - The quantity of time units this threshold concerns\ne.g,   if the threshold is every 5 minutes, this will be  5 .  Define the\nquantity of time this threshold concerns.    every: (amount) -> new ThresholdMultiplier @_score, amount",
            "title": "ThresholdBase#every"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#thresholdmultiplier",
            "text": "A threshold class to collect the multiplier.  class ThresholdMultiplier",
            "title": "ThresholdMultiplier"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#constructor_3",
            "text": "(Number)  score  - Passed along from ThresholdBase.    (Number)  amount  - Passed along from ThresholdBase.    Create a threshold.    constructor: (@_score, @_amount) ->\n\n    @_multiplier = 1",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#thresholdmultipliermilliseconds",
            "text": "",
            "title": "ThresholdMultiplier#milliseconds"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#thresholdmultiplierseconds",
            "text": "",
            "title": "ThresholdMultiplier#seconds"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#thresholdmultiplierminutes",
            "text": "Add a method for each multipler. This is this way just to DRY things up.    multipliers =\n    milliseconds: 1 / 1000\n    seconds: 1\n    minutes: 60\n\n  for key, multiplier of multipliers\n    do (key, multiplier) ->\n      ThresholdMultiplier::[key] = ->\n        @_multiplier = multiplier  Return a finalized threshold.          new ThresholdFinal @_score, @_amount, @_multiplier",
            "title": "ThresholdMultiplier#minutes"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#thresholdfinal",
            "text": "A finalized threshold definition.  class ThresholdFinal",
            "title": "ThresholdFinal"
        },
        {
            "location": "/source/packages/shrub-limiter/limiter/#constructor_4",
            "text": "(Number)  score  - Passed along from ThresholdMultiplier.    (Number)  amount  - Passed along from ThresholdMultiplier.    (Number)  multiplier  - Passed along from ThresholdMultiplier.    Create a threshold.    constructor: (score, amount, multiplier) ->\n\n    @calculateSeconds = -> amount * multiplier\n    @score = -> score",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-nodemailer/",
            "text": "nodemailer\n\n\nRenders and sends email.\n\n\nPromise = null\n\nconfig = null\n\nskin = null\n\n\n\n\nSandbox used to render email as HTML.\n\n\nsandbox = null\n\n\n\n\nnodemailer transport. Defaults to sendmail.\n\n\ntransport = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    Promise = require 'bluebird'\n\n    config = require 'config'\n\n    skin = require 'shrub-skin'\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    nodemailer = require 'nodemailer'\n\n    {Sandbox} = require 'sandboxes'\n\n    label: 'Bootstrap nodemailer'\n    middleware: [\n\n      (next) ->\n\n        settings = config.get 'packageConfig:shrub-nodemailer'\n\n\n\n\nInstantiate the email transport.\n\n\n        transport = nodemailer.createTransport(\n          require(settings.transport.module)(\n            settings.transport.options\n          )\n        )\n\n\n\n\nRender the app HTML and create a sandbox with it.\n\n\n        skin.renderAppHtml().then((html) ->\n\n          sandbox = new Sandbox()\n\n          sandbox.createDocument html, url: \"http://localhost:#{\n            config.get 'packageConfig:shrub-http:port'\n          }/home\"\n\n        ).then(->\n\n\n\n\nAugment it with functionality we'll find useful and convenient.\n\n\n          augmentSandbox sandbox\n\n        ).then(-> next()).catch next\n\n    ]\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n\n\n\nDefault site email information.\n\n\n    siteEmail:\n      address: 'admin@example.com'\n      name: 'Site administrator'\n\n\n\n\nPassed through directly to nodemailer.\n\n\n    transport:\n      module: 'nodemailer-sendmail-transport'\n      options: {}\n\n\n\n\nImplements hook \nshrubReplContext\n\n\nProvide mail sending to the REPL context.\n\n\n  registrar.registerHook 'shrubReplContext', (context) ->\n    context.sendMail = exports.sendMail\n\n\n\n\nsendMail\n\n\n\n\n\n\n(string) \ndirective\n - The path of the email directive to send.\n\n\n\n\n\n\n(object) \nmail\n - See \nthe nodemailer\nexample\n\n\n\n\n\n\nfor an example of the structure of this object.\n\n\n\n\n(object) \nscope\n - Object whose values will be injected into the directive\n\n\n\n\nscope when compiling the directive for the email output. \nSend an email.\n\n\nexports.sendMail = (directive, mail, scope) ->\n\n  path = config.get 'path'\n  siteEmail = config.get 'packageConfig:shrub-nodemailer:siteEmail'\n\n  Promise.resolve().then(->\n\n    sandbox.inject [\n      '$rootScope', '$compile'\n      ($rootScope, $compile) ->\n\n        $scope = $rootScope.$new()\n        $scope[key] = value for key, value of scope\n        $element = $compile(\"<div data-#{directive}></div>\")($scope)\n\n\n\n\nJust to be sure :)\n\n\n        $rootScope.$digest() for i in [0...10]\n\n        sandbox.prepareHtmlForEmail $element.html()\n\n    ]\n\n  ).then((html) ->\n\n    mail.html = html if html?\n\n  ).then(->\n\n\n\n\nIf the from field wasn't specified, look it up in the configuration.\n\n\n    unless mail.from\n      unless siteEmail.address\n        throw new Error 'Email sent without `from` field, and no site email address is defined!'\n\n\n\n\nUse the address by default.\n\n\n      mail.from = siteEmail.address\n\n\n\n\nFormat if there is a site email name\n\n\n      mail.from = \"#{siteEmail.name} <#{mail.from}>\" if siteEmail.name\n\n\n\n\nParse the HTML to plain text as a default if no plain text was provided.\n\n\n    mail.text ?= sandbox.text mail.html if mail.html?\n\n\n\n\nSend the mail.\n\n\n    new Promise (resolve, reject) ->\n      transport.sendMail mail, (error) ->\n\n        return reject error if error?\n        resolve()\n\n  )\n\n\n\n\nAugment the sandbox with the ability to rewrite HTML for email, and emit\nHTML as text.\n\n\naugmentSandbox = (sandbox) ->\n\n\n\n\nConvenience.\n\n\n  $ = sandbox._window.$\n\n  selectors = {}\n\n  htmlCssText = ''\n  bodyCssText = ''\n\n\n\n\nGather all CSS selectors and rules ahead of time.\n\n\n  gatherSelectors = ->\n    for stylesheet in sandbox._window.document.styleSheets\n      for rule in stylesheet.cssRules\n        continue unless rule.selectorText?\n\n\n\n\nSplit into individual selectors.\n\n\n        parts = rule.selectorText.split(',').map((selector) ->\n\n\n\n\nTrim whitespace.\n\n\n          selector.trim()\n\n        ).filter (selector) ->\n\n\n\n\nFilter pseudo selectors.\n\n\n          return false if selector.match /[:@]/\n\n\n\n\nCollect html and body rules manually.\n\n\n          if selector is 'html'\n            htmlCssText += rule.style.cssText\n            return false\n\n          if selector is 'body'\n            bodyCssText += rule.style.cssText\n            return false\n\n          true\n\n\n\n\nRejoin the selectors.\n\n\n        selector = parts.join ','\n\n\n\n\nNormalize the rule(s).\n\n\n        selectors[selector] ?= ''\n        selectors[selector] += rule.style.cssText.split(\n\n          ';'\n\n        ).filter((rule) ->\n\n          rule isnt ''\n\n        ).map((rule) ->\n\n          rule.trim()\n\n        ).sort().join '; '\n        selectors[selector] += ';'\n\n\n\n\nMerge as many rules as we can, so we'll have less work to do for each\napplication.\n\n\n    cssTextCache = {}\n    for selector, cssText of selectors\n      (cssTextCache[cssText] ?= []).push selector\n\n    for cssText, selectors_ of cssTextCache\n      selectors[selectors_.join ','] = cssText\n\n\n\n\nSandbox#inject\n\n\n\n\n(any) \ninjectable\n - An annotated function to inject with\n\n\n\n\ndependencies. \nInject an \nannotated\nfunction\n with\ndependencies.\n\n\n  sandbox.inject = (injectable) ->\n    injector = @_window.angular.element(@_window.document).injector()\n    injector.invoke injectable\n\n\n\n\nSandbox#inlineCss\n\n\nCREDIT:\nhttp://devintorr.es/blog/2010/05/26/turn-css-rules-into-inline-style-attributes-using-jquery/\nwith some improvements, of course.\n\n\n  sandbox.inlineCss = (html) ->\n    for selector, cssText of selectors\n      for element in $(selector, $(html))\n        element.style.cssText += cssText\n\n\n\n\nSandbox#prepareHtmlForEmail\n\n\nPrepare HTML for email; inject all CSS inline and allow the skin to\nmodify the output.\n\n\n  sandbox.prepareHtmlForEmail = (html) ->\n\n\n\n\nClone the body and insert the HTML into the main application area.\n\n\n    $body = $('body').clone()\n\n\n\n\nInvoke hook \nshrubNodemailerHtml\n\n\nLet the skin manage the mail HTML.\n\n\n    pkgman = require 'pkgman'\n    pkgman.invokePackage skin.activeKey(), 'shrubNodemailerHtml', $body, html, $\n\n\n\n\nInject all the styles inline.\n\n\n    sandbox.inlineCss $body\n\n\n\n\nReturn a valid HTML document.\n\n\n    \"\"\"\n<!doctype html>\n<html style=#{htmlCssText}\">\n<body style=#{bodyCssText}\">\n\n\n\n\n$body.html()}\n\n\n</body>\n</html>\n\"\"\"\n\n\n\n\nSandbox#text\n\n\nConvert HTML to text.\n\n\n  sandbox.text = (html) ->\n\n    text = $(html).text()\n\n\n\n\nRemove tab characters.\n\n\n    text = text.replace /\\t/g, ''\n\n\n\n\nRemove excessive empty lines.\n\n\n    emptyLines = 0\n    text = text.split('').reduce(\n      (l, r) ->\n\n        if (l.slice -1) is '\\n' and r is '\\n'\n          emptyLines += 1\n        else\n          emptyLines = 0\n\n        if emptyLines > 1\n          l\n        else\n          l + r\n\n      ''\n    ).trim()\n\n  new Promise (resolve) ->\n\n    sandbox.inject [\n      '$sniffer', 'shrub-socket'\n      ($sniffer, socket) ->\n\n\n\n\nDon't even try HTML 5 history on the server side.\n\n\n        $sniffer.history = false\n\n\n\n\nLet the socket finish initialization.\n\n\n        socket.on 'initialized', ->\n\n          gatherSelectors()\n\n          resolve sandbox\n\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-nodemailer/#nodemailer",
            "text": "Renders and sends email.  Promise = null\n\nconfig = null\n\nskin = null  Sandbox used to render email as HTML.  sandbox = null  nodemailer transport. Defaults to sendmail.  transport = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    Promise = require 'bluebird'\n\n    config = require 'config'\n\n    skin = require 'shrub-skin'  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    nodemailer = require 'nodemailer'\n\n    {Sandbox} = require 'sandboxes'\n\n    label: 'Bootstrap nodemailer'\n    middleware: [\n\n      (next) ->\n\n        settings = config.get 'packageConfig:shrub-nodemailer'  Instantiate the email transport.          transport = nodemailer.createTransport(\n          require(settings.transport.module)(\n            settings.transport.options\n          )\n        )  Render the app HTML and create a sandbox with it.          skin.renderAppHtml().then((html) ->\n\n          sandbox = new Sandbox()\n\n          sandbox.createDocument html, url: \"http://localhost:#{\n            config.get 'packageConfig:shrub-http:port'\n          }/home\"\n\n        ).then(->  Augment it with functionality we'll find useful and convenient.            augmentSandbox sandbox\n\n        ).then(-> next()).catch next\n\n    ]  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->  Default site email information.      siteEmail:\n      address: 'admin@example.com'\n      name: 'Site administrator'  Passed through directly to nodemailer.      transport:\n      module: 'nodemailer-sendmail-transport'\n      options: {}  Implements hook  shrubReplContext  Provide mail sending to the REPL context.    registrar.registerHook 'shrubReplContext', (context) ->\n    context.sendMail = exports.sendMail",
            "title": "nodemailer"
        },
        {
            "location": "/source/packages/shrub-nodemailer/#sendmail",
            "text": "(string)  directive  - The path of the email directive to send.    (object)  mail  - See  the nodemailer\nexample    for an example of the structure of this object.   (object)  scope  - Object whose values will be injected into the directive   scope when compiling the directive for the email output.  Send an email.  exports.sendMail = (directive, mail, scope) ->\n\n  path = config.get 'path'\n  siteEmail = config.get 'packageConfig:shrub-nodemailer:siteEmail'\n\n  Promise.resolve().then(->\n\n    sandbox.inject [\n      '$rootScope', '$compile'\n      ($rootScope, $compile) ->\n\n        $scope = $rootScope.$new()\n        $scope[key] = value for key, value of scope\n        $element = $compile(\"<div data-#{directive}></div>\")($scope)  Just to be sure :)          $rootScope.$digest() for i in [0...10]\n\n        sandbox.prepareHtmlForEmail $element.html()\n\n    ]\n\n  ).then((html) ->\n\n    mail.html = html if html?\n\n  ).then(->  If the from field wasn't specified, look it up in the configuration.      unless mail.from\n      unless siteEmail.address\n        throw new Error 'Email sent without `from` field, and no site email address is defined!'  Use the address by default.        mail.from = siteEmail.address  Format if there is a site email name        mail.from = \"#{siteEmail.name} <#{mail.from}>\" if siteEmail.name  Parse the HTML to plain text as a default if no plain text was provided.      mail.text ?= sandbox.text mail.html if mail.html?  Send the mail.      new Promise (resolve, reject) ->\n      transport.sendMail mail, (error) ->\n\n        return reject error if error?\n        resolve()\n\n  )  Augment the sandbox with the ability to rewrite HTML for email, and emit\nHTML as text.  augmentSandbox = (sandbox) ->  Convenience.    $ = sandbox._window.$\n\n  selectors = {}\n\n  htmlCssText = ''\n  bodyCssText = ''  Gather all CSS selectors and rules ahead of time.    gatherSelectors = ->\n    for stylesheet in sandbox._window.document.styleSheets\n      for rule in stylesheet.cssRules\n        continue unless rule.selectorText?  Split into individual selectors.          parts = rule.selectorText.split(',').map((selector) ->  Trim whitespace.            selector.trim()\n\n        ).filter (selector) ->  Filter pseudo selectors.            return false if selector.match /[:@]/  Collect html and body rules manually.            if selector is 'html'\n            htmlCssText += rule.style.cssText\n            return false\n\n          if selector is 'body'\n            bodyCssText += rule.style.cssText\n            return false\n\n          true  Rejoin the selectors.          selector = parts.join ','  Normalize the rule(s).          selectors[selector] ?= ''\n        selectors[selector] += rule.style.cssText.split(\n\n          ';'\n\n        ).filter((rule) ->\n\n          rule isnt ''\n\n        ).map((rule) ->\n\n          rule.trim()\n\n        ).sort().join '; '\n        selectors[selector] += ';'  Merge as many rules as we can, so we'll have less work to do for each\napplication.      cssTextCache = {}\n    for selector, cssText of selectors\n      (cssTextCache[cssText] ?= []).push selector\n\n    for cssText, selectors_ of cssTextCache\n      selectors[selectors_.join ','] = cssText",
            "title": "sendMail"
        },
        {
            "location": "/source/packages/shrub-nodemailer/#sandboxinject",
            "text": "(any)  injectable  - An annotated function to inject with   dependencies.  Inject an  annotated\nfunction  with\ndependencies.    sandbox.inject = (injectable) ->\n    injector = @_window.angular.element(@_window.document).injector()\n    injector.invoke injectable",
            "title": "Sandbox#inject"
        },
        {
            "location": "/source/packages/shrub-nodemailer/#sandboxinlinecss",
            "text": "CREDIT:\nhttp://devintorr.es/blog/2010/05/26/turn-css-rules-into-inline-style-attributes-using-jquery/\nwith some improvements, of course.    sandbox.inlineCss = (html) ->\n    for selector, cssText of selectors\n      for element in $(selector, $(html))\n        element.style.cssText += cssText",
            "title": "Sandbox#inlineCss"
        },
        {
            "location": "/source/packages/shrub-nodemailer/#sandboxpreparehtmlforemail",
            "text": "Prepare HTML for email; inject all CSS inline and allow the skin to\nmodify the output.    sandbox.prepareHtmlForEmail = (html) ->  Clone the body and insert the HTML into the main application area.      $body = $('body').clone()  Invoke hook  shrubNodemailerHtml  Let the skin manage the mail HTML.      pkgman = require 'pkgman'\n    pkgman.invokePackage skin.activeKey(), 'shrubNodemailerHtml', $body, html, $  Inject all the styles inline.      sandbox.inlineCss $body  Return a valid HTML document.      \"\"\"\n<!doctype html>\n<html style=#{htmlCssText}\">\n<body style=#{bodyCssText}\">  $body.html()}  </body>\n</html>\n\"\"\"",
            "title": "Sandbox#prepareHtmlForEmail"
        },
        {
            "location": "/source/packages/shrub-nodemailer/#sandboxtext",
            "text": "Convert HTML to text.    sandbox.text = (html) ->\n\n    text = $(html).text()  Remove tab characters.      text = text.replace /\\t/g, ''  Remove excessive empty lines.      emptyLines = 0\n    text = text.split('').reduce(\n      (l, r) ->\n\n        if (l.slice -1) is '\\n' and r is '\\n'\n          emptyLines += 1\n        else\n          emptyLines = 0\n\n        if emptyLines > 1\n          l\n        else\n          l + r\n\n      ''\n    ).trim()\n\n  new Promise (resolve) ->\n\n    sandbox.inject [\n      '$sniffer', 'shrub-socket'\n      ($sniffer, socket) ->  Don't even try HTML 5 history on the server side.          $sniffer.history = false  Let the socket finish initialization.          socket.on 'initialized', ->\n\n          gatherSelectors()\n\n          resolve sandbox\n\n    ]",
            "title": "Sandbox#text"
        },
        {
            "location": "/source/packages/shrub-orm/client/",
            "text": "Object-relational mapping\n\n\nThis is mostly stubbed for the browser. I can't justify sending a 400k ORM\nlibrary to the client, even though it would be awesome.\n\n\nPromise = require 'bluebird'\n\npkgman = require 'pkgman'\n\ncollections = {}\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularService\n\n\n  registrar.registerHook 'shrubAngularService', -> [\n    '$http'\n    ($http) ->\n\n      service = {}\n\n      exports.initialize()\n\n\n\n\norm.collection\n\n\n\n\n(String) \nidentity\n - Collection identity. e.g. \n'shrub-user'\n\n\n\n\nGet a collection by identity.\n\n\n      service.collection = (identity) -> collections[identity]\n\n\n\n\norm.collections\n\n\nGet all collections.\n\n\n      service.collections = -> collections\n\n      service\n\n  ]\n\nexports.initialize = ->\n\n\n\n\nInvoke hook \nshrubOrmCollections\n\n\n  collections_ = {}\n  for collectionList in pkgman.invokeFlat 'shrubOrmCollections'\n    for identity, collection of collectionList\n\n\n\n\nCollection defaults.\n\n\n      collection.identity ?= identity\n      collections_[collection.identity] = collection\n\n\n\n\nInstantiate a model with defaults supplied.\n\n\n      collection.instantiate = (values = {}) ->\n        model = JSON.parse JSON.stringify values\n\n        if not @autoCreatedAt? or @autoCreatedAt is true\n          model.createdAt = new Date values.createdAt ? Date.now()\n\n        if not @autoUpdatedAt? or @autoUpdatedAt is true\n          model.updatedAt = new Date values.updatedAt ? Date.now()\n\n        for key, value of @attributes\n\n\n\n\nSet functions.\n\n\n          model[key] = value if 'function' is typeof value\n\n\n\n\nSet any model defaults.\n\n\n          if value.defaultsTo?\n            model[key] ?= if 'function' is typeof value.defaultsTo\n              value.defaultsTo.call model\n            else\n              JSON.parse JSON.stringify value.defaultsTo\n\n\n\n\nHandle dates.\n\n\n          if model[key]? and 'date' is value or 'date' is value.type\n            model[key] = new Date model[key]\n\n        model\n\n\n\n\nInvoke hook \nshrubOrmCollectionsAlter\n\n\n  pkgman.invoke 'shrubOrmCollectionsAlter', collections_\n\n  collections = collections_",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-orm/client/#object-relational-mapping",
            "text": "This is mostly stubbed for the browser. I can't justify sending a 400k ORM\nlibrary to the client, even though it would be awesome.  Promise = require 'bluebird'\n\npkgman = require 'pkgman'\n\ncollections = {}\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularService    registrar.registerHook 'shrubAngularService', -> [\n    '$http'\n    ($http) ->\n\n      service = {}\n\n      exports.initialize()",
            "title": "Object-relational mapping"
        },
        {
            "location": "/source/packages/shrub-orm/client/#ormcollection",
            "text": "(String)  identity  - Collection identity. e.g.  'shrub-user'   Get a collection by identity.        service.collection = (identity) -> collections[identity]",
            "title": "orm.collection"
        },
        {
            "location": "/source/packages/shrub-orm/client/#ormcollections",
            "text": "Get all collections.        service.collections = -> collections\n\n      service\n\n  ]\n\nexports.initialize = ->  Invoke hook  shrubOrmCollections    collections_ = {}\n  for collectionList in pkgman.invokeFlat 'shrubOrmCollections'\n    for identity, collection of collectionList  Collection defaults.        collection.identity ?= identity\n      collections_[collection.identity] = collection  Instantiate a model with defaults supplied.        collection.instantiate = (values = {}) ->\n        model = JSON.parse JSON.stringify values\n\n        if not @autoCreatedAt? or @autoCreatedAt is true\n          model.createdAt = new Date values.createdAt ? Date.now()\n\n        if not @autoUpdatedAt? or @autoUpdatedAt is true\n          model.updatedAt = new Date values.updatedAt ? Date.now()\n\n        for key, value of @attributes  Set functions.            model[key] = value if 'function' is typeof value  Set any model defaults.            if value.defaultsTo?\n            model[key] ?= if 'function' is typeof value.defaultsTo\n              value.defaultsTo.call model\n            else\n              JSON.parse JSON.stringify value.defaultsTo  Handle dates.            if model[key]? and 'date' is value or 'date' is value.type\n            model[key] = new Date model[key]\n\n        model  Invoke hook  shrubOrmCollectionsAlter    pkgman.invoke 'shrubOrmCollectionsAlter', collections_\n\n  collections = collections_",
            "title": "orm.collections"
        },
        {
            "location": "/source/packages/shrub-orm/",
            "text": "Object-relational mapping\n\n\nTools for working with\n\nWaterline\n.\n\n\nrequire('events').EventEmitter.prototype._maxListeners = 100\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\nWaterline = null\n\ncollections = {}\nconnections = {}\n\nwaterline = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    Waterline = require 'waterline'\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    waterline = new Waterline()\n\n    label: 'Bootstrap ORM'\n    middleware: [\n\n      (next) -> exports.initialize next\n\n    ]\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-orm'\n\n    gruntConfig.registerTask 'build:shrub-orm', [\n      'newer:copy:shrub-orm'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-orm']\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n\n\n\nThe available adapters. This is a list of module names. We provide\nsails-redis by default.\n\n\n    adapters: [\n      'sails-redis'\n    ]\n\n\n\n\nThe available connnections. This is a keyed list of available\nconnections which are defined as an adapter and the configuration for\nthe adapter. The entries in the \nadapters\n list are available for use\nhere. We provide a \nshrub\n connection by default, which uses the\nsails-redis adapter with defaults.\n\n\n    connections:\n\n      shrub:\n\n        adapter: 'sails-redis'\n        port: 6379\n        host: 'localhost'\n        password: null\n        database: null\n\n\n\n\nImplements hook \nshrubReplContext\n\n\nProvide ORM to the REPL context.\n\n\n  registrar.registerHook 'shrubReplContext', (context) -> context.orm = exports\n\n\n\n\norm.initialize\n\n\n\n\n(Function) \nfn\n - Nodeback called when initialization completes.\n\n\n\n\nSpin up Waterline with our configuration.\n\n\nexports.initialize = (fn) ->\n\n  config_ = config.get 'packageConfig:shrub-orm'\n\n  waterlineConfig = adapters: {}, connections: {}\n\n\n\n\nrequire\n all the adapter modules.\n\n\n  for adapter in config_.adapters\n    waterlineConfig.adapters[adapter] = require adapter\n\n  waterlineConfig.connections = config_.connections\n\n\n\n\nInvoke hook \nshrubOrmCollections\n\n\n  collections_ = {}\n  for collectionList in pkgman.invokeFlat 'shrubOrmCollections', waterline\n    for identity, collection of collectionList\n\n\n\n\nSet collection defaults.\n\n\n      collection.connection ?= 'shrub'\n      collection.identity ?= identity\n      collection.migrate ?= 'create'\n      collections_[collection.identity] = collection\n\n\n\n\nCollection#instantiate.\n\n\n\n\n(Object) \nvalues\n - An object with values to populate the model\nproperties.\n\n\n\n\nInstantiate a model with defaults supplied.\n\n\n      collection.instantiate = (values = {}) ->\n\n        for key, value of @attributes\n          continue unless value.defaultsTo?\n\n\n\n\nSet any model defaults.\n\n\n          values[key] ?= if 'function' is typeof value.defaultsTo\n            value.defaultsTo.call values\n          else\n            JSON.parse JSON.stringify value.defaultsTo\n\n\n\n\nReach into Waterline a bit, hackish but they simply don't provide us\nwith a sane API for this.\n\n\n        new @_model @_schema.cleanValues @_transformer.serialize values\n\n\n\n\nInvoke hook \nshrubOrmCollectionsAlter\n\n\n  pkgman.invoke 'shrubOrmCollectionsAlter', collections_, waterline\n\n\n\n\nLoad the collections into Waterline.\n\n\n  for i, collection of collections_\n    waterline.loadCollection Waterline.Collection.extend collection\n\n  waterline.initialize waterlineConfig, (error, data) ->\n    return fn error if error?\n\n    collections = data.collections\n    connections = data.connections\n\n    fn()\n\n\n\n\norm.collection\n\n\n\n\n(String) \nidentity\n - Collection identity. e.g. \n'shrub-user'\n\n\n\n\nGet a collection by identity.\n\n\nexports.collection = (identity) -> collections[identity]\n\n\n\n\norm.collections\n\n\nGet all collections.\n\n\nexports.collections = -> collections\n\n\n\n\norm.connections\n\n\nGet all connections.\n\n\nexports.connections = -> connections\n\n\n\n\norm.teardown\n\n\n\n\n(Function) \nfn\n - Nodeback called after teardown.\n\n\n\n\nTear down Waterline.\n\n\nexports.teardown = (fn) -> waterline.teardown fn\n\n\n\n\norm.waterline\n\n\nGet the Waterline instance.\n\n\nexports.waterline = -> waterline",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-orm/#object-relational-mapping",
            "text": "Tools for working with Waterline .  require('events').EventEmitter.prototype._maxListeners = 100\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\nWaterline = null\n\ncollections = {}\nconnections = {}\n\nwaterline = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    Waterline = require 'waterline'  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    waterline = new Waterline()\n\n    label: 'Bootstrap ORM'\n    middleware: [\n\n      (next) -> exports.initialize next\n\n    ]  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-orm'\n\n    gruntConfig.registerTask 'build:shrub-orm', [\n      'newer:copy:shrub-orm'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-orm']  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->  The available adapters. This is a list of module names. We provide\nsails-redis by default.      adapters: [\n      'sails-redis'\n    ]  The available connnections. This is a keyed list of available\nconnections which are defined as an adapter and the configuration for\nthe adapter. The entries in the  adapters  list are available for use\nhere. We provide a  shrub  connection by default, which uses the\nsails-redis adapter with defaults.      connections:\n\n      shrub:\n\n        adapter: 'sails-redis'\n        port: 6379\n        host: 'localhost'\n        password: null\n        database: null  Implements hook  shrubReplContext  Provide ORM to the REPL context.    registrar.registerHook 'shrubReplContext', (context) -> context.orm = exports",
            "title": "Object-relational mapping"
        },
        {
            "location": "/source/packages/shrub-orm/#orminitialize",
            "text": "(Function)  fn  - Nodeback called when initialization completes.   Spin up Waterline with our configuration.  exports.initialize = (fn) ->\n\n  config_ = config.get 'packageConfig:shrub-orm'\n\n  waterlineConfig = adapters: {}, connections: {}  require  all the adapter modules.    for adapter in config_.adapters\n    waterlineConfig.adapters[adapter] = require adapter\n\n  waterlineConfig.connections = config_.connections  Invoke hook  shrubOrmCollections    collections_ = {}\n  for collectionList in pkgman.invokeFlat 'shrubOrmCollections', waterline\n    for identity, collection of collectionList  Set collection defaults.        collection.connection ?= 'shrub'\n      collection.identity ?= identity\n      collection.migrate ?= 'create'\n      collections_[collection.identity] = collection",
            "title": "orm.initialize"
        },
        {
            "location": "/source/packages/shrub-orm/#collectioninstantiate",
            "text": "(Object)  values  - An object with values to populate the model\nproperties.   Instantiate a model with defaults supplied.        collection.instantiate = (values = {}) ->\n\n        for key, value of @attributes\n          continue unless value.defaultsTo?  Set any model defaults.            values[key] ?= if 'function' is typeof value.defaultsTo\n            value.defaultsTo.call values\n          else\n            JSON.parse JSON.stringify value.defaultsTo  Reach into Waterline a bit, hackish but they simply don't provide us\nwith a sane API for this.          new @_model @_schema.cleanValues @_transformer.serialize values  Invoke hook  shrubOrmCollectionsAlter    pkgman.invoke 'shrubOrmCollectionsAlter', collections_, waterline  Load the collections into Waterline.    for i, collection of collections_\n    waterline.loadCollection Waterline.Collection.extend collection\n\n  waterline.initialize waterlineConfig, (error, data) ->\n    return fn error if error?\n\n    collections = data.collections\n    connections = data.connections\n\n    fn()",
            "title": "Collection#instantiate."
        },
        {
            "location": "/source/packages/shrub-orm/#ormcollection",
            "text": "(String)  identity  - Collection identity. e.g.  'shrub-user'   Get a collection by identity.  exports.collection = (identity) -> collections[identity]",
            "title": "orm.collection"
        },
        {
            "location": "/source/packages/shrub-orm/#ormcollections",
            "text": "Get all collections.  exports.collections = -> collections",
            "title": "orm.collections"
        },
        {
            "location": "/source/packages/shrub-orm/#ormconnections",
            "text": "Get all connections.  exports.connections = -> connections",
            "title": "orm.connections"
        },
        {
            "location": "/source/packages/shrub-orm/#ormteardown",
            "text": "(Function)  fn  - Nodeback called after teardown.   Tear down Waterline.  exports.teardown = (fn) -> waterline.teardown fn",
            "title": "orm.teardown"
        },
        {
            "location": "/source/packages/shrub-orm/#ormwaterline",
            "text": "Get the Waterline instance.  exports.waterline = -> waterline",
            "title": "orm.waterline"
        },
        {
            "location": "/source/packages/shrub-passport/",
            "text": "Passport integration\n\n\n\n\n\nAuthentication system, leaning on \npassport\n.\n\n\nmiddleware = require 'middleware'\npkgman = require 'pkgman'\n\norm = null\npassport = null\nPromise = null\n\nbeforeLoginMiddleware = null\nafterLoginMiddleware = null\nbeforeLogoutMiddleware = null\nafterLogoutMiddleware = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    orm = require 'shrub-orm'\n    passport = require 'passport'\n    Promise = require 'bluebird'\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    Promise = require 'bluebird'\n\n    label: 'Bootstrap user authorization'\n    middleware: [\n\n      (next) ->\n\n\n\n\nInvoke hook \nshrubUserBeforeLoginMiddleware\n\n\n        beforeLoginMiddleware = middleware.fromConfig(\n          'shrub-user:beforeLoginMiddleware'\n        )\n\n\n\n\nInvoke hook \nshrubUserAfterLoginMiddleware\n\n\n        afterLoginMiddleware = middleware.fromConfig(\n          'shrub-user:afterLoginMiddleware'\n        )\n\n\n\n\nInvoke hook \nshrubUserBeforeLogoutMiddleware\n\n\n        beforeLogoutMiddleware = middleware.fromConfig(\n          'shrub-user:beforeLogoutMiddleware'\n        )\n\n\n\n\nInvoke hook \nshrubUserAfterLogoutMiddleware\n\n\n        afterLogoutMiddleware = middleware.fromConfig(\n          'shrub-user:afterLogoutMiddleware'\n        )\n\n\n\n\nInvoke hook \nshrubUserLoginStrategies\n\n\nUse passport authorization strategies.\n\n\n        strategies = pkgman.invoke 'shrubUserLoginStrategies'\n\n\n\n\nInvoke hook \nshrubUserLoginStrategiesAlter\n\n\n        pkgman.invoke 'shrubUserLoginStrategiesAlter', strategies\n\n        for packageName, strategy of strategies\n          passport.use strategy.passportStrategy\n\n\n\n\nPassport serialization callback. Store the user ID.\n\n\n        passport.serializeUser (user, done) -> done null, user.id\n\n\n\n\nPassport deserialization callback.\n\n\n        passport.deserializeUser (req, id, done) ->\n\n\n\n\nLoad user based on ID\n\n\n          promise = orm.collection(\n            'shrub-user'\n          ).findOnePopulated(\n            id: id\n          ).then((user) ->\n\n\n\n\nPass in the user to be logged in through the request.\n\n\n            req.loggingInUser = user\n\n\n\n\nInvoke the \nbeforeLogin\n middleware.\n\n\n            new Promise (resolve, reject) ->\n              beforeLoginMiddleware.dispatch req, (error) ->\n                return reject error if error?\n                resolve user\n\n          ).nodeify done\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\n  registrar.registerHook 'shrubHttpMiddleware', ->\n\n    label: 'Load user using passport'\n    middleware: passportMiddleware()\n\n\n\n\nImplements hook \nshrubRpcRoutesAlter\n\n\n  registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    {spliceRouteMiddleware} = require 'shrub-rpc'\n\n\n\n\nImplement \nreq.loadUser\n.\n\n\n    loadUserMiddleware = (req, res, next) ->\n\n\n\n\nBootstrap Passport into a request.\n\n\n      req.loadUser = (done) -> req.loadSession ->\n\n        passportMiddleware_ = new Middleware()\n        passportMiddleware_.use fn for fn in passportMiddleware()\n        passportMiddleware_.dispatch req, res, (error) ->\n          return next error if error?\n          done()\n\n      next()\n\n\n\n\nMake sure loadUser is available early.\n\n\n    loadUserMiddleware.weight = -4999\n\n    for path, route of routes\n\n\n\n\nPrepend the loadUser bootstrapping.\n\n\n      route.middleware.unshift loadUserMiddleware\n\n\n\n\nSplice in Passport middleware.\n\n\n      spliceRouteMiddleware route, 'shrub-passport', passportMiddleware()\n\n    return\n\n\n\n\nImplements hook \nshrubSocketConnectionMiddleware\n\n\n  registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Load user using passport'\n\n\n\n\nJoin a channel for the username.\n\n\n    middleware: passportMiddleware()\n\n  registrar.recur [\n    'logout'\n  ]\n\npassportMiddleware = -> [\n\n\n\n\nPassport middleware.\n\n\n  passport.initialize()\n  passport.session()\n\n  (req, res, next) ->\n\n\n\n\nreq.authorize\n\n\n\n\n\n\n(string) \nmethod\n - The authorization method.\n\n\n\n\n\n\n(response) \nres\n - The HTTP/socket response object.\n\n\n\n\n\n\nAuthorize a user instance.\n\n\n    req.authorize = (method, options, res) ->\n      self = this\n\n      unless res?\n        res = options\n        options = {}\n\n      new Promise (resolve, reject) ->\n\n        self._passport.instance.authenticate(\n          method\n          options\n          (error, user, info) ->\n            return reject error if error?\n            resolve user, info\n\n        ) self, res\n\n    next()\n\n\n\n\nInvoke after login middleware if a user already exists in the session.\n\n\n  (req, res, next) ->\n    return next() unless req.user?\n\n    promise = new Promise (resolve, reject) ->\n      afterLoginMiddleware.dispatch req, (error) ->\n        return reject error if error?\n        resolve()\n\n    promise.nodeify next\n\n    promise.finally -> delete req.loggingInUser\n\n\n\n\nProxy req.log[iI]n to run our middleware, and\nreturn a promise.\n\n\n  (req, res, next) ->\n\n    login = req.login\n    req.login = req.logIn = (user, fn) ->\n\n      promise = new Promise (resolve, reject) ->\n\n        req.loggingInUser = user\n\n        beforeLoginMiddleware.dispatch req, (error) ->\n          return reject error if error?\n\n          login.call req, req.loggingInUser, (error) ->\n            return reject error if error?\n\n            afterLoginMiddleware.dispatch req, (error) ->\n              return reject error if error?\n\n              resolve()\n\n      promise.finally -> delete req.loggingInUser\n\n    next()\n\n\n\n\nProxy req.log[oO]ut to run our middleware, and\nreturn a promise.\n\n\n  (req, res, next) ->\n\n    logout = req.logout\n    req.logout = req.logOut = ->\n\n      req.loggingOutUser = req.user\n\n      promise = new Promise (resolve, reject) ->\n\n        beforeLogoutMiddleware.dispatch req, (error) ->\n          return reject error if error?\n\n          logout.call req\n\n          afterLogoutMiddleware.dispatch req, (error) ->\n            return reject error if error?\n\n            resolve()\n\n      promise.finally -> delete req.loggingOutUser\n\n    next()\n\n\n\n\nSave the user at the end of the request.\n\n\n  (req, res, next) ->\n\n    end = res.end\n    res.end = (data, encoding) ->\n      res.end = end\n\n      return res.end data, encoding unless req.user?.id\n\n      req.user.save().finally -> res.end data, encoding\n\n    next()\n\n]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-passport/#passport-integration",
            "text": "Authentication system, leaning on  passport .  middleware = require 'middleware'\npkgman = require 'pkgman'\n\norm = null\npassport = null\nPromise = null\n\nbeforeLoginMiddleware = null\nafterLoginMiddleware = null\nbeforeLogoutMiddleware = null\nafterLogoutMiddleware = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    orm = require 'shrub-orm'\n    passport = require 'passport'\n    Promise = require 'bluebird'  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    Promise = require 'bluebird'\n\n    label: 'Bootstrap user authorization'\n    middleware: [\n\n      (next) ->  Invoke hook  shrubUserBeforeLoginMiddleware          beforeLoginMiddleware = middleware.fromConfig(\n          'shrub-user:beforeLoginMiddleware'\n        )  Invoke hook  shrubUserAfterLoginMiddleware          afterLoginMiddleware = middleware.fromConfig(\n          'shrub-user:afterLoginMiddleware'\n        )  Invoke hook  shrubUserBeforeLogoutMiddleware          beforeLogoutMiddleware = middleware.fromConfig(\n          'shrub-user:beforeLogoutMiddleware'\n        )  Invoke hook  shrubUserAfterLogoutMiddleware          afterLogoutMiddleware = middleware.fromConfig(\n          'shrub-user:afterLogoutMiddleware'\n        )  Invoke hook  shrubUserLoginStrategies  Use passport authorization strategies.          strategies = pkgman.invoke 'shrubUserLoginStrategies'  Invoke hook  shrubUserLoginStrategiesAlter          pkgman.invoke 'shrubUserLoginStrategiesAlter', strategies\n\n        for packageName, strategy of strategies\n          passport.use strategy.passportStrategy  Passport serialization callback. Store the user ID.          passport.serializeUser (user, done) -> done null, user.id  Passport deserialization callback.          passport.deserializeUser (req, id, done) ->  Load user based on ID            promise = orm.collection(\n            'shrub-user'\n          ).findOnePopulated(\n            id: id\n          ).then((user) ->  Pass in the user to be logged in through the request.              req.loggingInUser = user  Invoke the  beforeLogin  middleware.              new Promise (resolve, reject) ->\n              beforeLoginMiddleware.dispatch req, (error) ->\n                return reject error if error?\n                resolve user\n\n          ).nodeify done\n\n        next()\n\n    ]  Implements hook  shrubHttpMiddleware    registrar.registerHook 'shrubHttpMiddleware', ->\n\n    label: 'Load user using passport'\n    middleware: passportMiddleware()  Implements hook  shrubRpcRoutesAlter    registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    {spliceRouteMiddleware} = require 'shrub-rpc'  Implement  req.loadUser .      loadUserMiddleware = (req, res, next) ->  Bootstrap Passport into a request.        req.loadUser = (done) -> req.loadSession ->\n\n        passportMiddleware_ = new Middleware()\n        passportMiddleware_.use fn for fn in passportMiddleware()\n        passportMiddleware_.dispatch req, res, (error) ->\n          return next error if error?\n          done()\n\n      next()  Make sure loadUser is available early.      loadUserMiddleware.weight = -4999\n\n    for path, route of routes  Prepend the loadUser bootstrapping.        route.middleware.unshift loadUserMiddleware  Splice in Passport middleware.        spliceRouteMiddleware route, 'shrub-passport', passportMiddleware()\n\n    return  Implements hook  shrubSocketConnectionMiddleware    registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Load user using passport'  Join a channel for the username.      middleware: passportMiddleware()\n\n  registrar.recur [\n    'logout'\n  ]\n\npassportMiddleware = -> [  Passport middleware.    passport.initialize()\n  passport.session()\n\n  (req, res, next) ->",
            "title": "Passport integration"
        },
        {
            "location": "/source/packages/shrub-passport/#reqauthorize",
            "text": "(string)  method  - The authorization method.    (response)  res  - The HTTP/socket response object.    Authorize a user instance.      req.authorize = (method, options, res) ->\n      self = this\n\n      unless res?\n        res = options\n        options = {}\n\n      new Promise (resolve, reject) ->\n\n        self._passport.instance.authenticate(\n          method\n          options\n          (error, user, info) ->\n            return reject error if error?\n            resolve user, info\n\n        ) self, res\n\n    next()  Invoke after login middleware if a user already exists in the session.    (req, res, next) ->\n    return next() unless req.user?\n\n    promise = new Promise (resolve, reject) ->\n      afterLoginMiddleware.dispatch req, (error) ->\n        return reject error if error?\n        resolve()\n\n    promise.nodeify next\n\n    promise.finally -> delete req.loggingInUser  Proxy req.log[iI]n to run our middleware, and\nreturn a promise.    (req, res, next) ->\n\n    login = req.login\n    req.login = req.logIn = (user, fn) ->\n\n      promise = new Promise (resolve, reject) ->\n\n        req.loggingInUser = user\n\n        beforeLoginMiddleware.dispatch req, (error) ->\n          return reject error if error?\n\n          login.call req, req.loggingInUser, (error) ->\n            return reject error if error?\n\n            afterLoginMiddleware.dispatch req, (error) ->\n              return reject error if error?\n\n              resolve()\n\n      promise.finally -> delete req.loggingInUser\n\n    next()  Proxy req.log[oO]ut to run our middleware, and\nreturn a promise.    (req, res, next) ->\n\n    logout = req.logout\n    req.logout = req.logOut = ->\n\n      req.loggingOutUser = req.user\n\n      promise = new Promise (resolve, reject) ->\n\n        beforeLogoutMiddleware.dispatch req, (error) ->\n          return reject error if error?\n\n          logout.call req\n\n          afterLogoutMiddleware.dispatch req, (error) ->\n            return reject error if error?\n\n            resolve()\n\n      promise.finally -> delete req.loggingOutUser\n\n    next()  Save the user at the end of the request.    (req, res, next) ->\n\n    end = res.end\n    res.end = (data, encoding) ->\n      res.end = end\n\n      return res.end data, encoding unless req.user?.id\n\n      req.user.save().finally -> res.end data, encoding\n\n    next()\n\n]",
            "title": "req.authorize"
        },
        {
            "location": "/source/packages/shrub-passport/logout/",
            "text": "User logout\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubRpcRoutes\n\n\n  registrar.registerHook 'shrubRpcRoutes', ->\n\n    routes = []\n\n\n\n\nLog out.\n\n\n    routes.push\n\n      path: 'shrub-user/logout'\n\n      middleware: [\n\n        'shrub-http-express/session'\n        'shrub-passport'\n\n        (req, res, next) -> req.logOut().then(-> res.end()).catch next\n\n      ]\n\n    return routes",
            "title": "logout.coffee"
        },
        {
            "location": "/source/packages/shrub-passport/logout/#user-logout",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubRpcRoutes    registrar.registerHook 'shrubRpcRoutes', ->\n\n    routes = []  Log out.      routes.push\n\n      path: 'shrub-user/logout'\n\n      middleware: [\n\n        'shrub-http-express/session'\n        'shrub-passport'\n\n        (req, res, next) -> req.logOut().then(-> res.end()).catch next\n\n      ]\n\n    return routes",
            "title": "User logout"
        },
        {
            "location": "/source/packages/shrub-repl/",
            "text": "REPL\n\n\nRuns a REPL and allows packages to add values to its context.\n\n\nCoffeeScript = require 'coffee-script'\nfs = require 'fs'\nnet = require 'net'\nreplServer = require 'repl'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'shrub:repl'\n\n\n\n\nThe socket server.\n\n\nserver = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n\n\n\nThe prompt display for REPL clients.\n\n\n    prompt: 'shrub> '\n\n\n\n\nThe location of the socket.\n\n\n    socket: \"#{__dirname}/socket\"\n\n\n\n\nUse a CoffeeScript REPL?\n\n\n    useCoffee: true\n\n\n\n\nImplements hook \nshrubCoreProcessExit\n\n\n  registrar.registerHook 'shrubCoreProcessExit', -> server?.close()\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    orm = require 'shrub-orm'\n\n    label: 'REPL'\n    middleware: [\n\n      (next) ->\n\n        settings = config.get 'packageConfig:shrub-repl'\n\n        server = net.createServer (socket) ->\n\n\n\n\nInvoke hook \nshrubReplContext\n\n\n          pkgman.invoke 'shrubReplContext', context = {}\n\n\n\n\nREPL server options.\n\n\n          opts =\n            prompt: settings.prompt\n            input: socket\n            output: socket\n            ignoreUndefined: true\n\n\n\n\nCoffeeScript?\n\n\n          if settings.useCoffee\n\n            opts.prompt = \"(coffee) #{settings.prompt}\"\n\n\n\n\nDefine our own eval function, using CoffeeScript.\n\n\n            opts.eval = (cmd, context, filename, callback) ->\n\n\n\n\nHandle blank lines correctly.\n\n\n              return callback null, undefined if cmd is '(\\n)'\n\n\n\n\nForward the input to CoffeeScript for evalulation.\n\n\n              try\n\n                callback null, CoffeeScript.eval(\n                  cmd\n                  sandbox: context\n                  filename: filename\n                )\n\n              catch error\n\n                callback error\n\n\n\n\nSpin up the server, inject the values from \nshrubReplContext\n, and\nprepare for later cleanup.\n\n\n          repl = replServer.start opts\n          repl.context[key] = value for key, value of context\n          repl.on 'exit', -> socket.end()\n\n\n\n\nTry to be tidy about things.\n\n\n        fs.unlink settings.socket, (error) ->\n\n\n\n\nIgnore the error if it's just saying the socket didn't exist.\n\n\n          return next error if error.code isnt 'ENOENT' if error?\n\n\n\n\nBind the REPL server socket.\n\n\n          server.listen settings.socket, (error) ->\n            return next error if error?\n            debug \"REPL server listening at #{settings.socket}\"\n            next()\n\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-repl/#repl",
            "text": "Runs a REPL and allows packages to add values to its context.  CoffeeScript = require 'coffee-script'\nfs = require 'fs'\nnet = require 'net'\nreplServer = require 'repl'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'shrub:repl'  The socket server.  server = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->  The prompt display for REPL clients.      prompt: 'shrub> '  The location of the socket.      socket: \"#{__dirname}/socket\"  Use a CoffeeScript REPL?      useCoffee: true  Implements hook  shrubCoreProcessExit    registrar.registerHook 'shrubCoreProcessExit', -> server?.close()  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    orm = require 'shrub-orm'\n\n    label: 'REPL'\n    middleware: [\n\n      (next) ->\n\n        settings = config.get 'packageConfig:shrub-repl'\n\n        server = net.createServer (socket) ->  Invoke hook  shrubReplContext            pkgman.invoke 'shrubReplContext', context = {}  REPL server options.            opts =\n            prompt: settings.prompt\n            input: socket\n            output: socket\n            ignoreUndefined: true  CoffeeScript?            if settings.useCoffee\n\n            opts.prompt = \"(coffee) #{settings.prompt}\"  Define our own eval function, using CoffeeScript.              opts.eval = (cmd, context, filename, callback) ->  Handle blank lines correctly.                return callback null, undefined if cmd is '(\\n)'  Forward the input to CoffeeScript for evalulation.                try\n\n                callback null, CoffeeScript.eval(\n                  cmd\n                  sandbox: context\n                  filename: filename\n                )\n\n              catch error\n\n                callback error  Spin up the server, inject the values from  shrubReplContext , and\nprepare for later cleanup.            repl = replServer.start opts\n          repl.context[key] = value for key, value of context\n          repl.on 'exit', -> socket.end()  Try to be tidy about things.          fs.unlink settings.socket, (error) ->  Ignore the error if it's just saying the socket didn't exist.            return next error if error.code isnt 'ENOENT' if error?  Bind the REPL server socket.            server.listen settings.socket, (error) ->\n            return next error if error?\n            debug \"REPL server listening at #{settings.socket}\"\n            next()\n\n    ]",
            "title": "REPL"
        },
        {
            "location": "/source/packages/shrub-rpc/client/",
            "text": "RPC\n\n\nDefine an Angular service to issue \nremote procedure\ncalls\n.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularService\n\n\n  registrar.registerHook 'shrubAngularService', -> [\n    '$injector', '$q', 'shrub-pkgman', 'shrub-socket'\n    ({invoke}, {defer}, pkgman, socket) ->\n\n      errors = require 'errors'\n\n      service = {}\n\n\n\n\nrpc.call\n\n\n\n\n\n\n(String) \npath\n - The RPC route path, e.g. \nshrub-user/login\n.\n\n\n\n\n\n\n(Object) \ndata\n - The data to send to the server.\n\n\n\n\n\n\nCall the server with some data.\n Returns a promise, either resolved\nwith the result of the response from the server, or rejected with the\nerror from the server.\n\n\n      service.call = (path, data) ->\n\n        deferred = defer()\n\n        socket.emit(\n          'shrub-rpc'\n          path: path, data: data\n          ({error, result}) ->\n            return deferred.reject errors.unserialize error if error?\n            deferred.resolve result\n        )\n\n\n\n\nInvoke hook \nshrubRpcCall\n\n\n        invoke(\n          injectable, null\n\n          route: path\n          data: data\n          result: deferred.promise\n\n        ) for injectable in pkgman.invokeFlat 'shrubRpcCall'\n\n        deferred.promise\n\n\n\n\nrpc.on\n\n\n\n\n\n\n(String) \neventName\n - The name of the event to listen for.\n\n\n\n\n\n\n(optional Function) \nfn\n - Callback called with the event data.\n\n\n\n\n\n\nListen for an event.\n Proxies directly to \nsocket.on\n.\n\n\n      service.on = (eventName, fn) -> socket.on eventName, fn\n\n\n\n\nrpc.formSubmitHandler\n\n\n\n\n\n\n(String) \npath\n - The RPC route path, e.g. \nshrub-user/login\n.\n\n\n\n\n\n\n(Function) \nfn\n - Nodeback called with the RPC response.\n\n\n\n\n\n\nHelper function to call an RPC route with the result of a form\nsubmission.\n\n\n      service.formSubmitHandler = (path, fn) ->\n\n        unless fn?\n          fn = path\n          path = null\n\n        (values, form) ->\n\n          service.call(path ? form.key, values).then(\n            (result) -> fn null, result\n          ).catch (error) -> fn error\n\n      service\n\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-rpc/client/#rpc",
            "text": "Define an Angular service to issue  remote procedure\ncalls .  exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularService    registrar.registerHook 'shrubAngularService', -> [\n    '$injector', '$q', 'shrub-pkgman', 'shrub-socket'\n    ({invoke}, {defer}, pkgman, socket) ->\n\n      errors = require 'errors'\n\n      service = {}",
            "title": "RPC"
        },
        {
            "location": "/source/packages/shrub-rpc/client/#rpccall",
            "text": "(String)  path  - The RPC route path, e.g.  shrub-user/login .    (Object)  data  - The data to send to the server.    Call the server with some data.  Returns a promise, either resolved\nwith the result of the response from the server, or rejected with the\nerror from the server.        service.call = (path, data) ->\n\n        deferred = defer()\n\n        socket.emit(\n          'shrub-rpc'\n          path: path, data: data\n          ({error, result}) ->\n            return deferred.reject errors.unserialize error if error?\n            deferred.resolve result\n        )  Invoke hook  shrubRpcCall          invoke(\n          injectable, null\n\n          route: path\n          data: data\n          result: deferred.promise\n\n        ) for injectable in pkgman.invokeFlat 'shrubRpcCall'\n\n        deferred.promise",
            "title": "rpc.call"
        },
        {
            "location": "/source/packages/shrub-rpc/client/#rpcon",
            "text": "(String)  eventName  - The name of the event to listen for.    (optional Function)  fn  - Callback called with the event data.    Listen for an event.  Proxies directly to  socket.on .        service.on = (eventName, fn) -> socket.on eventName, fn",
            "title": "rpc.on"
        },
        {
            "location": "/source/packages/shrub-rpc/client/#rpcformsubmithandler",
            "text": "(String)  path  - The RPC route path, e.g.  shrub-user/login .    (Function)  fn  - Nodeback called with the RPC response.    Helper function to call an RPC route with the result of a form\nsubmission.        service.formSubmitHandler = (path, fn) ->\n\n        unless fn?\n          fn = path\n          path = null\n\n        (values, form) ->\n\n          service.call(path ? form.key, values).then(\n            (result) -> fn null, result\n          ).catch (error) -> fn error\n\n      service\n\n  ]",
            "title": "rpc.formSubmitHandler"
        },
        {
            "location": "/source/packages/shrub-rpc/client/test-unit/",
            "text": "describe 'rpc', ->\n\n  rpc = null\n\n  beforeEach ->\n\n    inject [\n      'shrub-rpc'\n      (_rpc_) -> rpc = _rpc_\n    ]\n\n  it 'should send and receive data back from rpc calls', ->\n\n    inject [\n      '$rootScope', '$timeout', 'shrub-socket'\n      ($rootScope, $timeout, socket) ->\n\n        socket.catchEmit 'shrub-rpc', ({path, data}, fn) ->\n          expect(path).toBe 'test'\n\n          fn result: data.foo\n\n        result = null\n        error = 'invalid'\n\n        promise = rpc.call 'test', foo: 420\n        promise.then (_) -> result = _\n        promise.catch (_) -> error = _\n\n        $timeout.flush()\n        $rootScope.$apply()\n\n        expect(result).toBe 420\n        expect(error).toBe 'invalid'\n    ]\n\n  it 'should handle errors gracefully', ->\n\n    inject [\n      '$rootScope', 'shrub-socket'\n      ($rootScope, socket) ->\n\n        socket.catchEmit 'shrub-rpc', ({data}, fn) ->\n          fn error: new Error()\n\n        result = 'invalid'\n        error = null\n\n        promise = rpc.call 'test'\n        promise.then (_) -> result = _\n        promise.catch (_) -> error = _\n\n        $rootScope.$apply()\n\n        expect(result).toBe 'invalid'\n        expect(error).toBeDefined()\n\n    ]",
            "title": "test-unit.coffee"
        },
        {
            "location": "/source/packages/shrub-rpc/",
            "text": "RPC\n\n\nFramework for communication between client and server through\n\nRPC\n\n\n{EventEmitter} = require 'events'\n{IncomingMessage} = require 'http'\n\npkgman = null\n\n\n\n\nRPC route information.\n\n\nroutes = {}\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    pkgman = require 'pkgman'\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    _ = require 'lodash'\n    debug = require('debug') 'shrub-silly:rpc'\n\n    {Middleware} = require 'middleware'\n\n    clientModule = require './client'\n\n    label: 'Bootstrap RPC'\n    middleware: [\n\n      (next) ->\n\n\n\n\nInvoke hook \nshrubRpcRoutes\n\n\n        debug '- Registering RPC routess...'\n        for route in _.flatten pkgman.invokeFlat 'shrubRpcRoutes'\n\n          debug route.path\n\n\n\n\nNormalize middleware to array form.\n\n\n          route.middleware ?= []\n          if 'function' is typeof route.middleware\n            route.middleware = [route.middleware]\n\n          routes[route.path] = route\n        debug '- RPC routes registered.'\n\n\n\n\nInvoke hook \nshrubRpcRoutesAlter\n\n\n        pkgman.invoke 'shrubRpcRoutesAlter', routes\n\n\n\n\nSet up the middleware dispatcher.\n\n\n        for path, route of routes\n          route.dispatcher = new Middleware()\n\n          fn.weight ?= index for fn, index in route.middleware\n\n          sortedMiddleware = route.middleware.sort (l, r) ->\n            (l.weight ? 0) - (r.weight ? 0)\n\n          route.dispatcher.use fn for fn in sortedMiddleware\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubSocketConnectionMiddleware\n\n\n  registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    Promise = require 'bluebird'\n\n    config = require 'config'\n    errors = require 'errors'\n    logging = require 'logging'\n\n    logger = logging.create file: filename: 'logs/rpc.log'\n    {TransmittableError} = errors\n\n    label: 'Receive and dispatch RPC calls'\n    middleware: [\n\n      (req, res, next) ->\n\n\n\n\nLog an error without transmitting it.\n\n\n        logError = (error) -> logger.error errors.stack error\n\n\n\n\nHub for RPC calls. Dispatch routes.\n\n\n        req.socket.on 'shrub-rpc', ({path, data}, fn) ->\n          unless (route = routes[path])?\n            return logError new Error \"Unknown route called: #{path}\"\n\n\n\n\nDon't pass req directly, since it can be mutated by routes, and\nviolate other routes' expectations.\n\n\n          routeReq = new IncomingMessage req.socket.conn\n          routeReq.body = data\n          routeReq.route = route\n          routeReq.socket = req.socket\n\n\n\n\nTODO: Doc\n\n\n          routeRes = new class RpcRouteResponse extends EventEmitter\n\n            constructor: ->\n              super\n\n              @data = {}\n              @error = null\n              @headers = {}\n\n            getHeader: (key) -> @headers[key]\n\n            setHeader: (key, value) -> @headers[key] = value\n\n            setError: (@error) -> return this\n\n            end: (data) ->\n\n              @write data\n\n              return fn error: errors.serialize @error if @error?\n              fn result: @data\n\n            write: (data) -> @data[k] = v for own k, v of data\n\n            writeHead: (code, headers) ->\n              @headers[k] = v for k, v of headers\n\n\n\n\nSend an error to the client.\n\n\n          emitError = (error) -> routeRes.setError(error).end()\n\n\n\n\nError transmission and logging.\n\n\n          handleError = (error) ->\n\n\n\n\nTransmit transmittable errors to the client, otherwise conceal\nit.\n\n\n            if error instanceof TransmittableError\n              emitError error\n            else\n              emitError new Error 'Please try again later.'\n\n\n\n\nLog the full error stack, because it might help track down any\nproblem.\n\n\n            logError error if do ->\n\n\n\n\nUnknown errors.\n\n\n              unless error instanceof TransmittableError\n                return true\n\n\n\n\nIf we're not running in production.\n\n\n              if 'production' isnt config.get 'NODE_ENV'\n                return true\n\n\n\n\nDispatch the route.\n\n\n          route.dispatcher.dispatch routeReq, routeRes, (error) ->\n            handleError error if error?\n\n        next()\n\n    ]\n\n\n\n\nspliceRouteMiddleware\n\n\n\n\n\n\n(Object) \nroute\n - The RPC route definition object.\n\n\n\n\n\n\n(String) \nkey\n - The key used by RPC routes to be replaced with\nmiddleware.\n\n\n\n\n\n\n(Function Array) \nmiddleware\n - The middleware to be spliced in.\n\n\n\n\n\n\nSplice middleware functions in place of a key.\n\n\nSome packages define RPC route middleware that can be included as a string\n(e.g. \n'shrub-user'\n). This function will splice in an array of middleware\nwhere a placeholder key specifies.\n\n\nexports.spliceRouteMiddleware = (route, key, middleware) ->\n  return unless ~(index = route.middleware.indexOf key)\n\n  l = route.middleware.slice 0, index\n  r = route.middleware.slice index + 1\n\n  route.middleware = l.concat middleware, r\n\n  return",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-rpc/#rpc",
            "text": "Framework for communication between client and server through RPC  {EventEmitter} = require 'events'\n{IncomingMessage} = require 'http'\n\npkgman = null  RPC route information.  routes = {}\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    pkgman = require 'pkgman'  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    _ = require 'lodash'\n    debug = require('debug') 'shrub-silly:rpc'\n\n    {Middleware} = require 'middleware'\n\n    clientModule = require './client'\n\n    label: 'Bootstrap RPC'\n    middleware: [\n\n      (next) ->  Invoke hook  shrubRpcRoutes          debug '- Registering RPC routess...'\n        for route in _.flatten pkgman.invokeFlat 'shrubRpcRoutes'\n\n          debug route.path  Normalize middleware to array form.            route.middleware ?= []\n          if 'function' is typeof route.middleware\n            route.middleware = [route.middleware]\n\n          routes[route.path] = route\n        debug '- RPC routes registered.'  Invoke hook  shrubRpcRoutesAlter          pkgman.invoke 'shrubRpcRoutesAlter', routes  Set up the middleware dispatcher.          for path, route of routes\n          route.dispatcher = new Middleware()\n\n          fn.weight ?= index for fn, index in route.middleware\n\n          sortedMiddleware = route.middleware.sort (l, r) ->\n            (l.weight ? 0) - (r.weight ? 0)\n\n          route.dispatcher.use fn for fn in sortedMiddleware\n\n        next()\n\n    ]  Implements hook  shrubSocketConnectionMiddleware    registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    Promise = require 'bluebird'\n\n    config = require 'config'\n    errors = require 'errors'\n    logging = require 'logging'\n\n    logger = logging.create file: filename: 'logs/rpc.log'\n    {TransmittableError} = errors\n\n    label: 'Receive and dispatch RPC calls'\n    middleware: [\n\n      (req, res, next) ->  Log an error without transmitting it.          logError = (error) -> logger.error errors.stack error  Hub for RPC calls. Dispatch routes.          req.socket.on 'shrub-rpc', ({path, data}, fn) ->\n          unless (route = routes[path])?\n            return logError new Error \"Unknown route called: #{path}\"  Don't pass req directly, since it can be mutated by routes, and\nviolate other routes' expectations.            routeReq = new IncomingMessage req.socket.conn\n          routeReq.body = data\n          routeReq.route = route\n          routeReq.socket = req.socket  TODO: Doc            routeRes = new class RpcRouteResponse extends EventEmitter\n\n            constructor: ->\n              super\n\n              @data = {}\n              @error = null\n              @headers = {}\n\n            getHeader: (key) -> @headers[key]\n\n            setHeader: (key, value) -> @headers[key] = value\n\n            setError: (@error) -> return this\n\n            end: (data) ->\n\n              @write data\n\n              return fn error: errors.serialize @error if @error?\n              fn result: @data\n\n            write: (data) -> @data[k] = v for own k, v of data\n\n            writeHead: (code, headers) ->\n              @headers[k] = v for k, v of headers  Send an error to the client.            emitError = (error) -> routeRes.setError(error).end()  Error transmission and logging.            handleError = (error) ->  Transmit transmittable errors to the client, otherwise conceal\nit.              if error instanceof TransmittableError\n              emitError error\n            else\n              emitError new Error 'Please try again later.'  Log the full error stack, because it might help track down any\nproblem.              logError error if do ->  Unknown errors.                unless error instanceof TransmittableError\n                return true  If we're not running in production.                if 'production' isnt config.get 'NODE_ENV'\n                return true  Dispatch the route.            route.dispatcher.dispatch routeReq, routeRes, (error) ->\n            handleError error if error?\n\n        next()\n\n    ]  spliceRouteMiddleware    (Object)  route  - The RPC route definition object.    (String)  key  - The key used by RPC routes to be replaced with\nmiddleware.    (Function Array)  middleware  - The middleware to be spliced in.    Splice middleware functions in place of a key.  Some packages define RPC route middleware that can be included as a string\n(e.g.  'shrub-user' ). This function will splice in an array of middleware\nwhere a placeholder key specifies.  exports.spliceRouteMiddleware = (route, key, middleware) ->\n  return unless ~(index = route.middleware.indexOf key)\n\n  l = route.middleware.slice 0, index\n  r = route.middleware.slice index + 1\n\n  route.middleware = l.concat middleware, r\n\n  return",
            "title": "RPC"
        },
        {
            "location": "/source/packages/shrub-schema-rest/",
            "text": "REST API for database schema\n\n\nServe the database schema over a REST API.\n\n\ni8n = require 'inflection'\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubConfigClient\n\n\n  registrar.registerHook 'shrubConfigClient', ->\n\n    apiRoot: config.get 'packageConfig:shrub-schema:apiRoot'\n\n\n\n\nImplements hook \nshrubHttpRoutes\n\n\nServe the database schema as an authenticated REST API.\n\n\n  registrar.registerHook 'shrubHttpRoutes', (http) ->\n    routes = []\n\n\n\n\n} DRY.\n\n\n    interceptError = (res) ->\n      (error) -> serveJson res, error.code ? 500, message: error.message\n\n\n\n\n} DRY.\n\n\n    serveJson = (res, code, data) ->\n\n\n\n\nCORS policy enforcement.\n\n\n      corsHeaders = config.get 'packageConfig:shrub-schema:corsHeaders'\n      res.set corsHeaders if corsHeaders?\n\n\n\n\nServe JSON manually, breaking it to protect against XSRF.\nSee: \nhttp://docs.angularjs.org/api/ng/service/$http#json-vulnerability-protection\n\n\n      res.set 'Content-Type', 'application/json'\n      res.statusCode = code\n      res.send \")]}',\\n#{JSON.stringify data}\"\n\n\n\n\nServe the models. For each model, we'll define REST paths to allow\ninteraction with a model, or set of models.\n\n\n    for name, Model of schema.models\n\n      do (Model) ->\n\n        keyify = (key, value) ->\n          O = {}\n          O[key] = value\n          O\n\n        {resource, collection} = schema.resourcePaths name\n\n\n\n\nSupposing we're handling the \nUser\n model, and apiRoot is its\ndefault (\n/api\n), the values will be:\n\n\ncollectionPath = \"/api/users\"\nresourcePath = \"/api/user/:id\"\n\n\n\nWe'll assume these defaults for each path's explanation.\n\n\n        apiRoot = config.get 'packageConfig:shrub-schema:apiRoot'\n        collectionPath = \"#{apiRoot}/#{collection}\"\n        resourcePath = \"#{apiRoot}/#{resource}/:id\"\n\n\n\n\nGet the entire collection.\nGET \n/api/users\n\n\n        routes.push\n          path: collectionPath\n          receiver: (req, res) ->\n\n            query = if Object.keys(req.query).length then req.query\n\n            Model.authenticatedAll(\n              req.user, query\n            ).then((models) ->\n              serveJson res, 200, keyify collection, models\n            ).catch interceptError res\n\n\n\n\nGet how many resources are in the collection.\nGET \n/api/users/count\n\n\n        routes.push\n          path: \"#{collectionPath}/count\"\n          receiver: (req, res) ->\n\n            Model.authenticatedCount(\n              req.user\n            ).then((count) ->\n              serveJson res, 200, keyify 'count', count\n            ).catch interceptError res\n\n\n\n\nCreate a new resource in the collection.\nPOST \n/api/users\n\n\n        routes.push\n          verb: 'post'\n          path: collectionPath\n          receiver: (req, res) ->\n\n            Model.authenticatedCreate(\n              req.user, req.body\n            ).then((model) ->\n              serveJson res, 201, keyify resource, model\n            ).catch interceptError res\n\n\n\n\nDelete all resources in a collection.\nDELETE \n/api/users\n\n\n        routes.push\n          verb: 'delete'\n          path: collectionPath\n          receiver: (req, res) ->\n\n            Model.authenticatedDestroyAll(\n              req.user\n            ).then(->\n              serveJson res, 200, message: 'Collection deleted.'\n            ).catch interceptError res\n\n\n\n\nGet a resource.\nGET \n/api/user/1\n\n\n        routes.push\n          path: resourcePath\n          receiver: (req, res) ->\n\n            Model.authenticatedFind(\n              req.user\n              req.params.id\n            ).then((model) ->\n              serveJson res, 200, keyify resource, model\n            ).catch interceptError res\n\n\n\n\nUpdate a resource.\nPUT \n/api/user/1\n\n\n        routes.push\n          verb: 'put'\n          path: resourcePath\n          receiver: (req, res) ->\n\n            Model.authenticatedUpdate(\n              req.user\n              req.params.id\n              req.body\n            ).then(->\n              serveJson res, 200, message: 'Resource updated.'\n            ).catch interceptError res\n\n\n\n\nDelete a resource.\nDELETE \n/api/user/1\n\n\n        routes.push\n          verb: 'delete'\n          path: resourcePath\n          receiver: (req, res) ->\n\n            Model.authenticatedDestroy(\n              req.user\n              req.params.id\n            ).then(->\n              serveJson res, 200, message: 'Resource deleted.'\n            ).catch interceptError res\n\n    routes\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n\n\n\n} The URL root where the schema REST API is served.\n\n\n    apiRoot: '/api'\n\n\n\n\nCORS\n\nheaders.\n\n\n    corsHeaders: null\n\n\nexports.resourcePaths = (name) ->\n\n  resource = i8n.dasherize(i8n.underscore name).toLowerCase()\n\n  resource: resource\n  collection: i8n.pluralize resource",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-schema-rest/#rest-api-for-database-schema",
            "text": "Serve the database schema over a REST API.  i8n = require 'inflection'\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->",
            "title": "REST API for database schema"
        },
        {
            "location": "/source/packages/shrub-schema-rest/#implements-hook-shrubconfigclient",
            "text": "registrar.registerHook 'shrubConfigClient', ->\n\n    apiRoot: config.get 'packageConfig:shrub-schema:apiRoot'",
            "title": "Implements hook shrubConfigClient"
        },
        {
            "location": "/source/packages/shrub-schema-rest/#implements-hook-shrubhttproutes",
            "text": "Serve the database schema as an authenticated REST API.    registrar.registerHook 'shrubHttpRoutes', (http) ->\n    routes = []  } DRY.      interceptError = (res) ->\n      (error) -> serveJson res, error.code ? 500, message: error.message  } DRY.      serveJson = (res, code, data) ->  CORS policy enforcement.        corsHeaders = config.get 'packageConfig:shrub-schema:corsHeaders'\n      res.set corsHeaders if corsHeaders?  Serve JSON manually, breaking it to protect against XSRF.\nSee:  http://docs.angularjs.org/api/ng/service/$http#json-vulnerability-protection        res.set 'Content-Type', 'application/json'\n      res.statusCode = code\n      res.send \")]}',\\n#{JSON.stringify data}\"  Serve the models. For each model, we'll define REST paths to allow\ninteraction with a model, or set of models.      for name, Model of schema.models\n\n      do (Model) ->\n\n        keyify = (key, value) ->\n          O = {}\n          O[key] = value\n          O\n\n        {resource, collection} = schema.resourcePaths name  Supposing we're handling the  User  model, and apiRoot is its\ndefault ( /api ), the values will be:  collectionPath = \"/api/users\"\nresourcePath = \"/api/user/:id\"  We'll assume these defaults for each path's explanation.          apiRoot = config.get 'packageConfig:shrub-schema:apiRoot'\n        collectionPath = \"#{apiRoot}/#{collection}\"\n        resourcePath = \"#{apiRoot}/#{resource}/:id\"  Get the entire collection.\nGET  /api/users          routes.push\n          path: collectionPath\n          receiver: (req, res) ->\n\n            query = if Object.keys(req.query).length then req.query\n\n            Model.authenticatedAll(\n              req.user, query\n            ).then((models) ->\n              serveJson res, 200, keyify collection, models\n            ).catch interceptError res  Get how many resources are in the collection.\nGET  /api/users/count          routes.push\n          path: \"#{collectionPath}/count\"\n          receiver: (req, res) ->\n\n            Model.authenticatedCount(\n              req.user\n            ).then((count) ->\n              serveJson res, 200, keyify 'count', count\n            ).catch interceptError res  Create a new resource in the collection.\nPOST  /api/users          routes.push\n          verb: 'post'\n          path: collectionPath\n          receiver: (req, res) ->\n\n            Model.authenticatedCreate(\n              req.user, req.body\n            ).then((model) ->\n              serveJson res, 201, keyify resource, model\n            ).catch interceptError res  Delete all resources in a collection.\nDELETE  /api/users          routes.push\n          verb: 'delete'\n          path: collectionPath\n          receiver: (req, res) ->\n\n            Model.authenticatedDestroyAll(\n              req.user\n            ).then(->\n              serveJson res, 200, message: 'Collection deleted.'\n            ).catch interceptError res  Get a resource.\nGET  /api/user/1          routes.push\n          path: resourcePath\n          receiver: (req, res) ->\n\n            Model.authenticatedFind(\n              req.user\n              req.params.id\n            ).then((model) ->\n              serveJson res, 200, keyify resource, model\n            ).catch interceptError res  Update a resource.\nPUT  /api/user/1          routes.push\n          verb: 'put'\n          path: resourcePath\n          receiver: (req, res) ->\n\n            Model.authenticatedUpdate(\n              req.user\n              req.params.id\n              req.body\n            ).then(->\n              serveJson res, 200, message: 'Resource updated.'\n            ).catch interceptError res  Delete a resource.\nDELETE  /api/user/1          routes.push\n          verb: 'delete'\n          path: resourcePath\n          receiver: (req, res) ->\n\n            Model.authenticatedDestroy(\n              req.user\n              req.params.id\n            ).then(->\n              serveJson res, 200, message: 'Resource deleted.'\n            ).catch interceptError res\n\n    routes",
            "title": "Implements hook shrubHttpRoutes"
        },
        {
            "location": "/source/packages/shrub-schema-rest/#implements-hook-shrubconfigserver",
            "text": "registrar.registerHook 'shrubConfigServer', ->  } The URL root where the schema REST API is served.      apiRoot: '/api'  CORS \nheaders.      corsHeaders: null\n\n\nexports.resourcePaths = (name) ->\n\n  resource = i8n.dasherize(i8n.underscore name).toLowerCase()\n\n  resource: resource\n  collection: i8n.pluralize resource",
            "title": "Implements hook shrubConfigServer"
        },
        {
            "location": "/source/packages/shrub-session/",
            "text": "Session\n\n\nManage sessions across HTTP and socket connections.\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubOrmCollections\n\n\n  registrar.registerHook 'shrubOrmCollections', ->\n\n    Session =\n\n\n\n\nSkip the numeric primary key, we'll use the session ID.\n\n\n      autoPK: false\n\n      attributes:\n\n\n\n\nStore the session data as a blob of data.\n\n\n        blob: 'string'\n\n\n\n\nWhen this session expires.\n\n\n        expires: 'datetime'\n\n\n\n\nThe session ID, used as the primary key.\n\n\n        sid:\n          type: 'string'\n          primaryKey: true\n\n    'shrub-session': Session\n\n\n\n\nImplements hook \nshrubAuditFingerprint\n\n\n  registrar.registerHook 'shrubAuditFingerprint', (req) ->\n\n\n\n\nSession ID.\n\n\n    session: if req?.session? then req.session.id\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n\n\n\nKey within the cookie where the session is stored.\n\n\n    key: 'connect.sid'\n\n\n\n\nCookie information.\n\n\n    cookie:\n\n\n\n\nThe crypto key we encrypt the cookie with.\n\n\n      cryptoKey: '***CHANGE THIS***'\n\n\n\n\nThe max age of this session. Defaults to two weeks.\n\n\n      maxAge: 1000 * 60 * 60 * 24 * 14\n\n\n\n\nImplements hook \nshrubSocketConnectionMiddleware\n\n\n  registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Join channel for session'\n    middleware: [\n\n      (req, res, next) ->\n\n        return req.socket.join \"session/#{req.session.id}\", next if req.session?\n\n        next()\n\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-session/#session",
            "text": "Manage sessions across HTTP and socket connections.  config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubOrmCollections    registrar.registerHook 'shrubOrmCollections', ->\n\n    Session =  Skip the numeric primary key, we'll use the session ID.        autoPK: false\n\n      attributes:  Store the session data as a blob of data.          blob: 'string'  When this session expires.          expires: 'datetime'  The session ID, used as the primary key.          sid:\n          type: 'string'\n          primaryKey: true\n\n    'shrub-session': Session  Implements hook  shrubAuditFingerprint    registrar.registerHook 'shrubAuditFingerprint', (req) ->  Session ID.      session: if req?.session? then req.session.id  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->  Key within the cookie where the session is stored.      key: 'connect.sid'  Cookie information.      cookie:  The crypto key we encrypt the cookie with.        cryptoKey: '***CHANGE THIS***'  The max age of this session. Defaults to two weeks.        maxAge: 1000 * 60 * 60 * 24 * 14  Implements hook  shrubSocketConnectionMiddleware    registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Join channel for session'\n    middleware: [\n\n      (req, res, next) ->\n\n        return req.socket.join \"session/#{req.session.id}\", next if req.session?\n\n        next()\n\n    ]",
            "title": "Session"
        },
        {
            "location": "/source/packages/shrub-session/store/",
            "text": "Session store\n\n\n*An implementation of express's \nSession\nStore\n\nAPI.\n\n\nExpressSession = require 'express-session'\n\norm = null\n\nmodule.exports = (connect) ->\n\n  Store = ExpressSession.Store\n\n  class OrmStore extends Store\n\n\n\n\nconstructor\n\n\n*Lazy-load ORM so as not to bog down the build process (and we have no\nway to implement hook \nshrubCorePreBootstrap\n at this point).\n\n\n    constructor: ->\n\n      orm = require 'shrub-orm'\n\n\n\n\nOrmStore#get\n\n\n\n\n\n\n(String) \nsid\n - Session ID.\n\n\n\n\n\n\n(Function) \nfn\n - Nodeback called with the retrieved session (if any).\n\n\n\n\n\n\nGet a session by ID.\n\n\n    get: (sid, fn) ->\n      self = this\n\n      Session = orm.collection 'shrub-session'\n\n      Session.findOne(sid: sid).then((session) ->\n        return fn() unless session?\n\n\n\n\nExpired?\n\n\n        if Date.now >= session.expires.getTime()\n          return self.destroy sid, (error) ->\n            return fn error if error?\n            fn()\n\n        fn null, JSON.parse session.blob\n\n      ).catch fn\n\n\n\n\nOrmStore#set\n\n\n\n\n\n\n(String) \nsid\n - Session ID.\n\n\n\n\n\n\n(Object) \nsess\n - Session data.\n\n\n\n\n\n\n(Function) \nfn\n - Nodeback called with the created/updated session.\n\n\n\n\n\n\nGet a session by ID.\n\n\n    set: (sid, sess, fn) ->\n\n      Session = orm.collection 'shrub-session'\n\n\n\n\nUse the cookie expiration if it exists, otherwise default to one day.\n\n\n      ttl = @ttl ? if 'number' is typeof maxAge = sess.cookie.maxAge\n        maxAge / 1000 or 0\n      else\n        86400\n\n      Session.findOrCreate(\n        sid: sid\n      ,\n        sid: sid\n        expires: new Date Date.now() + ttl * 1000\n      ).then((session) ->\n        session.blob = JSON.stringify sess\n        session.save()\n      ).then((session) -> fn null, session).catch fn\n\n    touch: @::['set']\n\n\n\n\nOrmStore#destroy\n\n\n\n\n\n\n(String) \nsid\n - Session ID.\n\n\n\n\n\n\n(Function) \nfn\n - Nodeback called after the session is destroyed.\n\n\n\n\n\n\nDestroy a session by ID.\n\n\n    destroy: (sid, fn) ->\n\n      Session = orm.collection 'shrub-session'\n\n      Session.destroy(sid: sid).exec fn",
            "title": "store.coffee"
        },
        {
            "location": "/source/packages/shrub-session/store/#session-store",
            "text": "*An implementation of express's  Session\nStore \nAPI.  ExpressSession = require 'express-session'\n\norm = null\n\nmodule.exports = (connect) ->\n\n  Store = ExpressSession.Store\n\n  class OrmStore extends Store",
            "title": "Session store"
        },
        {
            "location": "/source/packages/shrub-session/store/#constructor",
            "text": "*Lazy-load ORM so as not to bog down the build process (and we have no\nway to implement hook  shrubCorePreBootstrap  at this point).      constructor: ->\n\n      orm = require 'shrub-orm'",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-session/store/#ormstoreget",
            "text": "(String)  sid  - Session ID.    (Function)  fn  - Nodeback called with the retrieved session (if any).    Get a session by ID.      get: (sid, fn) ->\n      self = this\n\n      Session = orm.collection 'shrub-session'\n\n      Session.findOne(sid: sid).then((session) ->\n        return fn() unless session?  Expired?          if Date.now >= session.expires.getTime()\n          return self.destroy sid, (error) ->\n            return fn error if error?\n            fn()\n\n        fn null, JSON.parse session.blob\n\n      ).catch fn",
            "title": "OrmStore#get"
        },
        {
            "location": "/source/packages/shrub-session/store/#ormstoreset",
            "text": "(String)  sid  - Session ID.    (Object)  sess  - Session data.    (Function)  fn  - Nodeback called with the created/updated session.    Get a session by ID.      set: (sid, sess, fn) ->\n\n      Session = orm.collection 'shrub-session'  Use the cookie expiration if it exists, otherwise default to one day.        ttl = @ttl ? if 'number' is typeof maxAge = sess.cookie.maxAge\n        maxAge / 1000 or 0\n      else\n        86400\n\n      Session.findOrCreate(\n        sid: sid\n      ,\n        sid: sid\n        expires: new Date Date.now() + ttl * 1000\n      ).then((session) ->\n        session.blob = JSON.stringify sess\n        session.save()\n      ).then((session) -> fn null, session).catch fn\n\n    touch: @::['set']",
            "title": "OrmStore#set"
        },
        {
            "location": "/source/packages/shrub-session/store/#ormstoredestroy",
            "text": "(String)  sid  - Session ID.    (Function)  fn  - Nodeback called after the session is destroyed.    Destroy a session by ID.      destroy: (sid, fn) ->\n\n      Session = orm.collection 'shrub-session'\n\n      Session.destroy(sid: sid).exec fn",
            "title": "OrmStore#destroy"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/client/form/",
            "text": "Strapped - Notifications\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubSkinLink\n\n\n  registrar.registerHook 'shrubSkinLink', -> [\n    '$directive', '$element'\n    (directive, element) ->\n\n      return unless ~[\n        'shrubFormWidgetSubmit'\n        'shrubFormWidgetText'\n        'shrubFormWidgetCheckbox'\n        'shrubFormWidgetRadio'\n      ].indexOf directive.name\n\n      element.addClass 'form-group'\n  ]\n\n\n\n\nImplements hook \nshrubSkinLink--DIRECTIVE\n\n\n  registrar.registerHook 'shrubSkinLink--shrubFormWidgetGroup', -> [\n    '$element'\n    (element) -> element.addClass 'form-inline'\n  ]",
            "title": "form.coffee"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/client/form/#strapped-notifications",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubSkinLink    registrar.registerHook 'shrubSkinLink', -> [\n    '$directive', '$element'\n    (directive, element) ->\n\n      return unless ~[\n        'shrubFormWidgetSubmit'\n        'shrubFormWidgetText'\n        'shrubFormWidgetCheckbox'\n        'shrubFormWidgetRadio'\n      ].indexOf directive.name\n\n      element.addClass 'form-group'\n  ]  Implements hook  shrubSkinLink--DIRECTIVE    registrar.registerHook 'shrubSkinLink--shrubFormWidgetGroup', -> [\n    '$element'\n    (element) -> element.addClass 'form-inline'\n  ]",
            "title": "Strapped - Notifications"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/client/",
            "text": "Strapped - client\n\n\nexports.pkgmanRegister = (registrar) ->\n\n  registrar.recur [\n    'form', 'main-nav', 'notifications'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/client/#strapped-client",
            "text": "exports.pkgmanRegister = (registrar) ->\n\n  registrar.recur [\n    'form', 'main-nav', 'notifications'\n  ]",
            "title": "Strapped - client"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/client/main-nav/",
            "text": "Strapped - Main navigation\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/window-title'\n    (windowTitle) ->\n\n      link: (scope, elm, attr) ->\n\n\n\n\nAdd some useful links to the nav.\n\n\n        scope.menu =\n\n          name: 'main-nav'\n          attributes:\n            class: ['nav', 'navbar-nav', 'navbar-left']\n            id: 'main-nav'\n          items: []\n\n        scope.$watch(\n          -> windowTitle.page()\n          -> scope.pageTitle = windowTitle.page()\n        )\n\n      template: '''\n\n<nav class=\"navbar navbar-default\" role=\"navigation\">\n  <div class=\"container-fluid\">\n\n    <div class=\"navbar-header\">\n      <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".shrub-skin-strapped-ui-nav\">\n        <span class=\"sr-only\">Toggle navigation</span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n      </button>\n\n      <a class=\"navbar-brand\" href=\"#\"><span data-ng-bind=\"pageTitle\"></span></a>\n\n      <div\n        class=\"mobile navbar-notification\"\n        data-shrub-ui-notifications\n        data-queue-name=\"shrubExampleGeneral\"\n      >\n      </div>\n\n    </div>\n\n    <div class=\"navbar-collapse collapse shrub-skin-strapped-ui-nav\">\n\n      <div\n        class=\"desktop navbar-notification navbar-right\"\n        data-shrub-ui-notifications\n        data-queue-name=\"shrubExampleGeneral\"\n      >\n      </div>\n\n      <div\n        class=\"navbar-text navbar-right navbar-user\"\n      >\n        Hi,\n        <span\n          data-shrub-user-actions\n        >\n        </span>\n      </div>\n\n      <div\n        data-shrub-ui-menu\n        data-menu=\"menu\"\n      ></div>\n    </div>\n  </div>\n</nav>\n\n'''\n\n  ]",
            "title": "main-nav.coffee"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/client/main-nav/#strapped-main-navigation",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/window-title'\n    (windowTitle) ->\n\n      link: (scope, elm, attr) ->  Add some useful links to the nav.          scope.menu =\n\n          name: 'main-nav'\n          attributes:\n            class: ['nav', 'navbar-nav', 'navbar-left']\n            id: 'main-nav'\n          items: []\n\n        scope.$watch(\n          -> windowTitle.page()\n          -> scope.pageTitle = windowTitle.page()\n        )\n\n      template: '''\n\n<nav class=\"navbar navbar-default\" role=\"navigation\">\n  <div class=\"container-fluid\">\n\n    <div class=\"navbar-header\">\n      <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".shrub-skin-strapped-ui-nav\">\n        <span class=\"sr-only\">Toggle navigation</span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n        <span class=\"icon-bar\"></span>\n      </button>\n\n      <a class=\"navbar-brand\" href=\"#\"><span data-ng-bind=\"pageTitle\"></span></a>\n\n      <div\n        class=\"mobile navbar-notification\"\n        data-shrub-ui-notifications\n        data-queue-name=\"shrubExampleGeneral\"\n      >\n      </div>\n\n    </div>\n\n    <div class=\"navbar-collapse collapse shrub-skin-strapped-ui-nav\">\n\n      <div\n        class=\"desktop navbar-notification navbar-right\"\n        data-shrub-ui-notifications\n        data-queue-name=\"shrubExampleGeneral\"\n      >\n      </div>\n\n      <div\n        class=\"navbar-text navbar-right navbar-user\"\n      >\n        Hi,\n        <span\n          data-shrub-user-actions\n        >\n        </span>\n      </div>\n\n      <div\n        data-shrub-ui-menu\n        data-menu=\"menu\"\n      ></div>\n    </div>\n  </div>\n</nav>\n\n'''\n\n  ]",
            "title": "Strapped - Main navigation"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/client/notifications/",
            "text": "Strapped - Notifications\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubSkinLink--DIRECTIVE\n\n\n  registrar.registerHook 'shrubSkinLink--shrubUiNotifications', -> [\n    '$compile', '$scope', '$element', '$attr'\n    ($compile, scope, element, attr) ->\n\n\n\n\nInitialize the popover.\n\n\n      ($button = element.find 'button').popover\n\n        container: 'body'\n        content: -> element.find '.notifications'\n        html: true\n        placement: 'bottom'\n        template: \"\"\"\n\n<div class=\"popover popover-notifications popover-#{attr.queueName}\" role=\"tooltip\">\n  <div class=\"arrow\"></div>\n  <div class=\"popover-title\"></div>\n  <div class=\"popover-content\"></div>\n</div>\n\n\"\"\"\n        title: ->\n\n          tpl = '''\n\n<div\n  class=\"title\"\n  data-shrub-ui-notifications-title\n></div>\n\n'''\n\n          $compile(tpl)(scope)\n\n\n\n\nWhen the notifications are opened, acknowledge them.\n\n\n      $button.on 'show.bs.popover', -> scope.$emit 'shrub.ui.notifications.acknowledged'\n\n\n\n\nWait for the new queue to be compiled into the DOM, and then\nreposition the popover, since the new content may shift it.\n\n\n      scope.$watch(\n        'queue.notifications()', -> scope.$$postDigest ->\n          return unless (pop = $button.data 'bs.popover').$tip?\n          return unless pop.$tip.hasClass 'in'\n          pop.applyPlacement(\n            pop.getCalculatedOffset(\n              'bottom', pop.getPosition()\n              pop.$tip[0].offsetWidth\n              pop.$tip[0].offsetHeight\n            )\n            'bottom'\n          )\n        true\n      )\n\n\n\n\nHide the popover if any notification is clicked.\n\n\n      scope.$on 'shrub.ui.notification.clicked', -> $button.popover 'hide'\n\n  ]",
            "title": "notifications.coffee"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/client/notifications/#strapped-notifications",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubSkinLink--DIRECTIVE    registrar.registerHook 'shrubSkinLink--shrubUiNotifications', -> [\n    '$compile', '$scope', '$element', '$attr'\n    ($compile, scope, element, attr) ->  Initialize the popover.        ($button = element.find 'button').popover\n\n        container: 'body'\n        content: -> element.find '.notifications'\n        html: true\n        placement: 'bottom'\n        template: \"\"\"\n\n<div class=\"popover popover-notifications popover-#{attr.queueName}\" role=\"tooltip\">\n  <div class=\"arrow\"></div>\n  <div class=\"popover-title\"></div>\n  <div class=\"popover-content\"></div>\n</div>\n\n\"\"\"\n        title: ->\n\n          tpl = '''\n\n<div\n  class=\"title\"\n  data-shrub-ui-notifications-title\n></div>\n\n'''\n\n          $compile(tpl)(scope)  When the notifications are opened, acknowledge them.        $button.on 'show.bs.popover', -> scope.$emit 'shrub.ui.notifications.acknowledged'  Wait for the new queue to be compiled into the DOM, and then\nreposition the popover, since the new content may shift it.        scope.$watch(\n        'queue.notifications()', -> scope.$$postDigest ->\n          return unless (pop = $button.data 'bs.popover').$tip?\n          return unless pop.$tip.hasClass 'in'\n          pop.applyPlacement(\n            pop.getCalculatedOffset(\n              'bottom', pop.getPosition()\n              pop.$tip[0].offsetWidth\n              pop.$tip[0].offsetHeight\n            )\n            'bottom'\n          )\n        true\n      )  Hide the popover if any notification is clicked.        scope.$on 'shrub.ui.notification.clicked', -> $button.popover 'hide'\n\n  ]",
            "title": "Strapped - Notifications"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/",
            "text": "Strapped\n\n\nShrub's default skin.\n\n\npath = require 'path'\n\nshrubSkin = require 'shrub-skin'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubNodemailerHtml\n\n\n  registrar.registerHook 'shrubNodemailerHtml', ($body, html, $) ->\n\n    $('.container > .main', $body).html html\n\n    $body.find('.navbar-toggle, .navbar-collapse').remove()\n    $body.find('[data-shrub-ui-messages]').remove()\n\n    $body.find('script').remove()\n\n    $('noscript', $body).remove()\n\n\n\n\nImplements hook \nshrubSkinAssets\n\n\n  registrar.registerHook 'shrubSkinAssets', (assets) ->\n\n\n\n\nAdd our future-compiled LESS style sheets.\n\n\n    assets.styleSheets.default.push '/css/style.css'\n    assets.styleSheets.production.push '/css/style.css'\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.less ?= {}\n\n    shrubSkin.gruntSkin gruntConfig, 'shrub-skin-strapped'\n\n    gruntConfig.configureTask 'less', 'shrub-skin-strapped', files: [\n      src: [\n        \"#{__dirname}/app/less/style.less\"\n      ]\n      dest: 'app/skin/shrub-skin-strapped/css/style.css'\n    ]\n\n    gruntConfig.configureTask(\n      'watch', 'shrub-skin-strappedLess'\n\n      files: [\n        \"#{__dirname}/app/less/style.less\"\n      ]\n      tasks: [\n        'newer:less:shrub-skin-strapped'\n      ]\n      options: livereload: true\n    )\n\n    gruntConfig.registerTask 'build:shrub-skin-strapped', [\n      'clean:shrub-skin-strapped'\n      'newer:copy:shrub-skin-strapped'\n      'less:shrub-skin-strapped'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-skin-strapped']\n\n    gruntConfig.loadNpmTasks ['grunt-contrib-less']",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-skin-strapped/#strapped",
            "text": "Shrub's default skin.  path = require 'path'\n\nshrubSkin = require 'shrub-skin'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubNodemailerHtml    registrar.registerHook 'shrubNodemailerHtml', ($body, html, $) ->\n\n    $('.container > .main', $body).html html\n\n    $body.find('.navbar-toggle, .navbar-collapse').remove()\n    $body.find('[data-shrub-ui-messages]').remove()\n\n    $body.find('script').remove()\n\n    $('noscript', $body).remove()  Implements hook  shrubSkinAssets    registrar.registerHook 'shrubSkinAssets', (assets) ->  Add our future-compiled LESS style sheets.      assets.styleSheets.default.push '/css/style.css'\n    assets.styleSheets.production.push '/css/style.css'  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.less ?= {}\n\n    shrubSkin.gruntSkin gruntConfig, 'shrub-skin-strapped'\n\n    gruntConfig.configureTask 'less', 'shrub-skin-strapped', files: [\n      src: [\n        \"#{__dirname}/app/less/style.less\"\n      ]\n      dest: 'app/skin/shrub-skin-strapped/css/style.css'\n    ]\n\n    gruntConfig.configureTask(\n      'watch', 'shrub-skin-strappedLess'\n\n      files: [\n        \"#{__dirname}/app/less/style.less\"\n      ]\n      tasks: [\n        'newer:less:shrub-skin-strapped'\n      ]\n      options: livereload: true\n    )\n\n    gruntConfig.registerTask 'build:shrub-skin-strapped', [\n      'clean:shrub-skin-strapped'\n      'newer:copy:shrub-skin-strapped'\n      'less:shrub-skin-strapped'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-skin-strapped']\n\n    gruntConfig.loadNpmTasks ['grunt-contrib-less']",
            "title": "Strapped"
        },
        {
            "location": "/source/packages/shrub-skin/client/",
            "text": "Skinning\n\n\nImplement the skin system, allowing clients to change the look and feel of\nthe site on-the-fly, as well as quickly load assets from the default skin on\npage load.\n\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->\n\n  currentSkinKey = null\n  defaultSkinKey = config.get 'packageConfig:shrub-skin:default'\n\n\n\n\nImplements hook \nshrubAngularDirectiveAlter\n\n\n  registrar.registerHook 'shrubAngularDirectiveAlter', (directive, path) -> [\n\n    '$cacheFactory', '$compile', '$http', '$injector', '$interpolate', '$q', '$rootScope'\n    ($cacheFactory, $compile, $http, $injector, $interpolate, $q, $rootScope) ->\n\n\n\n\nEnsure ID is a candidate.\n\n\n      directive.candidateKeys ?= []\n      directive.candidateKeys.unshift 'id'\n\n\n\n\nProxy link function to add our own directive retrieval and compilation\nstep.\n\n\n      link = directive.link\n      directive.link = (scope, element, attr, controller, transclude) ->\n\n        candidateHooksInvoked = {}\n\n\n\n\nSave top-level arguments for later calls to link functions.\n\n\n        topLevelArgs = arguments\n\n\n\n\nCurrent template candidate.\n\n\n        candidate = undefined\n\n        recalculateCandidate = ->\n\n\n\n\nGet the skin assets.\n\n\n          skinAssets = config.get(\n            \"packageConfig:shrub-skin:assets:#{currentSkinKey}\"\n          )\n\n\n\n\nTrack changes to the current template candidate.\n\n\n          oldCandidate = candidate\n\n\n\n\nBuild a list of all candidates by first attempting to interpolate\ncandidate keys, and falling back to attribute values, if any.\nCandidate arrays are joined by single dashes.\n\n\n          candidateList = do ->\n            list = []\n\n            for keys in directive.candidateKeys\n              keys = [keys] unless angular.isArray keys\n\n              item = []\n              for key in keys\n\n                specific = scope[key]\n                specific = attr[key] unless specific\n\n                item.push specific if specific\n\n              item = item.join '-'\n              list.push item if item\n\n            list\n\n\n\n\nMap the candidate list to template filenames and add the base path\ntemplate candidate.\n\n\n          candidateTemplates = for candidate_ in candidateList\n            \"#{path}--#{candidate_}.html\"\n          candidateTemplates.push \"#{path}.html\"\n\n\n\n\nReturn the first existing template. The asset templates are\nalready sorted by descending specificity.\n\n\n          candidate = do ->\n            for uri in candidateTemplates\n              return uri if skinAssets?.templates?[uri]\n\n            return null\n\n\n\n\nIf the candidate changed, clear the hook invocation cache and\nrelink.\n\n\n          if candidate isnt oldCandidate\n            candidateHooksInvoked = {}\n\n\n\n\nInsert and compile the template HTML if it exists.\n\n\n            if skinAssets?.templates?[candidate]\n\n\n\n\nInsert and compile HTML.\n\n\n              element.html skinAssets.templates[candidate]\n              $compile(element.contents())(scope)\n\n\n\n\nCall directive link function.\n\n\n            link topLevelArgs... if link?\n\n\n\n\nInvoke the candidate link hooks.\n\n\n          invocations = [\n            'shrubSkinLink'\n            \"shrubSkinLink--#{directive.name}\"\n          ]\n\n\n\n\nAdd the candidates in reverse order, so they ascend in\nspecificity.\n\n\n          invocations.push(\n            \"shrubSkinLink--#{directive.name}--#{c}\"\n          ) for c in candidateList.reverse()\n\n          for hook in invocations\n            continue if candidateHooksInvoked[hook]\n            candidateHooksInvoked[hook] = true\n\n\n\n\nInvoke hook \nshrubSkinLink\n\n\nInvoke hook \nshrubSkinLink--DIRECTIVE\n\n\nInvoke hook \nshrubSkinLink--DIRECTIVE--ID\n\n\n            for f in pkgman.invokeFlat hook\n\n              $injector.invoke(\n                f, null\n                $directive: directive\n                $scope: scope\n                $element: element\n                $attr: attr\n                $controller: controller\n                $transclude: transclude\n              )\n\n        applySkin = (skinKey) ->\n          return if currentSkinKey is skinKey\n          currentSkinKey = skinKey\n\n          candidateHooksInvoked = {}\n          recalculateCandidate()\n\n        applySkin defaultSkinKey\n\n\n\n\nRelink again every time the skin changes.\n\n\n        $rootScope.$on 'shrub-skin.changed', (_, skinKey) -> applySkin skinKey\n\n\n\n\nSet watches for all candidate-related values.\n\n\n        keysSeen = {}\n        watchers = []\n        for keys in directive.candidateKeys\n\n          keys = [keys] unless angular.isArray keys\n          for key in keys\n            continue if keysSeen[key]\n            keysSeen[key] = true\n\n            attr.$observe key, recalculateCandidate\n            watchers.push -> scope[attr[key]]\n\n        scope.$watchGroup watchers, recalculateCandidate\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularProvider\n\n\n  registrar.registerHook 'shrubAngularProvider', -> [\n\n    '$injector', '$provide'\n    ($injector, $provide) ->\n\n      provider = {}\n\n      provider.$get = [\n        '$http', '$interval', '$q', '$rootScope', '$window'\n        ($http, $interval, $q, $rootScope, $window) ->\n\n          service = {}\n\n\n\n\nskin.addStylesheet\n\n\n(String) \nhref\n - The href of the stylesheet to add. \nAdd a skin\nstylesheet.\n\n\n          service.addStylesheet = (href) ->\n\n            deferred = $q.defer()\n\n            styleSheets = $window.document.styleSheets\n            index = styleSheets.length\n\n\n\n\nInsert the stylesheed as a link element in the head element,\nclassed with 'skin' so we can easily remove it if the skin\nchanges.\n\n\n            element = $window.document.createElement 'link'\n            element.type = 'text/css'\n            element.rel = 'stylesheet'\n            element.href = \"/skin/#{currentSkinKey}/#{href}\"\n            element.className = 'skin'\n            angular.element('head').append element\n\n            resolve = -> deferred.resolve()\n\n\n\n\nA rare case where IE actually does the right thing! (and Opera).\n\n\n            if $window.opera or ~$window.navigator.userAgent.indexOf 'MSIE'\n\n              element.onload = resolve\n              element.onreadystatechange = ->\n                switch @readyState\n                  when 'loaded', 'complete'\n                    resolve()\n\n\n\n\nEveryone else needs to resort to polling.\n\n\n            else\n\n              wasParsed = ->\n\n                try\n\n                  styleSheet = styleSheets[index]\n\n                  return true if styleSheet.cssRules\n                  return true if styleSheet.rules?.length\n\n                  return false\n\n                catch error\n\n                  return false\n\n              poll = $interval ->\n\n                if wasParsed()\n\n                  $interval.cancel poll\n                  resolve()\n\n                return\n\n              , 10\n\n            deferred.promise\n\n\n\n\nskin.addStylesheets\n\n\n(String Array) \nhrefs\n - The hrefs of the stylesheets to add. \nAdd\na list of skin stylesheets.\n\n\n          service.addStylesheets = (hrefs) ->\n            $q.all (service.addStylesheet href for href in hrefs)\n\n\n\n\nCLoak the body during the skin transition.\n\n\n          addBodyCloak = ->\n\n            $body = angular.element 'body'\n            $body.addClass 'shrub-skin-cloak'\n\n\n\n\nRemove the cloak after the transition is complete.\n\n\n          removeBodyCloak = ->\n\n            $body = angular.element 'body'\n            $body.removeClass 'shrub-skin-cloak'\n\n\n\n\nRemove all current skin stylesheets.\n\n\n          removeSkinStylesheets = ->\n\n            $head = angular.element 'head'\n            head = $head[0]\n\n            node = head.firstChild\n            while node\n\n              nextNode = node.nextSibling\n\n              if 'LINK' is node.tagName\n                if angular.element(node).hasClass 'skin'\n                  head.removeChild node\n\n              node = nextNode\n\n            return\n\n\n\n\nUse the correct assets for the environment.\n\n\n          environmentKey = if 'production' is cache.get 'environment'\n            'production'\n          else\n            'default'\n\n\n\n\nskin.change\n\n\n(String) \nskinKey\n - The key of the skin to change to \nChange\nskin.\n\n\n          service.change = (skinKey) ->\n            return if skinKey is currentSkinKey\n\n\n\n\nCloak the body.\n\n\n            addBodyCloak()\n            removeSkinStylesheets()\n\n            skinAssets = config.get(\n              \"packageConfig:shrub-skin:assets:#{skinKey}\"\n            )\n\n\n\n\nUncloak and notify when finished.\n\n\n            service.addStylesheets(\n              skinAssets.styleSheets[environmentKey]\n            ).finally ->\n              removeBodyCloak()\n\n              $rootScope.$broadcast 'shrub-skin.changed', skinKey\n\n          service\n\n      ]\n\n      provider\n\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-skin/client/#skinning",
            "text": "Implement the skin system, allowing clients to change the look and feel of\nthe site on-the-fly, as well as quickly load assets from the default skin on\npage load.  config = require 'config'\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->\n\n  currentSkinKey = null\n  defaultSkinKey = config.get 'packageConfig:shrub-skin:default'  Implements hook  shrubAngularDirectiveAlter    registrar.registerHook 'shrubAngularDirectiveAlter', (directive, path) -> [\n\n    '$cacheFactory', '$compile', '$http', '$injector', '$interpolate', '$q', '$rootScope'\n    ($cacheFactory, $compile, $http, $injector, $interpolate, $q, $rootScope) ->  Ensure ID is a candidate.        directive.candidateKeys ?= []\n      directive.candidateKeys.unshift 'id'  Proxy link function to add our own directive retrieval and compilation\nstep.        link = directive.link\n      directive.link = (scope, element, attr, controller, transclude) ->\n\n        candidateHooksInvoked = {}  Save top-level arguments for later calls to link functions.          topLevelArgs = arguments  Current template candidate.          candidate = undefined\n\n        recalculateCandidate = ->  Get the skin assets.            skinAssets = config.get(\n            \"packageConfig:shrub-skin:assets:#{currentSkinKey}\"\n          )  Track changes to the current template candidate.            oldCandidate = candidate  Build a list of all candidates by first attempting to interpolate\ncandidate keys, and falling back to attribute values, if any.\nCandidate arrays are joined by single dashes.            candidateList = do ->\n            list = []\n\n            for keys in directive.candidateKeys\n              keys = [keys] unless angular.isArray keys\n\n              item = []\n              for key in keys\n\n                specific = scope[key]\n                specific = attr[key] unless specific\n\n                item.push specific if specific\n\n              item = item.join '-'\n              list.push item if item\n\n            list  Map the candidate list to template filenames and add the base path\ntemplate candidate.            candidateTemplates = for candidate_ in candidateList\n            \"#{path}--#{candidate_}.html\"\n          candidateTemplates.push \"#{path}.html\"  Return the first existing template. The asset templates are\nalready sorted by descending specificity.            candidate = do ->\n            for uri in candidateTemplates\n              return uri if skinAssets?.templates?[uri]\n\n            return null  If the candidate changed, clear the hook invocation cache and\nrelink.            if candidate isnt oldCandidate\n            candidateHooksInvoked = {}  Insert and compile the template HTML if it exists.              if skinAssets?.templates?[candidate]  Insert and compile HTML.                element.html skinAssets.templates[candidate]\n              $compile(element.contents())(scope)  Call directive link function.              link topLevelArgs... if link?  Invoke the candidate link hooks.            invocations = [\n            'shrubSkinLink'\n            \"shrubSkinLink--#{directive.name}\"\n          ]  Add the candidates in reverse order, so they ascend in\nspecificity.            invocations.push(\n            \"shrubSkinLink--#{directive.name}--#{c}\"\n          ) for c in candidateList.reverse()\n\n          for hook in invocations\n            continue if candidateHooksInvoked[hook]\n            candidateHooksInvoked[hook] = true  Invoke hook  shrubSkinLink  Invoke hook  shrubSkinLink--DIRECTIVE  Invoke hook  shrubSkinLink--DIRECTIVE--ID              for f in pkgman.invokeFlat hook\n\n              $injector.invoke(\n                f, null\n                $directive: directive\n                $scope: scope\n                $element: element\n                $attr: attr\n                $controller: controller\n                $transclude: transclude\n              )\n\n        applySkin = (skinKey) ->\n          return if currentSkinKey is skinKey\n          currentSkinKey = skinKey\n\n          candidateHooksInvoked = {}\n          recalculateCandidate()\n\n        applySkin defaultSkinKey  Relink again every time the skin changes.          $rootScope.$on 'shrub-skin.changed', (_, skinKey) -> applySkin skinKey  Set watches for all candidate-related values.          keysSeen = {}\n        watchers = []\n        for keys in directive.candidateKeys\n\n          keys = [keys] unless angular.isArray keys\n          for key in keys\n            continue if keysSeen[key]\n            keysSeen[key] = true\n\n            attr.$observe key, recalculateCandidate\n            watchers.push -> scope[attr[key]]\n\n        scope.$watchGroup watchers, recalculateCandidate\n\n  ]  Implements hook  shrubAngularProvider    registrar.registerHook 'shrubAngularProvider', -> [\n\n    '$injector', '$provide'\n    ($injector, $provide) ->\n\n      provider = {}\n\n      provider.$get = [\n        '$http', '$interval', '$q', '$rootScope', '$window'\n        ($http, $interval, $q, $rootScope, $window) ->\n\n          service = {}",
            "title": "Skinning"
        },
        {
            "location": "/source/packages/shrub-skin/client/#skinaddstylesheet",
            "text": "(String)  href  - The href of the stylesheet to add.  Add a skin\nstylesheet.            service.addStylesheet = (href) ->\n\n            deferred = $q.defer()\n\n            styleSheets = $window.document.styleSheets\n            index = styleSheets.length  Insert the stylesheed as a link element in the head element,\nclassed with 'skin' so we can easily remove it if the skin\nchanges.              element = $window.document.createElement 'link'\n            element.type = 'text/css'\n            element.rel = 'stylesheet'\n            element.href = \"/skin/#{currentSkinKey}/#{href}\"\n            element.className = 'skin'\n            angular.element('head').append element\n\n            resolve = -> deferred.resolve()  A rare case where IE actually does the right thing! (and Opera).              if $window.opera or ~$window.navigator.userAgent.indexOf 'MSIE'\n\n              element.onload = resolve\n              element.onreadystatechange = ->\n                switch @readyState\n                  when 'loaded', 'complete'\n                    resolve()  Everyone else needs to resort to polling.              else\n\n              wasParsed = ->\n\n                try\n\n                  styleSheet = styleSheets[index]\n\n                  return true if styleSheet.cssRules\n                  return true if styleSheet.rules?.length\n\n                  return false\n\n                catch error\n\n                  return false\n\n              poll = $interval ->\n\n                if wasParsed()\n\n                  $interval.cancel poll\n                  resolve()\n\n                return\n\n              , 10\n\n            deferred.promise",
            "title": "skin.addStylesheet"
        },
        {
            "location": "/source/packages/shrub-skin/client/#skinaddstylesheets",
            "text": "(String Array)  hrefs  - The hrefs of the stylesheets to add.  Add\na list of skin stylesheets.            service.addStylesheets = (hrefs) ->\n            $q.all (service.addStylesheet href for href in hrefs)  CLoak the body during the skin transition.            addBodyCloak = ->\n\n            $body = angular.element 'body'\n            $body.addClass 'shrub-skin-cloak'  Remove the cloak after the transition is complete.            removeBodyCloak = ->\n\n            $body = angular.element 'body'\n            $body.removeClass 'shrub-skin-cloak'  Remove all current skin stylesheets.            removeSkinStylesheets = ->\n\n            $head = angular.element 'head'\n            head = $head[0]\n\n            node = head.firstChild\n            while node\n\n              nextNode = node.nextSibling\n\n              if 'LINK' is node.tagName\n                if angular.element(node).hasClass 'skin'\n                  head.removeChild node\n\n              node = nextNode\n\n            return  Use the correct assets for the environment.            environmentKey = if 'production' is cache.get 'environment'\n            'production'\n          else\n            'default'",
            "title": "skin.addStylesheets"
        },
        {
            "location": "/source/packages/shrub-skin/client/#skinchange",
            "text": "(String)  skinKey  - The key of the skin to change to  Change\nskin.            service.change = (skinKey) ->\n            return if skinKey is currentSkinKey  Cloak the body.              addBodyCloak()\n            removeSkinStylesheets()\n\n            skinAssets = config.get(\n              \"packageConfig:shrub-skin:assets:#{skinKey}\"\n            )  Uncloak and notify when finished.              service.addStylesheets(\n              skinAssets.styleSheets[environmentKey]\n            ).finally ->\n              removeBodyCloak()\n\n              $rootScope.$broadcast 'shrub-skin.changed', skinKey\n\n          service\n\n      ]\n\n      provider\n\n  ]",
            "title": "skin.change"
        },
        {
            "location": "/source/packages/shrub-skin/",
            "text": "Skin\n\n\nAllows the visual aspects of the site to be controlled by skin packages.\n\n\nfs = require 'fs'\npath = require 'path'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubConfigClient\n\n\n  registrar.registerHook 'shrubConfigClient', ->\n\n    skinAssets = {}\n    for packagePath in pkgman.packagesImplementing 'shrubSkinAssets'\n      skinAssets[packagePath] = exports.assets packagePath\n\n    default: config.get 'packageConfig:shrub-skin:default'\n    assets: skinAssets\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\n  registrar.registerHook 'path', 'shrubHttpMiddleware', (http) ->\n\n    label: 'Skin path handling'\n    middleware: [\n\n      (req, res, next) ->\n\n\n\n\nIf we get here and it's a skin URL, it must be a 404 otherwise,\nexpress/static would have picked it up already.\n\n\n        return res.sendStatus 404 if req.path.match /^\\/skin\\//\n\n        next()\n    ]\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\n  registrar.registerHook 'render', 'shrubHttpMiddleware', (http) ->\n\n    label: 'Render skinned page HTML'\n    middleware: [\n\n      (req, res, next) ->\n\n        return exports.renderAppHtml().then((html) ->\n          req.delivery = html\n          next()\n        ).catch (error) -> next error\n\n  ]\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n\n\n\nDefault skin.\n\n\n    default: 'shrub-skin-strapped'\n\n\n\n\nactiveKey\n\n\nGet the active skin's key\n\n\nexports.activeKey = -> config.get 'packageConfig:shrub-skin:default'\n\n\n\n\ngruntSkin\n\n\nHelper function to copy skin assets. Configures a grunt task, e.g. if your\nskin is named \nmy-special-skin\n, the configured task is named\n\nmy-special-skinCopy\n. This is not automatically added to the build\ndependencies, you do it manually so you can control exactly when it\nhappens.\n\n\nexports.gruntSkin = (gruntConfig, key) ->\n\n  skinPath = path.dirname require.resolve key\n\n  gruntConfig.clean ?= {}\n  gruntConfig.copy ?= {}\n  gruntConfig.watch ?= {}\n\n  gruntConfig.configureTask 'clean', key, [\n    \"app/skin/#{key}\"\n  ]\n\n  copyFiles = []\n\n  copyFiles.push(\n    expand: true\n    cwd: \"#{skinPath}/app\"\n    src: [\"#{verbatim}/**/*\"]\n    dest: \"app/skin/#{key}\"\n  ) for verbatim in ['css', 'fonts', 'img', 'js', 'lib']\n\n  gruntConfig.configureTask 'copy', key, files: copyFiles\n\n  gruntConfig.configureTask(\n    'watch', \"#{key}Copy\"\n\n    files: copyFiles.concat(\n      src: \"template/**/*\"\n    ).map(\n      (copyFile) -> \"#{skinPath}/app/#{copyFile.src}\"\n    )\n    tasks: [\n      \"newer:copy:#{key}\"\n    ]\n    options: livereload: true\n  )\n\n\n\n\nrenderAppHtml\n\n\nRender the application HTML.\n\n\nexports.renderAppHtml = ->\n\n  Promise = require 'bluebird'\n\n  cheerio = require 'cheerio'\n\n  assets = require 'shrub-assets'\n\n  skinKey = exports.activeKey()\n  skinDirectory = exports.skinDirectory skinKey\n\n  environmentKey = if 'production' is process.env.NODE_ENV\n    'production'\n  else\n    'default'\n\n\n\n\nRead the app HTML.\n\n\n  readFile = Promise.promisify fs.readFile, fs\n  readFile(\n    \"#{skinDirectory}/app/template/app.html\", encoding: 'utf8'\n  ).then (html) ->\n\n    $ = cheerio.load html\n\n    pkgman.invoke 'skinRenderAppHtml', $\n\n    $head = $('head')\n    $body = $('body')\n\n\n\n\nInject the application-level assets first.\n\n\n    appAssets = assets.assets()\n\n    $head.append $('<link />').attr(\n      type: 'text/css'\n      rel: 'styleSheet'\n      href: styleSheet\n    ) for styleSheet in appAssets.styleSheets\n\n    $body.append $('<script />').attr(\n      src: script\n    ) for script in appAssets.scripts\n\n\n\n\nInject the skin-level assets.\n\n\n    skinAssets = exports.assets skinKey\n\n    $head.append $('<link />').attr(\n      class: 'skin'\n      type: 'text/css'\n      rel: 'stylesheet'\n      href: \"/skin/#{skinKey}/#{styleSheet}\"\n    ) for styleSheet in skinAssets.styleSheets[environmentKey] ? []\n\n    $body.append $('<script />').attr(\n      class: 'skin'\n      src: \"/skin/#{skinKey}/#{script}\"\n    ) for script in skinAssets.scripts[environmentKey] ? []\n\n\n\n\nReturn the full HTML.\n\n\n    return $.html()\n\n\n\n\nskinDirectory\n\n\n\n\n(String) \nkey\n - The skin key.\n\n\n\n\nGet the directory a skin lives within.\n\n\nexports.skinDirectory = (key) -> path.dirname require.resolve key\n\n\n\n\nassets\n\n\n\n\n(String) \nkey\n - The skin key.\n\n\n\n\nGet the assets for a skin.\n\n\nTODO: This needs caching.\n\n\nexports.assets = (skinKey) ->\n\n  glob = require 'simple-glob'\n  pkgman = require 'pkgman'\n\n  skinPath = path.dirname require.resolve skinKey\n  skinModule = require skinKey\n\n\n\n\nRead in all the templates.\n\n\n  templates = {}\n  for templatePath in glob cwd: \"#{skinPath}/app/template\", [\n    '**/*.html', '!app.html'\n  ]\n\n\n\n\nStrip out most of the unnecessary whitespace.\n\n\n    templates[templatePath] = fs.readFileSync(\n      \"#{skinPath}/app/template/#{templatePath}\"\n    ).toString('utf8').replace /\\s+/g, ' '\n\n\n\n\nAssets currently default to .js/.css for default and .min.js and .min.css\nfor production.\n\n\n  skinAssets =\n\n    templates: templates\n\n    scripts:\n\n      default: glob cwd: \"#{skinPath}/app\", [\n        'js/**/*.js', '!js/**/*.min.js'\n      ]\n\n      production: glob cwd: \"#{skinPath}/app\", [\n        'js/**/*.min.js'\n      ]\n\n    styleSheets:\n\n      default: glob cwd: \"#{skinPath}/app\", [\n        'css/**/*.css', '!css/**/*.min.css'\n      ]\n\n      production: glob cwd: \"#{skinPath}/app\", [\n        'css/**/*.min.css'\n      ]\n\n\n\n\nMake script and stylesheet paths absolute.\n\n\n  for type in ['scripts', 'styleSheets']\n    for env in ['default', 'production']\n      for asset, i in skinAssets[type][env]\n        skinAssets[type][env][i] = \"/#{asset}\"\n\n\n\n\nInvoke hook \nshrubSkinAssets\n\n\n  pkgman.invokePackage skinKey, 'shrubSkinAssets', skinAssets\n\n  return skinAssets",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-skin/#skin",
            "text": "Allows the visual aspects of the site to be controlled by skin packages.  fs = require 'fs'\npath = require 'path'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubConfigClient    registrar.registerHook 'shrubConfigClient', ->\n\n    skinAssets = {}\n    for packagePath in pkgman.packagesImplementing 'shrubSkinAssets'\n      skinAssets[packagePath] = exports.assets packagePath\n\n    default: config.get 'packageConfig:shrub-skin:default'\n    assets: skinAssets  Implements hook  shrubHttpMiddleware    registrar.registerHook 'path', 'shrubHttpMiddleware', (http) ->\n\n    label: 'Skin path handling'\n    middleware: [\n\n      (req, res, next) ->  If we get here and it's a skin URL, it must be a 404 otherwise,\nexpress/static would have picked it up already.          return res.sendStatus 404 if req.path.match /^\\/skin\\//\n\n        next()\n    ]  Implements hook  shrubHttpMiddleware    registrar.registerHook 'render', 'shrubHttpMiddleware', (http) ->\n\n    label: 'Render skinned page HTML'\n    middleware: [\n\n      (req, res, next) ->\n\n        return exports.renderAppHtml().then((html) ->\n          req.delivery = html\n          next()\n        ).catch (error) -> next error\n\n  ]  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->  Default skin.      default: 'shrub-skin-strapped'",
            "title": "Skin"
        },
        {
            "location": "/source/packages/shrub-skin/#activekey",
            "text": "Get the active skin's key  exports.activeKey = -> config.get 'packageConfig:shrub-skin:default'",
            "title": "activeKey"
        },
        {
            "location": "/source/packages/shrub-skin/#gruntskin",
            "text": "Helper function to copy skin assets. Configures a grunt task, e.g. if your\nskin is named  my-special-skin , the configured task is named my-special-skinCopy . This is not automatically added to the build\ndependencies, you do it manually so you can control exactly when it\nhappens.  exports.gruntSkin = (gruntConfig, key) ->\n\n  skinPath = path.dirname require.resolve key\n\n  gruntConfig.clean ?= {}\n  gruntConfig.copy ?= {}\n  gruntConfig.watch ?= {}\n\n  gruntConfig.configureTask 'clean', key, [\n    \"app/skin/#{key}\"\n  ]\n\n  copyFiles = []\n\n  copyFiles.push(\n    expand: true\n    cwd: \"#{skinPath}/app\"\n    src: [\"#{verbatim}/**/*\"]\n    dest: \"app/skin/#{key}\"\n  ) for verbatim in ['css', 'fonts', 'img', 'js', 'lib']\n\n  gruntConfig.configureTask 'copy', key, files: copyFiles\n\n  gruntConfig.configureTask(\n    'watch', \"#{key}Copy\"\n\n    files: copyFiles.concat(\n      src: \"template/**/*\"\n    ).map(\n      (copyFile) -> \"#{skinPath}/app/#{copyFile.src}\"\n    )\n    tasks: [\n      \"newer:copy:#{key}\"\n    ]\n    options: livereload: true\n  )",
            "title": "gruntSkin"
        },
        {
            "location": "/source/packages/shrub-skin/#renderapphtml",
            "text": "Render the application HTML.  exports.renderAppHtml = ->\n\n  Promise = require 'bluebird'\n\n  cheerio = require 'cheerio'\n\n  assets = require 'shrub-assets'\n\n  skinKey = exports.activeKey()\n  skinDirectory = exports.skinDirectory skinKey\n\n  environmentKey = if 'production' is process.env.NODE_ENV\n    'production'\n  else\n    'default'  Read the app HTML.    readFile = Promise.promisify fs.readFile, fs\n  readFile(\n    \"#{skinDirectory}/app/template/app.html\", encoding: 'utf8'\n  ).then (html) ->\n\n    $ = cheerio.load html\n\n    pkgman.invoke 'skinRenderAppHtml', $\n\n    $head = $('head')\n    $body = $('body')  Inject the application-level assets first.      appAssets = assets.assets()\n\n    $head.append $('<link />').attr(\n      type: 'text/css'\n      rel: 'styleSheet'\n      href: styleSheet\n    ) for styleSheet in appAssets.styleSheets\n\n    $body.append $('<script />').attr(\n      src: script\n    ) for script in appAssets.scripts  Inject the skin-level assets.      skinAssets = exports.assets skinKey\n\n    $head.append $('<link />').attr(\n      class: 'skin'\n      type: 'text/css'\n      rel: 'stylesheet'\n      href: \"/skin/#{skinKey}/#{styleSheet}\"\n    ) for styleSheet in skinAssets.styleSheets[environmentKey] ? []\n\n    $body.append $('<script />').attr(\n      class: 'skin'\n      src: \"/skin/#{skinKey}/#{script}\"\n    ) for script in skinAssets.scripts[environmentKey] ? []  Return the full HTML.      return $.html()",
            "title": "renderAppHtml"
        },
        {
            "location": "/source/packages/shrub-skin/#skindirectory",
            "text": "(String)  key  - The skin key.   Get the directory a skin lives within.  exports.skinDirectory = (key) -> path.dirname require.resolve key",
            "title": "skinDirectory"
        },
        {
            "location": "/source/packages/shrub-skin/#assets",
            "text": "(String)  key  - The skin key.   Get the assets for a skin.  TODO: This needs caching.  exports.assets = (skinKey) ->\n\n  glob = require 'simple-glob'\n  pkgman = require 'pkgman'\n\n  skinPath = path.dirname require.resolve skinKey\n  skinModule = require skinKey  Read in all the templates.    templates = {}\n  for templatePath in glob cwd: \"#{skinPath}/app/template\", [\n    '**/*.html', '!app.html'\n  ]  Strip out most of the unnecessary whitespace.      templates[templatePath] = fs.readFileSync(\n      \"#{skinPath}/app/template/#{templatePath}\"\n    ).toString('utf8').replace /\\s+/g, ' '  Assets currently default to .js/.css for default and .min.js and .min.css\nfor production.    skinAssets =\n\n    templates: templates\n\n    scripts:\n\n      default: glob cwd: \"#{skinPath}/app\", [\n        'js/**/*.js', '!js/**/*.min.js'\n      ]\n\n      production: glob cwd: \"#{skinPath}/app\", [\n        'js/**/*.min.js'\n      ]\n\n    styleSheets:\n\n      default: glob cwd: \"#{skinPath}/app\", [\n        'css/**/*.css', '!css/**/*.min.css'\n      ]\n\n      production: glob cwd: \"#{skinPath}/app\", [\n        'css/**/*.min.css'\n      ]  Make script and stylesheet paths absolute.    for type in ['scripts', 'styleSheets']\n    for env in ['default', 'production']\n      for asset, i in skinAssets[type][env]\n        skinAssets[type][env][i] = \"/#{asset}\"  Invoke hook  shrubSkinAssets    pkgman.invokePackage skinKey, 'shrubSkinAssets', skinAssets\n\n  return skinAssets",
            "title": "assets"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/client/",
            "text": "Socket.IO socket\n\n\nProvide an Angular service wrapping Socket.IO.\n\n\nTODO: Need to handle connection errors.\n\n\nconfig = require 'config'\ndebug = require('debug') 'shrub:socket.io'\n\nSocket = require 'shrub-socket/socket'\n\nexports.Manager = class SocketIoSocket extends Socket\n\n  @$inject = ['$rootScope']\n\n\n\n\nconstructor\n*\n\n\n  constructor: ($rootScope) ->\n    super\n\n    @_isConnected = false\n    @_$rootScope = $rootScope\n    @_socket = io.connect()\n\n\n\n\nQueue up any messages to be emitted before initialization completes, and\nsend them all immediately upon connection.\n\n\n    @_initializedQueue = []\n    @_socket.on 'initialized', =>\n      @emit.apply this, args for args in @_initializedQueue\n\n    @_socket.on 'connect', => @_isConnected = true\n\n    return\n\n\n\n\nSocketIoSocket#disconnect\n\n\nDisconnect the socket from the server.\n\n\n  disconnect: -> @_socket.disconnect()\n\n\n\n\nSocketIoSocket#emit\n\n\n\n\n\n\n(String) \neventName\n - The name of the event to emit.\n\n\n\n\n\n\n(any) \ndata\n - The event data to emit.\n\n\n\n\n\n\n(optional Function) \nfn\n - Callback called with whatever the server\nreturned.\n\n\n\n\n\n\nEmit an event to the server.\n\n\n  emit: (eventName, data, fn) ->\n    return @_initializedQueue.push arguments unless @_isConnected\n\n\n\n\nLog.\n\n\n    message = \"sent: #{eventName}\"\n    message += \", #{JSON.stringify data, null, '  '}\" if data?\n    debug message\n\n    @_socket.emit eventName, data, (response) =>\n\n\n\n\nEarly out if the client doesn't care about the response.\n\n\n      return unless fn?\n\n\n\n\nLog.\n\n\n      message = \"response: #{eventName}\"\n      message += \", #{\n        JSON.stringify response, null, '  '\n      }\" if response.result? or response.error?\n      debug message\n\n\n\n\nEnter Angular scope.\n\n\n      @_$rootScope.$apply -> fn response\n\n\n\n\nSocketIoSocket#on\n\n\n\n\n\n\n(String) \neventName\n - The name of the event to listen for.\n\n\n\n\n\n\n(optional Function) \nfn\n - Callback called with the event data.\n\n\n\n\n\n\nListen for an event.\n\n\n  on: (eventName, fn) ->\n\n\n\n\nWe need to digest the scope after the response.\n\n\n    @_socket.on eventName, (data) =>\n\n\n\n\nLog.\n\n\n      message = \"received: #{eventName}\"\n      message += \", #{JSON.stringify data, null, '  '}\" if data?\n      debug message\n\n\n\n\nEnter Angular scope.\n\n\n      onArguments = arguments\n      @_$rootScope.$apply => fn.apply @_socket, onArguments",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/client/#socketio-socket",
            "text": "Provide an Angular service wrapping Socket.IO.  TODO: Need to handle connection errors.  config = require 'config'\ndebug = require('debug') 'shrub:socket.io'\n\nSocket = require 'shrub-socket/socket'\n\nexports.Manager = class SocketIoSocket extends Socket\n\n  @$inject = ['$rootScope']",
            "title": "Socket.IO socket"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/client/#constructor",
            "text": "constructor: ($rootScope) ->\n    super\n\n    @_isConnected = false\n    @_$rootScope = $rootScope\n    @_socket = io.connect()  Queue up any messages to be emitted before initialization completes, and\nsend them all immediately upon connection.      @_initializedQueue = []\n    @_socket.on 'initialized', =>\n      @emit.apply this, args for args in @_initializedQueue\n\n    @_socket.on 'connect', => @_isConnected = true\n\n    return",
            "title": "constructor*"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/client/#socketiosocketdisconnect",
            "text": "Disconnect the socket from the server.    disconnect: -> @_socket.disconnect()",
            "title": "SocketIoSocket#disconnect"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/client/#socketiosocketemit",
            "text": "(String)  eventName  - The name of the event to emit.    (any)  data  - The event data to emit.    (optional Function)  fn  - Callback called with whatever the server\nreturned.    Emit an event to the server.    emit: (eventName, data, fn) ->\n    return @_initializedQueue.push arguments unless @_isConnected  Log.      message = \"sent: #{eventName}\"\n    message += \", #{JSON.stringify data, null, '  '}\" if data?\n    debug message\n\n    @_socket.emit eventName, data, (response) =>  Early out if the client doesn't care about the response.        return unless fn?  Log.        message = \"response: #{eventName}\"\n      message += \", #{\n        JSON.stringify response, null, '  '\n      }\" if response.result? or response.error?\n      debug message  Enter Angular scope.        @_$rootScope.$apply -> fn response",
            "title": "SocketIoSocket#emit"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/client/#socketiosocketon",
            "text": "(String)  eventName  - The name of the event to listen for.    (optional Function)  fn  - Callback called with the event data.    Listen for an event.    on: (eventName, fn) ->  We need to digest the scope after the response.      @_socket.on eventName, (data) =>  Log.        message = \"received: #{eventName}\"\n      message += \", #{JSON.stringify data, null, '  '}\" if data?\n      debug message  Enter Angular scope.        onArguments = arguments\n      @_$rootScope.$apply => fn.apply @_socket, onArguments",
            "title": "SocketIoSocket#on"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/",
            "text": "Socket.IO\n\n\nBuild and serve \nSocket.IO\n.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAssetsMiddleware\n\n\n  registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    config = require 'config'\n\n    label: 'Socket.IO'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n\n          assets.scripts.push '/lib/socket.io/socket.io.min.js'\n\n        else\n\n          assets.scripts.push '/lib/socket.io/socket.io.js'\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubGruntConfig\n\n\n  registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-socket.io'\n\n    gruntConfig.registerTask 'build:shrub-socket.io', [\n      'newer:copy:shrub-socket.io'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-socket.io']\n\nexports.Manager = require './manager'",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/#socketio",
            "text": "Build and serve  Socket.IO .  exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAssetsMiddleware    registrar.registerHook 'shrubAssetsMiddleware', ->\n\n    config = require 'config'\n\n    label: 'Socket.IO'\n    middleware: [\n\n      (assets, next) ->\n\n        if 'production' is config.get 'NODE_ENV'\n\n          assets.scripts.push '/lib/socket.io/socket.io.min.js'\n\n        else\n\n          assets.scripts.push '/lib/socket.io/socket.io.js'\n\n        next()\n\n    ]  Implements hook  shrubGruntConfig    registrar.registerHook 'shrubGruntConfig', (gruntConfig) ->\n\n    gruntConfig.copyAppFiles \"#{__dirname}/app\", 'shrub-socket.io'\n\n    gruntConfig.registerTask 'build:shrub-socket.io', [\n      'newer:copy:shrub-socket.io'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:shrub-socket.io']\n\nexports.Manager = require './manager'",
            "title": "Socket.IO"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/manager/",
            "text": "SocketIoManager\n\n\nA \nSocket.IO\n implementation of SocketManager.\n\n\n{EventEmitter} = require 'events'\n\nPromise = null\n\nconfig = null\nerrors = null\nlogging = null\n\nsocketLogger = null\n\nSocketManager = require '../shrub-socket/manager'\n\nmodule.exports = class SocketIoManager extends SocketManager\n\n\n\n\nconstructor\n\n\n  constructor: ->\n    super\n\n    Promise ?= require 'bluebird'\n\n    config ?= require 'config'\n    errors ?= require 'errors'\n    logging ?= require 'logging'\n\n    socketLogger ?= logging.create file: filename: 'logs/socket.io.log'\n\n    options = config.get 'packageConfig:shrub-socket:manager:options'\n\n\n\n\nLoad the adapter.\n\n\n    @_adapter = switch options?.store ? 'redis'\n\n      when 'redis'\n\n        redis = require 'redis'\n\n        require('socket.io-redis')(\n          pubClient: redis.createClient()\n          subClient: redis.createClient()\n        )\n\n\n\n\nSocketIoManager#broadcast\n\n\n\n\n\n\n(string) \nchannel\n - The channel to broadcast to.\n\n\n\n\n\n\n(string) \nevent\n - The event to broadcast.\n\n\n\n\n\n\n(any) \ndata\n - The data to broadcast.\n\n\n\n\n\n\nBroadcast data to clients in a room.\n\n\n  broadcast: (channel, event, data) ->\n    @io.in(channel).emit event, data\n    this\n\n\n\n\nSocketIoManager#channels\n\n\n\n\n(socket) \nsocket\n - A socket.\n\n\n\n\nGet a list of channels a socket is in.\n\n\n  channels: (socket) -> socket.rooms\n\n\n\n\nSocketIoManager#clients\n\n\n\n\n(string) \nchannel\n - The channel to check.\n\n\n\n\nGet a list of clients in a channel.\n\n\n  clients: (channel) ->\n    self = this\n    new Promise (resolve, reject) ->\n      self.io.in(channel).clients (error, clients) ->\n        return reject error if error?\n        resolve clients\n\n\n\n\nSocketIoManager#intercom\n\n\n\n\n\n\n(string) \nchannel\n - The channel to broadcast to.\n\n\n\n\n\n\n(string) \nevent\n - The event to broadcast.\n\n\n\n\n\n\n(mixed) \ndata\n - The data to broadcast.\n\n\n\n\n\n\nBroadcast data to server sockets in a room.\n\n\n  intercom: (channel, event, data) ->\n    @io.in(channel).intercom event, data\n    this\n\n\n\n\nSocketIoManager#listen\n\n\n\n\n(HttpServer) \nhttp\n - The HTTP server to listen on for connections.\n\n\n\n\nListen for socket connections coming through the HTTP server.\n\n\n  listen: (http) ->\n\n    options = config.get 'packageConfig:shrub-socket:manager:options'\n\n\n\n\nSet up the socket.io server.\n\n\n    @io = require('socket.io') http.server()\n\n\n\n\nSet the adapter.\n\n\n    @io.adapter @_adapter if @_adapter?\n\n\n\n\nAuthorization.\n\n\n    @io.use (socket, next) =>\n\n      socket.request.http = http\n      socket.request.socket = socket\n\n\n\n\nConnect provides this, it will make middleware (like session) not\nchoke and die.\n\n\n      socket.request.originalUrl = socket.request.url\n\n\n\n\nBuild a fake response which extends EventEmitter because some connect\nmiddleware (like session) listenes for errors with \non\n. Even though\nthey're never actually emitted, this will make sure nothing breaks.\n\n\n      res = new class SocketConnectionResponse extends EventEmitter\n        constructor: -> super\n\n\n\n\nStubs. \nTODO\n: Make these not stubs.\n\n\n        getHeader: -> null\n        write: -> null\n\n\n\n\nDispatch the authorization middleware.\n\n\n      @_connectionMiddleware.dispatch socket.request, res, (error) ->\n\n\n\n\nIf any kind of error was thrown, propagate it.\n\n\n        return next error if error?\n\n        next()\n\n\n\n\nConnection (post-authorization).\n\n\n    @io.on 'connection', (socket) =>\n\n\n\n\nRun the disconnection middleware on socket close.\n\n\n      oncloseProxy = socket.onclose\n      socket.onclose = =>\n        @_disconnectionMiddleware.dispatch socket.request, null, (error) ->\n          socketLogger.error errors.stack error if error?\n\n        oncloseProxy.call socket\n\n\n\n\nJoin a '$global' channel.\n\n\n      socket.join '$global', (error) =>\n        return socketLogger.error errors.stack error if error?\n\n\n\n\nDispatch the connection middleware.\n\n\n        socket.emit 'initialized'",
            "title": "manager.coffee"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/manager/#socketiomanager",
            "text": "A  Socket.IO  implementation of SocketManager.  {EventEmitter} = require 'events'\n\nPromise = null\n\nconfig = null\nerrors = null\nlogging = null\n\nsocketLogger = null\n\nSocketManager = require '../shrub-socket/manager'\n\nmodule.exports = class SocketIoManager extends SocketManager",
            "title": "SocketIoManager"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/manager/#constructor",
            "text": "constructor: ->\n    super\n\n    Promise ?= require 'bluebird'\n\n    config ?= require 'config'\n    errors ?= require 'errors'\n    logging ?= require 'logging'\n\n    socketLogger ?= logging.create file: filename: 'logs/socket.io.log'\n\n    options = config.get 'packageConfig:shrub-socket:manager:options'  Load the adapter.      @_adapter = switch options?.store ? 'redis'\n\n      when 'redis'\n\n        redis = require 'redis'\n\n        require('socket.io-redis')(\n          pubClient: redis.createClient()\n          subClient: redis.createClient()\n        )",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/manager/#socketiomanagerbroadcast",
            "text": "(string)  channel  - The channel to broadcast to.    (string)  event  - The event to broadcast.    (any)  data  - The data to broadcast.    Broadcast data to clients in a room.    broadcast: (channel, event, data) ->\n    @io.in(channel).emit event, data\n    this",
            "title": "SocketIoManager#broadcast"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/manager/#socketiomanagerchannels",
            "text": "(socket)  socket  - A socket.   Get a list of channels a socket is in.    channels: (socket) -> socket.rooms",
            "title": "SocketIoManager#channels"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/manager/#socketiomanagerclients",
            "text": "(string)  channel  - The channel to check.   Get a list of clients in a channel.    clients: (channel) ->\n    self = this\n    new Promise (resolve, reject) ->\n      self.io.in(channel).clients (error, clients) ->\n        return reject error if error?\n        resolve clients",
            "title": "SocketIoManager#clients"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/manager/#socketiomanagerintercom",
            "text": "(string)  channel  - The channel to broadcast to.    (string)  event  - The event to broadcast.    (mixed)  data  - The data to broadcast.    Broadcast data to server sockets in a room.    intercom: (channel, event, data) ->\n    @io.in(channel).intercom event, data\n    this",
            "title": "SocketIoManager#intercom"
        },
        {
            "location": "/source/packages/shrub-socket-socket.io/manager/#socketiomanagerlisten",
            "text": "(HttpServer)  http  - The HTTP server to listen on for connections.   Listen for socket connections coming through the HTTP server.    listen: (http) ->\n\n    options = config.get 'packageConfig:shrub-socket:manager:options'  Set up the socket.io server.      @io = require('socket.io') http.server()  Set the adapter.      @io.adapter @_adapter if @_adapter?  Authorization.      @io.use (socket, next) =>\n\n      socket.request.http = http\n      socket.request.socket = socket  Connect provides this, it will make middleware (like session) not\nchoke and die.        socket.request.originalUrl = socket.request.url  Build a fake response which extends EventEmitter because some connect\nmiddleware (like session) listenes for errors with  on . Even though\nthey're never actually emitted, this will make sure nothing breaks.        res = new class SocketConnectionResponse extends EventEmitter\n        constructor: -> super  Stubs.  TODO : Make these not stubs.          getHeader: -> null\n        write: -> null  Dispatch the authorization middleware.        @_connectionMiddleware.dispatch socket.request, res, (error) ->  If any kind of error was thrown, propagate it.          return next error if error?\n\n        next()  Connection (post-authorization).      @io.on 'connection', (socket) =>  Run the disconnection middleware on socket close.        oncloseProxy = socket.onclose\n      socket.onclose = =>\n        @_disconnectionMiddleware.dispatch socket.request, null, (error) ->\n          socketLogger.error errors.stack error if error?\n\n        oncloseProxy.call socket  Join a '$global' channel.        socket.join '$global', (error) =>\n        return socketLogger.error errors.stack error if error?  Dispatch the connection middleware.          socket.emit 'initialized'",
            "title": "SocketIoManager#listen"
        },
        {
            "location": "/source/packages/shrub-socket/client/dummy/",
            "text": "Dummy socket\n\n\nMock out the socket manager.\n\n\nSocket = require 'shrub-socket/socket'\n\nexports.Manager = class DummySocket extends Socket\n\n  constructor: ($timeout) ->\n    super\n\n    @_$timeout = $timeout\n\n    @_emitMap = {}\n    @_onMap = {}\n\n  catchEmit: (eventName, fn) -> (@_emitMap[eventName] ?= []).push fn\n\n  emit: (eventName, data, done) ->\n    @_$timeout => fn data, done for fn in @_emitMap[eventName] ? []\n\n  on: (eventName, fn) -> (@_onMap[eventName] ?= []).push fn\n\n  stimulateOn: (eventName, data) ->\n    @_$timeout => fn data for fn in @_onMap[eventName] ? []",
            "title": "dummy.coffee"
        },
        {
            "location": "/source/packages/shrub-socket/client/dummy/#dummy-socket",
            "text": "Mock out the socket manager.  Socket = require 'shrub-socket/socket'\n\nexports.Manager = class DummySocket extends Socket\n\n  constructor: ($timeout) ->\n    super\n\n    @_$timeout = $timeout\n\n    @_emitMap = {}\n    @_onMap = {}\n\n  catchEmit: (eventName, fn) -> (@_emitMap[eventName] ?= []).push fn\n\n  emit: (eventName, data, done) ->\n    @_$timeout => fn data, done for fn in @_emitMap[eventName] ? []\n\n  on: (eventName, fn) -> (@_onMap[eventName] ?= []).push fn\n\n  stimulateOn: (eventName, data) ->\n    @_$timeout => fn data for fn in @_onMap[eventName] ? []",
            "title": "Dummy socket"
        },
        {
            "location": "/source/packages/shrub-socket/client/",
            "text": "Socket\n\n\nProvide an Angular service wrapping a real-time socket.\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularService\n\n\n  registrar.registerHook 'shrubAngularService', ->\n\n\n\n\nLoad the manager module.\n\n\n    {Manager} = require config.get 'packageConfig:shrub-socket:manager:module'\n    Manager",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-socket/client/#socket",
            "text": "Provide an Angular service wrapping a real-time socket.  config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularService    registrar.registerHook 'shrubAngularService', ->  Load the manager module.      {Manager} = require config.get 'packageConfig:shrub-socket:manager:module'\n    Manager",
            "title": "Socket"
        },
        {
            "location": "/source/packages/shrub-socket/client/socket/",
            "text": "Abstract Socket\n\n\nmodule.exports = class Socket\n\n  constructor: ->\n\n  disconnect: ->\n\n  emit: (eventName, data, fn) ->\n\n  on: (eventName, fn) ->",
            "title": "socket.coffee"
        },
        {
            "location": "/source/packages/shrub-socket/client/socket/#abstract-socket",
            "text": "module.exports = class Socket\n\n  constructor: ->\n\n  disconnect: ->\n\n  emit: (eventName, data, fn) ->\n\n  on: (eventName, fn) ->",
            "title": "Abstract Socket"
        },
        {
            "location": "/source/packages/shrub-socket/",
            "text": "Socket\n\n\nManage socket connections.\n\n\nconfig = require 'config'\n\n\n\n\nThe socket manager.\n\n\nsocketManager = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubConfigClient\n\n\n  registrar.registerHook 'shrubConfigClient', ->\n\n\n\n\nIf we're doing end-to-end testing, mock out the socket manager.\n\n\n    socketModule = if (config.get 'E2E')?\n\n      'shrub-socket/dummy'\n\n    else\n\n      config.get 'packageConfig:shrub-socket:manager:module'\n\n    manager: module: socketModule\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    label: 'Socket server'\n    middleware: [\n\n      (next) ->\n\n        {manager: httpManager} = require 'shrub-http'\n\n        {Manager} = require config.get 'packageConfig:shrub-socket:manager:module'\n\n\n\n\nSpin up the socket server, and have it listen on the HTTP server.\n\n\n        socketManager = new Manager()\n        socketManager.loadMiddleware()\n        socketManager.listen httpManager()\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n\n\n\nMiddleware stack dispatched for a socket connection.\n\n\n    connectionMiddleware: [\n      'shrub-core'\n      'shrub-http-express/session'\n      'shrub-session'\n      'shrub-user'\n      'shrub-villiany'\n      'shrub-rpc'\n    ]\n\n\n\n\nMiddleware stack dispatched when socket disconnects.\n\n\n    disconnectionMiddleware: []\n\n    manager:\n\n\n\n\nModule implementing the socket manager. Defaults to socket.io.\n\n\n      module: 'shrub-socket-socket.io'\n\n\n\n\nImplements hook \nshrubReplContext\n\n\n  registrar.registerHook 'shrubReplContext', (context) ->\n\n\n\n\nProvide the socketManager to REPL.\n\n\n    context.socketManager = socketManager\n\n\n\n\nmanager\n\n\nGet the socket manager.\n\n\nexports.manager = -> socketManager",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-socket/#socket",
            "text": "Manage socket connections.  config = require 'config'  The socket manager.  socketManager = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubConfigClient    registrar.registerHook 'shrubConfigClient', ->  If we're doing end-to-end testing, mock out the socket manager.      socketModule = if (config.get 'E2E')?\n\n      'shrub-socket/dummy'\n\n    else\n\n      config.get 'packageConfig:shrub-socket:manager:module'\n\n    manager: module: socketModule  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    label: 'Socket server'\n    middleware: [\n\n      (next) ->\n\n        {manager: httpManager} = require 'shrub-http'\n\n        {Manager} = require config.get 'packageConfig:shrub-socket:manager:module'  Spin up the socket server, and have it listen on the HTTP server.          socketManager = new Manager()\n        socketManager.loadMiddleware()\n        socketManager.listen httpManager()\n\n        next()\n\n    ]  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->  Middleware stack dispatched for a socket connection.      connectionMiddleware: [\n      'shrub-core'\n      'shrub-http-express/session'\n      'shrub-session'\n      'shrub-user'\n      'shrub-villiany'\n      'shrub-rpc'\n    ]  Middleware stack dispatched when socket disconnects.      disconnectionMiddleware: []\n\n    manager:  Module implementing the socket manager. Defaults to socket.io.        module: 'shrub-socket-socket.io'  Implements hook  shrubReplContext    registrar.registerHook 'shrubReplContext', (context) ->  Provide the socketManager to REPL.      context.socketManager = socketManager",
            "title": "Socket"
        },
        {
            "location": "/source/packages/shrub-socket/#manager",
            "text": "Get the socket manager.  exports.manager = -> socketManager",
            "title": "manager"
        },
        {
            "location": "/source/packages/shrub-socket/manager/",
            "text": "SocketManager\n\n\n{EventEmitter} = require 'events'\n\n\n\n\nThis class implements an abstract interface to be implemented by a socket\nserver (e.g. \nSocket.io\n).\n\n\nmodule.exports = class SocketManager extends EventEmitter\n\n\n\n\nconstructor\n\n\nCreate the server.\n\n\n  constructor: ->\n\n    super\n\n    @_connectionMiddleware = null\n    @_disconnectionMiddleware = null\n\n\n\n\nSocketManager.AuthorizationFailure\n\n\nMay be thrown from within socket authorization middleware, to denote that\nno real error occurred, but authorization failed.\n\n\n  class @AuthorizationFailure extends Error\n    constructor: (@message) ->\n\n\n\n\nSocketManager#loadMiddleware\n\n\nGather and initialize socket middleware.\n\n\n  loadMiddleware: ->\n\n    middleware = require 'middleware'\n\n\n\n\nInvoke hook \nshrubSocketConnectionMiddleware\n\n\n    @_connectionMiddleware = middleware.fromConfig(\n      'shrub-socket:connectionMiddleware'\n    )\n\n\n\n\nInvoke hook \nshrubSocketDisconnectionMiddleware\n\n\n    @_disconnectionMiddleware = middleware.fromConfig(\n      'shrub-socket:disconnectionMiddleware'\n    )\n\n\n\n\nEnsure any subclass implements these \"pure virtual\" methods.\n\n\n  SocketManager::[method] = (-> throw new ReferenceError(\n    \"SocketManager::#{method} is a pure virtual method!\"\n  )) for method in [\n    'broadcast', 'channels', 'clients', 'intercom', 'listen'\n  ]",
            "title": "manager.coffee"
        },
        {
            "location": "/source/packages/shrub-socket/manager/#socketmanager",
            "text": "{EventEmitter} = require 'events'  This class implements an abstract interface to be implemented by a socket\nserver (e.g.  Socket.io ).  module.exports = class SocketManager extends EventEmitter",
            "title": "SocketManager"
        },
        {
            "location": "/source/packages/shrub-socket/manager/#constructor",
            "text": "Create the server.    constructor: ->\n\n    super\n\n    @_connectionMiddleware = null\n    @_disconnectionMiddleware = null",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-socket/manager/#socketmanagerauthorizationfailure",
            "text": "May be thrown from within socket authorization middleware, to denote that\nno real error occurred, but authorization failed.    class @AuthorizationFailure extends Error\n    constructor: (@message) ->",
            "title": "SocketManager.AuthorizationFailure"
        },
        {
            "location": "/source/packages/shrub-socket/manager/#socketmanagerloadmiddleware",
            "text": "Gather and initialize socket middleware.    loadMiddleware: ->\n\n    middleware = require 'middleware'  Invoke hook  shrubSocketConnectionMiddleware      @_connectionMiddleware = middleware.fromConfig(\n      'shrub-socket:connectionMiddleware'\n    )  Invoke hook  shrubSocketDisconnectionMiddleware      @_disconnectionMiddleware = middleware.fromConfig(\n      'shrub-socket:disconnectionMiddleware'\n    )  Ensure any subclass implements these \"pure virtual\" methods.    SocketManager::[method] = (-> throw new ReferenceError(\n    \"SocketManager::#{method} is a pure virtual method!\"\n  )) for method in [\n    'broadcast', 'channels', 'clients', 'intercom', 'listen'\n  ]",
            "title": "SocketManager#loadMiddleware"
        },
        {
            "location": "/source/packages/shrub-ui/client/attributes/",
            "text": "UI - Attributes\n\n\nGeneralized attribute directive.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    '$compile'\n    ($compile) ->\n\n      directive = {}\n\n      directive.link = (scope, element, attr) ->\n\n        updateAttributes = (attributes, oldAttributes) ->\n          return unless attributes?\n\n\n\n\nCreate a dummy attribute to apply all attributes to, since trying\nto apply then directly to the element is potentially problematic.\n\n\n          dummy = angular.element '<div>'\n\n          for k, v of attributes\n\n            if 'class' is k\n\n              v = [v] unless angular.isArray v\n              dummy.addClass v.join ' '\n\n            else\n\n              dummy.attr k, v\n\n\n\n\nCompile and link child directives.\n\n\n          compileScope = scope.$new true\n          compileScope.attributes = attributes\n          $compile(dummy)(compileScope)\n\n\n\n\nSet everything that ended up on our dummy element to the parent\nelement.\n\n\n          dummy.removeClass 'ng-scope'\n          attr.$set k, dummy.attr k for k of attributes\n\n        scope.$watch attr['shrubUiAttributes'], updateAttributes, true\n\n      directive\n\n  ]",
            "title": "attributes.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/attributes/#ui-attributes",
            "text": "Generalized attribute directive.  exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    '$compile'\n    ($compile) ->\n\n      directive = {}\n\n      directive.link = (scope, element, attr) ->\n\n        updateAttributes = (attributes, oldAttributes) ->\n          return unless attributes?  Create a dummy attribute to apply all attributes to, since trying\nto apply then directly to the element is potentially problematic.            dummy = angular.element '<div>'\n\n          for k, v of attributes\n\n            if 'class' is k\n\n              v = [v] unless angular.isArray v\n              dummy.addClass v.join ' '\n\n            else\n\n              dummy.attr k, v  Compile and link child directives.            compileScope = scope.$new true\n          compileScope.attributes = attributes\n          $compile(dummy)(compileScope)  Set everything that ended up on our dummy element to the parent\nelement.            dummy.removeClass 'ng-scope'\n          attr.$set k, dummy.attr k for k of attributes\n\n        scope.$watch attr['shrubUiAttributes'], updateAttributes, true\n\n      directive\n\n  ]",
            "title": "UI - Attributes"
        },
        {
            "location": "/source/packages/shrub-ui/client/",
            "text": "User Interface\n\n\nUser interface components.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n  registrar.recur [\n    'attributes', 'list', 'markdown', 'menu', 'messages', 'notifications'\n    'window-title'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/#user-interface",
            "text": "User interface components.  exports.pkgmanRegister = (registrar) ->\n\n  registrar.recur [\n    'attributes', 'list', 'markdown', 'menu', 'messages', 'notifications'\n    'window-title'\n  ]",
            "title": "User Interface"
        },
        {
            "location": "/source/packages/shrub-ui/client/list/",
            "text": "UI - List\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularController\n\n\n  registrar.registerHook 'shrubAngularController', -> [\n\n    class ListController\n\n      link: (scope, element, attr) ->\n\n\n\n\nMaintain the full ancestor path for list and item.\n\n\n        scope.$watchGroup(\n          [\n            -> scope.list?.name\n            -> scope.parentAncestorPath\n          ]\n          ->\n\n\n\n\nKeep track of the full ancestor path.\n\n\n            parts = []\n            parts.push scope.parentAncestorPath if scope.parentAncestorPath\n            parts.push scope.list.name if scope.list?.name\n            scope.ancestorPath = parts.join '-'\n\n            element.addClass scope.list.name if scope.list?.name\n        )\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n\n    '$compile', '$timeout'\n    ($compile, $timeout) ->\n\n      directive = {}\n\n      directive.bindToController = true\n\n      directive.candidateKeys = [\n        'list.attributes.id'\n        'list.name'\n        'ancestorPath'\n      ]\n\n\n\n\nPrevent infinite recursion when compiling nested lists.\n\n\n      directive.compile = (cElement) ->\n\n        contents = cElement.contents().remove()\n\n        (scope, lElement, attr, controller) ->\n\n          compiled = $compile contents\n          lElement.append compiled scope\n\n          directive.link arguments...\n\n      directive.scope =\n\n        list: '='\n        parentAncestorPath: '=?'\n\n      directive.template = '''\n\n<li\n  data-ng-repeat=\"item in list.items\"\n\n  data-shrub-ui-list-item\n  data-shrub-ui-attributes=\"item.attributes\"\n  data-item=\"item\"\n  data-parent-ancestor-path=\"parentAncestorPath\"\n></li>\n\n'''\n\n      directive\n\n  ]\n\n  registrar.recur [\n    'item'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/list/#ui-list",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularController    registrar.registerHook 'shrubAngularController', -> [\n\n    class ListController\n\n      link: (scope, element, attr) ->  Maintain the full ancestor path for list and item.          scope.$watchGroup(\n          [\n            -> scope.list?.name\n            -> scope.parentAncestorPath\n          ]\n          ->  Keep track of the full ancestor path.              parts = []\n            parts.push scope.parentAncestorPath if scope.parentAncestorPath\n            parts.push scope.list.name if scope.list?.name\n            scope.ancestorPath = parts.join '-'\n\n            element.addClass scope.list.name if scope.list?.name\n        )\n\n  ]  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n\n    '$compile', '$timeout'\n    ($compile, $timeout) ->\n\n      directive = {}\n\n      directive.bindToController = true\n\n      directive.candidateKeys = [\n        'list.attributes.id'\n        'list.name'\n        'ancestorPath'\n      ]  Prevent infinite recursion when compiling nested lists.        directive.compile = (cElement) ->\n\n        contents = cElement.contents().remove()\n\n        (scope, lElement, attr, controller) ->\n\n          compiled = $compile contents\n          lElement.append compiled scope\n\n          directive.link arguments...\n\n      directive.scope =\n\n        list: '='\n        parentAncestorPath: '=?'\n\n      directive.template = '''\n\n<li\n  data-ng-repeat=\"item in list.items\"\n\n  data-shrub-ui-list-item\n  data-shrub-ui-attributes=\"item.attributes\"\n  data-item=\"item\"\n  data-parent-ancestor-path=\"parentAncestorPath\"\n></li>\n\n'''\n\n      directive\n\n  ]\n\n  registrar.recur [\n    'item'\n  ]",
            "title": "UI - List"
        },
        {
            "location": "/source/packages/shrub-ui/client/list/item/",
            "text": "UI - list item\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularController\n\n\n  registrar.registerHook 'shrubAngularController', -> [\n\n    class ListItemController\n\n      link: (scope, element, attr) ->\n\n        scope.$watch(\n          -> scope.item?.markup\n          ->\n\n            for child in element.children()\n\n\n\n\nChild list?\n\n\n              $child = angular.element child\n              continue if $child.attr('data-shrub-ui-list')?\n\n              $child.remove()\n\n            element.prepend scope.item.markup if scope.item?.markup\n\n        )\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n\n    ->\n\n      directive = {}\n\n      directive.bindToController = true\n\n      directive.candidateKeys = [\n        'ancestorPath'\n      ]\n\n      directive.scope =\n\n        item: '='\n        ancestorPath: '=?'\n\n      directive.template = '''\n\n<ul\n  data-ng-if=\"item.list\"\n  data-shrub-ui-list\n  data-shrub-ui-attributes=\"item.list.attributes\"\n  data-list=\"item.list\"\n  data-parent-ancestor-path=\"ancestorPath\"\n></ul>\n\n'''\n\n      directive\n\n  ]",
            "title": "item.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/list/item/#ui-list-item",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularController    registrar.registerHook 'shrubAngularController', -> [\n\n    class ListItemController\n\n      link: (scope, element, attr) ->\n\n        scope.$watch(\n          -> scope.item?.markup\n          ->\n\n            for child in element.children()  Child list?                $child = angular.element child\n              continue if $child.attr('data-shrub-ui-list')?\n\n              $child.remove()\n\n            element.prepend scope.item.markup if scope.item?.markup\n\n        )\n\n  ]  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n\n    ->\n\n      directive = {}\n\n      directive.bindToController = true\n\n      directive.candidateKeys = [\n        'ancestorPath'\n      ]\n\n      directive.scope =\n\n        item: '='\n        ancestorPath: '=?'\n\n      directive.template = '''\n\n<ul\n  data-ng-if=\"item.list\"\n  data-shrub-ui-list\n  data-shrub-ui-attributes=\"item.list.attributes\"\n  data-list=\"item.list\"\n  data-parent-ancestor-path=\"ancestorPath\"\n></ul>\n\n'''\n\n      directive\n\n  ]",
            "title": "UI - list item"
        },
        {
            "location": "/source/packages/shrub-ui/client/markdown/",
            "text": "UI - Markdown\n\n\nmarked = require 'marked'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularFilter\n\n\n  registrar.registerHook 'shrubAngularFilter', -> ->\n\n    (input, sanitize = true) -> marked input, sanitize: sanitize",
            "title": "markdown.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/markdown/#ui-markdown",
            "text": "marked = require 'marked'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularFilter    registrar.registerHook 'shrubAngularFilter', -> ->\n\n    (input, sanitize = true) -> marked input, sanitize: sanitize",
            "title": "UI - Markdown"
        },
        {
            "location": "/source/packages/shrub-ui/client/menu/",
            "text": "UI - Menu\n\n\nManage menus; essentially recursive lists with an emphasis on navigation.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularController\n\n\n  registrar.registerHook 'shrubAngularController', -> [\n    '$compile', '$location', '$scope'\n    class MenuController\n\n\n\n\nconstructor\n\n\n      constructor: ($compile, $location, $scope) ->\n        self = this\n\n        self.linkMap = {}\n\n        $scope.$watch(\n          -> $scope.menu\n          -> self.rebuildListTree $compile, $scope if $scope.menu?\n          true\n        )\n\n        $scope.$watchGroup(\n          [\n            -> $location.path()\n            -> self.linkMap\n          ]\n          (newValues, oldValues) ->\n\n\n\n\nPaths without the leading slash.\n\n\n            if oldPath = oldValues[0]\n              oldPath = oldPath.substr 1\n\n\n\n\nRemove the active class if we navigated away.\n\n\n              if self.linkMap[oldPath]?[0].attributes?.class?\n                attributes = self.linkMap[oldPath][0].attributes\n                if attributes.class.length\n                  index = attributes.class.indexOf 'active'\n                  attributes.class.splice index, 1\n\n\n\n\nAdd the active class if we navigated to.\n\n\n            newPath = newValues[0].substr 1\n            if self.linkMap[newPath]?\n              attributes = self.linkMap[newPath][0].attributes\n              (attributes.class ?= []).push 'active'\n\n        )\n\n\n\n\nMenuController#rebuildListTree\n\n\nRebuild the list tree from the menu tree.\n\n\n      rebuildListTree: ($compile, $scope) ->\n        self = this\n\n        rebuildBranch = (list, branch) ->\n\n          list.attributes ?= {}\n\n          buildItem = (leaf) ->\n\n            item = angular.copy leaf\n            item.attributes ?= {}\n            item.markup = []\n\n            if leaf.markupBefore?\n              item.markup.push angular.element leaf.markupBefore\n\n            item.markup.push linkElement = angular.element '<a>'\n            linkElement.attr 'data-shrub-ui-attributes', 'attributes'\n            linkElement.attr 'href', leaf.path\n            linkElement.html leaf.label\n\n            compileScope = $scope.$new true\n            compileScope.attributes = leaf.linkAttributes\n\n            $compile(linkElement)(compileScope)\n\n            linkElement.removeAttr 'data-shrub-ui-attributes'\n\n            if leaf.markupAfter?\n              item.markup.push angular.element leaf.markupAfter\n\n            (self.linkMap[leaf.path] ?= []).push item\n\n\n\n\nRecur.\n\n\n            if leaf.list?\n\n              item.list = angular.copy leaf.list\n              rebuildBranch item.list, leaf.list\n\n            item\n\n          list.items = for leaf in branch.items\n            buildItem leaf\n\n          return\n\n        self.linkMap = {}\n        $scope.list = angular.copy $scope.menu\n        rebuildBranch $scope.list, $scope.menu\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n\n    '$compile', '$timeout'\n    ($compile, $timeout) ->\n\n      directive = {}\n\n      directive.bindToController = true\n\n      directive.candidateKeys = [\n        'menu.name'\n      ]\n\n      directive.scope =\n\n        menu: '='\n\n      directive.template = '''\n\n<ul\n  data-shrub-ui-list\n  data-shrub-ui-attributes=\"list.attributes\"\n  data-list=\"list\"\n></ul>\n\n'''\n\n      directive\n\n  ]",
            "title": "menu.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/menu/#ui-menu",
            "text": "Manage menus; essentially recursive lists with an emphasis on navigation.  exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularController    registrar.registerHook 'shrubAngularController', -> [\n    '$compile', '$location', '$scope'\n    class MenuController",
            "title": "UI - Menu"
        },
        {
            "location": "/source/packages/shrub-ui/client/menu/#constructor",
            "text": "constructor: ($compile, $location, $scope) ->\n        self = this\n\n        self.linkMap = {}\n\n        $scope.$watch(\n          -> $scope.menu\n          -> self.rebuildListTree $compile, $scope if $scope.menu?\n          true\n        )\n\n        $scope.$watchGroup(\n          [\n            -> $location.path()\n            -> self.linkMap\n          ]\n          (newValues, oldValues) ->  Paths without the leading slash.              if oldPath = oldValues[0]\n              oldPath = oldPath.substr 1  Remove the active class if we navigated away.                if self.linkMap[oldPath]?[0].attributes?.class?\n                attributes = self.linkMap[oldPath][0].attributes\n                if attributes.class.length\n                  index = attributes.class.indexOf 'active'\n                  attributes.class.splice index, 1  Add the active class if we navigated to.              newPath = newValues[0].substr 1\n            if self.linkMap[newPath]?\n              attributes = self.linkMap[newPath][0].attributes\n              (attributes.class ?= []).push 'active'\n\n        )",
            "title": "constructor"
        },
        {
            "location": "/source/packages/shrub-ui/client/menu/#menucontrollerrebuildlisttree",
            "text": "Rebuild the list tree from the menu tree.        rebuildListTree: ($compile, $scope) ->\n        self = this\n\n        rebuildBranch = (list, branch) ->\n\n          list.attributes ?= {}\n\n          buildItem = (leaf) ->\n\n            item = angular.copy leaf\n            item.attributes ?= {}\n            item.markup = []\n\n            if leaf.markupBefore?\n              item.markup.push angular.element leaf.markupBefore\n\n            item.markup.push linkElement = angular.element '<a>'\n            linkElement.attr 'data-shrub-ui-attributes', 'attributes'\n            linkElement.attr 'href', leaf.path\n            linkElement.html leaf.label\n\n            compileScope = $scope.$new true\n            compileScope.attributes = leaf.linkAttributes\n\n            $compile(linkElement)(compileScope)\n\n            linkElement.removeAttr 'data-shrub-ui-attributes'\n\n            if leaf.markupAfter?\n              item.markup.push angular.element leaf.markupAfter\n\n            (self.linkMap[leaf.path] ?= []).push item  Recur.              if leaf.list?\n\n              item.list = angular.copy leaf.list\n              rebuildBranch item.list, leaf.list\n\n            item\n\n          list.items = for leaf in branch.items\n            buildItem leaf\n\n          return\n\n        self.linkMap = {}\n        $scope.list = angular.copy $scope.menu\n        rebuildBranch $scope.list, $scope.menu\n\n  ]  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n\n    '$compile', '$timeout'\n    ($compile, $timeout) ->\n\n      directive = {}\n\n      directive.bindToController = true\n\n      directive.candidateKeys = [\n        'menu.name'\n      ]\n\n      directive.scope =\n\n        menu: '='\n\n      directive.template = '''\n\n<ul\n  data-shrub-ui-list\n  data-shrub-ui-attributes=\"list.attributes\"\n  data-list=\"list\"\n></ul>\n\n'''\n\n      directive\n\n  ]",
            "title": "MenuController#rebuildListTree"
        },
        {
            "location": "/source/packages/shrub-ui/client/messages/",
            "text": "UI - Messages\n\n\nManage transient UI messages.\n\n\nconfig = require 'config'\nerrors = require 'errors'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    '$timeout', 'shrub-ui/messages'\n    ($timeout, {count, removeTop, top}) ->\n\n      link: (scope, elm, attr) ->\n\n        activeNotification = null\n\n        $notificationWrapper = elm.find '.notification-wrapper'\n\n\n\n\nUser closed the notification.\n\n\n        scope.close = ->\n          $timeout.cancel activeNotification\n          $notificationWrapper.fadeOut '2000', -> scope.$apply ->\n            removeTop()\n\n          return\n\n        scope.$watch(\n          -> top()\n          ->\n\n\n\n\nWhen we get a new notification, make it our active notification.\n\n\n            scope.notification = top()\n            return if count() is 0\n\n\n\n\nFade it in and keep it on the screen for 15 seconds.\n\n\n            $notificationWrapper.fadeIn '2000'\n\n            activeNotification = $timeout(\n              -> scope.close()\n              15000\n            )\n\n        )\n\n      template: '''\n\n<div class=\"notification-wrapper\">\n\n  <div\n    data-ng-show=\"!!notification\"\n    data-ng-class=\"notification.class\"\n    class=\"alert notification fade in\"\n  >\n    <button\n      type=\"button\"\n      class=\"close\"\n      data-ng-click=\"close()\"\n    >&times;</button>\n    <span data-ng-bind-html=\"notification.text\"></span>\n  </div>\n\n</div>\n\n'''\n\n  ]\n\n\n\n\nImplements hook \nshrubRpcCall\n\n\n  registrar.registerHook 'shrubRpcCall', -> [\n    'shrub-ui/messages', 'result'\n    (messages, result) ->\n\n\n\n\nAdd a message with the error text, if any.\n\n\n      result.catch (error) -> messages.add(\n        class: 'alert-danger', text: errors.message error\n      )\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularService\n\n\n  registrar.registerHook 'shrubAngularService', -> [\n    'shrub-socket'\n    (socket) ->\n\n      service = {}\n\n      _messages = []\n\n\n\n\nmessages.add\n\n\nAdd a notification to be displayed.\n\n\n      service.add = (notification) ->\n\n        notification.class ?= 'alert-info'\n\n        _messages.push notification\n\n\n\n\nmessages.addError\n\n\nAdd an error notification to be displayed.\n\n\n      service.addError = (error) -> @add(\n        class: 'alert-danger', text: errors.message error\n      )\n\n\n\n\nmessages.top\n\n\nGet the top notification.\n\n\n      service.top = -> _messages[0]\n\n\n\n\nmessages.removeTop\n\n\nRemove the top notification.\n\n\n      service.removeTop = -> _messages.shift()\n\n\n\n\nmessages.count\n\n\nThe number of messages to show.\n\n\n      service.count = -> _messages.length\n\n\n\n\nAccept messages from the server.\n\n\n      socket.on 'shrub-ui/messages', (data) ->\n        service.add message for message in data.messages\n\n      service\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularAppRun\n\n\n  registrar.registerHook 'shrubAngularAppRun', -> [\n    'shrub-ui/messages'\n    (messages) ->\n\n      errorMessages = config.get 'packageConfig:shrub-ui:errorMessages'\n      for errorMessage in errorMessages ? []\n        messages.addError errors.unserialize errorMessage\n\n      return\n\n  ]",
            "title": "messages.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/messages/#ui-messages",
            "text": "Manage transient UI messages.  config = require 'config'\nerrors = require 'errors'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    '$timeout', 'shrub-ui/messages'\n    ($timeout, {count, removeTop, top}) ->\n\n      link: (scope, elm, attr) ->\n\n        activeNotification = null\n\n        $notificationWrapper = elm.find '.notification-wrapper'  User closed the notification.          scope.close = ->\n          $timeout.cancel activeNotification\n          $notificationWrapper.fadeOut '2000', -> scope.$apply ->\n            removeTop()\n\n          return\n\n        scope.$watch(\n          -> top()\n          ->  When we get a new notification, make it our active notification.              scope.notification = top()\n            return if count() is 0  Fade it in and keep it on the screen for 15 seconds.              $notificationWrapper.fadeIn '2000'\n\n            activeNotification = $timeout(\n              -> scope.close()\n              15000\n            )\n\n        )\n\n      template: '''\n\n<div class=\"notification-wrapper\">\n\n  <div\n    data-ng-show=\"!!notification\"\n    data-ng-class=\"notification.class\"\n    class=\"alert notification fade in\"\n  >\n    <button\n      type=\"button\"\n      class=\"close\"\n      data-ng-click=\"close()\"\n    >&times;</button>\n    <span data-ng-bind-html=\"notification.text\"></span>\n  </div>\n\n</div>\n\n'''\n\n  ]  Implements hook  shrubRpcCall    registrar.registerHook 'shrubRpcCall', -> [\n    'shrub-ui/messages', 'result'\n    (messages, result) ->  Add a message with the error text, if any.        result.catch (error) -> messages.add(\n        class: 'alert-danger', text: errors.message error\n      )\n\n  ]  Implements hook  shrubAngularService    registrar.registerHook 'shrubAngularService', -> [\n    'shrub-socket'\n    (socket) ->\n\n      service = {}\n\n      _messages = []",
            "title": "UI - Messages"
        },
        {
            "location": "/source/packages/shrub-ui/client/messages/#messagesadd",
            "text": "Add a notification to be displayed.        service.add = (notification) ->\n\n        notification.class ?= 'alert-info'\n\n        _messages.push notification",
            "title": "messages.add"
        },
        {
            "location": "/source/packages/shrub-ui/client/messages/#messagesadderror",
            "text": "Add an error notification to be displayed.        service.addError = (error) -> @add(\n        class: 'alert-danger', text: errors.message error\n      )",
            "title": "messages.addError"
        },
        {
            "location": "/source/packages/shrub-ui/client/messages/#messagestop",
            "text": "Get the top notification.        service.top = -> _messages[0]",
            "title": "messages.top"
        },
        {
            "location": "/source/packages/shrub-ui/client/messages/#messagesremovetop",
            "text": "Remove the top notification.        service.removeTop = -> _messages.shift()",
            "title": "messages.removeTop"
        },
        {
            "location": "/source/packages/shrub-ui/client/messages/#messagescount",
            "text": "The number of messages to show.        service.count = -> _messages.length  Accept messages from the server.        socket.on 'shrub-ui/messages', (data) ->\n        service.add message for message in data.messages\n\n      service\n\n  ]  Implements hook  shrubAngularAppRun    registrar.registerHook 'shrubAngularAppRun', -> [\n    'shrub-ui/messages'\n    (messages) ->\n\n      errorMessages = config.get 'packageConfig:shrub-ui:errorMessages'\n      for errorMessage in errorMessages ? []\n        messages.addError errors.unserialize errorMessage\n\n      return\n\n  ]",
            "title": "messages.count"
        },
        {
            "location": "/source/packages/shrub-ui/client/notifications/",
            "text": "UI - Notifications\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-rpc', 'shrub-ui/notifications'\n    (rpc, notifications) ->\n\n      directive = {}\n\n      directive.candidateKeys = [\n        'queueName'\n      ]\n\n      directive.link = (scope, element, attr) ->\n\n\n\n\nPut the queue name into the scope.\n\n\n        scope.queueName = attr.queueName\n        scope.queue = notifications.queue scope.queueName\n\n\n\n\nWhen notifications are akcnowledged.\n\n\n        scope.$on 'shrub.ui.notifications.acknowledged', ->\n          return unless scope.unacknowledged\n\n\n\n\nTell the server.\n\n\n          rpc.call(\n            'shrub-ui/notifications/acknowledged'\n            queue: attr.queueName\n          )\n\n\n\n\nMark client notifications as acknowledged.\n\n\n          for notification in scope.queue.notifications()\n            notification.acknowledged = true\n\n\n\n\nMark the notification as read.\n\n\n        scope.markAsRead = (notification, markedAsRead) ->\n          return if markedAsRead is notification.markedAsRead\n\n          notification.markedAsRead = markedAsRead\n\n          rpc.call(\n            'shrub-ui/notifications/markAsRead'\n            ids: [notification.id]\n            markedAsRead: markedAsRead\n          )\n\n\n\n\nHide the popover when any notification is clicked. Feel free to\ncatch the \nshrub.ui.notification.clicked\n event in your\nshrubSkinLink implementation.\n\n\n        scope.notificationClicked = ($event, notification) ->\n\n          scope.$emit(\n            'shrub.ui.notification.clicked'\n            $event, notification\n          )\n\n\n\n\nSet up default behavior on a click event, and provide the\nderegistration function to any shrubSkinLink consumers.\n\n\n        scope.$deregisterDefaultClickHandler = scope.$on(\n          'shrub.ui.notification.clicked'\n          ($event, $clickEvent, notification) ->\n\n\n\n\nMark the notification as read.\n\n\n            scope.markAsRead notification, true\n        )\n\n\n\n\nKeep track of unread items.\n\n\n        scope.$watch 'queue.notifications()', (notifications) ->\n          unacknowledged = notifications.filter (notification) ->\n            not notification.acknowledged\n\n          scope.unacknowledged = if unacknowledged.length > 0\n            unacknowledged.length\n          else\n            undefined\n        , true\n\n      directive.scope = {}\n\n      directive.template = \"\"\"\n\n<div\n  class=\"notifications-container\"\n>\n\n  <button>\n    !\n    <span\n      class=\"unacknowledged\"\n      data-ng-bind=\"unacknowledged\"\n      data-ng-if=\"unacknowledged > 0\"\n    ></span>\n  </button>\n\n  <div\n    data-ng-hide=\"true\"\n  >\n\n    <div\n      class=\"notifications\"\n      data-ng-class=\"classes\"\n    >\n\n      <ul>\n\n        <li\n          data-ng-if=\"!!queue.notifications().length\"\n          data-ng-repeat=\"notification in queue.notifications()\"\n        >\n          <a\n            data-shrub-ui-notifications-item\n            data-notification=\"notification\"\n            data-ng-href=\"{{notification.path}}\"\n            data-ng-click=\"notificationClicked($event, notification)\"\n          >\n          </a>\n        </li>\n\n        <li\n          data-ng-if=\"!queue.notifications().length\"\n        >\n          <a\n            href=\"javascript:void(0)\"\n          >\n            There's nothing here yet...\n          </a>\n        </li>\n      </ul>\n    </div>\n  </div>\n</div>\n\n\"\"\"\n\n      directive\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularService\n\n\n  registrar.registerHook 'shrubAngularService', -> [\n    '$q', 'shrub-rpc', 'shrub-socket'\n    ($q, rpc, socket) ->\n\n      service = {}\n\n      _queues = {}\n\n\n\n\nnotifications.list\n\n\nGet a queue of notifications.\n\n\n      service.queue = (queue) ->\n        _queues[queue] ?= new NotificationQueue()\n\n\n\n\nnotifications.loadMore\n\n\nLoad more notifications\n\n\n      service.loadMore = (queue, skip) ->\n\n        rpc.call(\n          'shrub-ui/notifications'\n          queue: queue\n          skip: skip\n\n        ).then (notifications) ->\n\n          _queues[queue] ?= new NotificationQueue()\n          _queues[queue].add notifications\n\n\n\n\nAdd in initial notifications from config.\n\n\n      for queue, notifications of config.get(\n        'packageConfig:shrub-ui:notifications'\n      )\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].add notifications\n\n\n\n\nAccept notifications from the server.\n\n\n      socket.on 'shrub-ui/notifications', (data) ->\n        {queue, notifications} = data\n\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].add notifications\n\n\n\n\nRemove notifications.\n\n\n      socket.on 'shrub-ui/notifications/remove', (data) ->\n        {queue, ids} = data\n\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].remove ids\n\n\n\n\nMark notifications as read.\n\n\n      socket.on 'shrub-ui/notifications/markAsRead', (data) ->\n        {queue, ids, markedAsRead} = data\n\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].markAsRead ids, markedAsRead\n\n\n\n\nMark notifications as acknowledged.\n\n\n      socket.on 'shrub-ui/notifications/acknowledged', (data) ->\n        {queue, ids} = data\n\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].markAsAcknowledged ids\n\n      service\n\n  ]\n\n  registrar.recur [\n    'item', 'title'\n  ]\n\nclass NotificationQueue\n\n  constructor: ->\n\n    @_notifications = []\n    @_notificationsIndex = {}\n\n  add: (notifications) ->\n\n    for notification in notifications\n\n      @_notifications.unshift notification\n      @_notificationsIndex[notification.id] = notification\n\n    return\n\n  remove: (ids) ->\n\n    for id in ids\n      continue unless notification = @_notificationsIndex[id]\n\n      index = @_notifications.indexOf notification\n      @_notifications.splice index, 1\n      delete @_notificationsIndex[id]\n\n    return\n\n  notifications: -> @_notifications\n\n  markAsAcknowledged: (ids) ->\n\n    for id in ids\n      continue unless notification = @_notificationsIndex[id]\n\n      notification.acknowledged = true\n\n    return\n\n  markAsRead: (ids, markedAsRead) ->\n\n    for id in ids\n      continue unless notification = @_notificationsIndex[id]\n\n      notification.markedAsRead = markedAsRead\n\n    return",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/notifications/#ui-notifications",
            "text": "config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-rpc', 'shrub-ui/notifications'\n    (rpc, notifications) ->\n\n      directive = {}\n\n      directive.candidateKeys = [\n        'queueName'\n      ]\n\n      directive.link = (scope, element, attr) ->  Put the queue name into the scope.          scope.queueName = attr.queueName\n        scope.queue = notifications.queue scope.queueName  When notifications are akcnowledged.          scope.$on 'shrub.ui.notifications.acknowledged', ->\n          return unless scope.unacknowledged  Tell the server.            rpc.call(\n            'shrub-ui/notifications/acknowledged'\n            queue: attr.queueName\n          )  Mark client notifications as acknowledged.            for notification in scope.queue.notifications()\n            notification.acknowledged = true  Mark the notification as read.          scope.markAsRead = (notification, markedAsRead) ->\n          return if markedAsRead is notification.markedAsRead\n\n          notification.markedAsRead = markedAsRead\n\n          rpc.call(\n            'shrub-ui/notifications/markAsRead'\n            ids: [notification.id]\n            markedAsRead: markedAsRead\n          )  Hide the popover when any notification is clicked. Feel free to\ncatch the  shrub.ui.notification.clicked  event in your\nshrubSkinLink implementation.          scope.notificationClicked = ($event, notification) ->\n\n          scope.$emit(\n            'shrub.ui.notification.clicked'\n            $event, notification\n          )  Set up default behavior on a click event, and provide the\nderegistration function to any shrubSkinLink consumers.          scope.$deregisterDefaultClickHandler = scope.$on(\n          'shrub.ui.notification.clicked'\n          ($event, $clickEvent, notification) ->  Mark the notification as read.              scope.markAsRead notification, true\n        )  Keep track of unread items.          scope.$watch 'queue.notifications()', (notifications) ->\n          unacknowledged = notifications.filter (notification) ->\n            not notification.acknowledged\n\n          scope.unacknowledged = if unacknowledged.length > 0\n            unacknowledged.length\n          else\n            undefined\n        , true\n\n      directive.scope = {}\n\n      directive.template = \"\"\"\n\n<div\n  class=\"notifications-container\"\n>\n\n  <button>\n    !\n    <span\n      class=\"unacknowledged\"\n      data-ng-bind=\"unacknowledged\"\n      data-ng-if=\"unacknowledged > 0\"\n    ></span>\n  </button>\n\n  <div\n    data-ng-hide=\"true\"\n  >\n\n    <div\n      class=\"notifications\"\n      data-ng-class=\"classes\"\n    >\n\n      <ul>\n\n        <li\n          data-ng-if=\"!!queue.notifications().length\"\n          data-ng-repeat=\"notification in queue.notifications()\"\n        >\n          <a\n            data-shrub-ui-notifications-item\n            data-notification=\"notification\"\n            data-ng-href=\"{{notification.path}}\"\n            data-ng-click=\"notificationClicked($event, notification)\"\n          >\n          </a>\n        </li>\n\n        <li\n          data-ng-if=\"!queue.notifications().length\"\n        >\n          <a\n            href=\"javascript:void(0)\"\n          >\n            There's nothing here yet...\n          </a>\n        </li>\n      </ul>\n    </div>\n  </div>\n</div>\n\n\"\"\"\n\n      directive\n\n  ]  Implements hook  shrubAngularService    registrar.registerHook 'shrubAngularService', -> [\n    '$q', 'shrub-rpc', 'shrub-socket'\n    ($q, rpc, socket) ->\n\n      service = {}\n\n      _queues = {}",
            "title": "UI - Notifications"
        },
        {
            "location": "/source/packages/shrub-ui/client/notifications/#notificationslist",
            "text": "Get a queue of notifications.        service.queue = (queue) ->\n        _queues[queue] ?= new NotificationQueue()",
            "title": "notifications.list"
        },
        {
            "location": "/source/packages/shrub-ui/client/notifications/#notificationsloadmore",
            "text": "Load more notifications        service.loadMore = (queue, skip) ->\n\n        rpc.call(\n          'shrub-ui/notifications'\n          queue: queue\n          skip: skip\n\n        ).then (notifications) ->\n\n          _queues[queue] ?= new NotificationQueue()\n          _queues[queue].add notifications  Add in initial notifications from config.        for queue, notifications of config.get(\n        'packageConfig:shrub-ui:notifications'\n      )\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].add notifications  Accept notifications from the server.        socket.on 'shrub-ui/notifications', (data) ->\n        {queue, notifications} = data\n\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].add notifications  Remove notifications.        socket.on 'shrub-ui/notifications/remove', (data) ->\n        {queue, ids} = data\n\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].remove ids  Mark notifications as read.        socket.on 'shrub-ui/notifications/markAsRead', (data) ->\n        {queue, ids, markedAsRead} = data\n\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].markAsRead ids, markedAsRead  Mark notifications as acknowledged.        socket.on 'shrub-ui/notifications/acknowledged', (data) ->\n        {queue, ids} = data\n\n        _queues[queue] ?= new NotificationQueue()\n        _queues[queue].markAsAcknowledged ids\n\n      service\n\n  ]\n\n  registrar.recur [\n    'item', 'title'\n  ]\n\nclass NotificationQueue\n\n  constructor: ->\n\n    @_notifications = []\n    @_notificationsIndex = {}\n\n  add: (notifications) ->\n\n    for notification in notifications\n\n      @_notifications.unshift notification\n      @_notificationsIndex[notification.id] = notification\n\n    return\n\n  remove: (ids) ->\n\n    for id in ids\n      continue unless notification = @_notificationsIndex[id]\n\n      index = @_notifications.indexOf notification\n      @_notifications.splice index, 1\n      delete @_notificationsIndex[id]\n\n    return\n\n  notifications: -> @_notifications\n\n  markAsAcknowledged: (ids) ->\n\n    for id in ids\n      continue unless notification = @_notificationsIndex[id]\n\n      notification.acknowledged = true\n\n    return\n\n  markAsRead: (ids, markedAsRead) ->\n\n    for id in ids\n      continue unless notification = @_notificationsIndex[id]\n\n      notification.markedAsRead = markedAsRead\n\n    return",
            "title": "notifications.loadMore"
        },
        {
            "location": "/source/packages/shrub-ui/client/notifications/item/",
            "text": "UI - Notifications item\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/notifications', 'shrub-rpc'\n    (notifications, rpc) ->\n\n      directive = {}\n\n      directive.candidateKeys = [\n        ['queueName', 'notification.type']\n        'notification.type'\n        'queueName'\n      ]\n\n      directive.link = (scope, element) ->\n\n\n\n\nRemove the notification from the queue.\n\n\n        scope.remove = ($event) ->\n          $event.stopPropagation()\n\n          ids = [scope.notification.id]\n          rpc.call(\n            'shrub-ui/notifications/remove'\n            ids: ids\n          )\n          index = scope.queue.remove ids\n\n\n\n\nToggle the notification's marked-as-read state.\n\n\n        scope.toggleMarkedAsRead = ($event) ->\n          $event.stopPropagation()\n\n          scope.markAsRead(\n            scope.notification, not scope.notification.markedAsRead\n          )\n\n\n\n\nWatch the marked-as-read state and make some changes.\n\n\n        scope.$watch 'notification.markedAsRead', (markedAsRead) ->\n\n          if markedAsRead\n            element.addClass 'marked-as-read'\n            scope.iconClass = 'glyphicon-check'\n            scope.title = 'Mark as unread'\n          else\n            element.removeClass 'marked-as-read'\n            scope.iconClass = 'glyphicon-eye-open'\n            scope.title = 'Mark as read'\n\n      directive.scope = true\n\n      directive.template = '''\n\n<a\n  data-ng-click=\"remove($event)\"\n  data-ng-if=\"notification.mayRemove\"\n>\n  <span\n    class=\"remove glyphicon glyphicon-remove\"\n    tabindex=\"0\"\n    title=\"Remove\"\n  ></span>\n</a>\n\n<a\n  data-ng-click=\"toggleMarkedAsRead($event)\"\n>\n  <span\n    class=\"mark-as-read glyphicon\"\n    data-ng-class=\"iconClass\"\n    tabindex=\"0\"\n    title=\"{{title}}\"\n  ></span>\n</a>\n\n<div\n  data-ng-bind=\"notification.variables | json\"\n></div>\n\n'''\n\n      directive\n\n  ]",
            "title": "item.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/notifications/item/#ui-notifications-item",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/notifications', 'shrub-rpc'\n    (notifications, rpc) ->\n\n      directive = {}\n\n      directive.candidateKeys = [\n        ['queueName', 'notification.type']\n        'notification.type'\n        'queueName'\n      ]\n\n      directive.link = (scope, element) ->  Remove the notification from the queue.          scope.remove = ($event) ->\n          $event.stopPropagation()\n\n          ids = [scope.notification.id]\n          rpc.call(\n            'shrub-ui/notifications/remove'\n            ids: ids\n          )\n          index = scope.queue.remove ids  Toggle the notification's marked-as-read state.          scope.toggleMarkedAsRead = ($event) ->\n          $event.stopPropagation()\n\n          scope.markAsRead(\n            scope.notification, not scope.notification.markedAsRead\n          )  Watch the marked-as-read state and make some changes.          scope.$watch 'notification.markedAsRead', (markedAsRead) ->\n\n          if markedAsRead\n            element.addClass 'marked-as-read'\n            scope.iconClass = 'glyphicon-check'\n            scope.title = 'Mark as unread'\n          else\n            element.removeClass 'marked-as-read'\n            scope.iconClass = 'glyphicon-eye-open'\n            scope.title = 'Mark as read'\n\n      directive.scope = true\n\n      directive.template = '''\n\n<a\n  data-ng-click=\"remove($event)\"\n  data-ng-if=\"notification.mayRemove\"\n>\n  <span\n    class=\"remove glyphicon glyphicon-remove\"\n    tabindex=\"0\"\n    title=\"Remove\"\n  ></span>\n</a>\n\n<a\n  data-ng-click=\"toggleMarkedAsRead($event)\"\n>\n  <span\n    class=\"mark-as-read glyphicon\"\n    data-ng-class=\"iconClass\"\n    tabindex=\"0\"\n    title=\"{{title}}\"\n  ></span>\n</a>\n\n<div\n  data-ng-bind=\"notification.variables | json\"\n></div>\n\n'''\n\n      directive\n\n  ]",
            "title": "UI - Notifications item"
        },
        {
            "location": "/source/packages/shrub-ui/client/notifications/title/",
            "text": "UI - Notifications title\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/notifications', 'shrub-rpc'\n    (notifications, rpc) ->\n\n      directive = {}\n\n      directive.candidateKeys = [\n        'queueName'\n      ]\n\n      directive.link = (scope) ->\n\n        _ = require 'lodash'\n\n        scope.notAlreadyRead = -> _.filter(\n          scope.queue.notifications()\n          (notification) -> not notification.markedAsRead\n        )\n\n\n\n\nMark all notifications as read.\n\n\n        scope.markAllRead = ->\n          notAlreadyRead = @notAlreadyRead()\n\n\n\n\nEarly out if there's nothing to do.\n\n\n          return if notAlreadyRead.length is 0\n\n\n\n\nMark notifications as read, and tell the server.\n\n\n          scope.queue.markAsRead ids = _.map(\n            notAlreadyRead, (notification) -> notification.id\n          )\n\n          rpc.call(\n            'shrub-ui/notifications/markAsRead'\n            ids: ids\n            markedAsRead: true\n\n          )\n\n      directive.scope = true\n\n      directive.template = '''\n\n<a\n  class=\"mark-all-read\"\n  data-ng-click=\"markAllRead()\"\n  data-ng-show=\"notAlreadyRead().length > 0\"\n>Mark all read</a>\n\n<p\n  class=\"title\"\n>Notifications</p>\n\n'''\n\n      directive\n\n  ]",
            "title": "title.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/notifications/title/#ui-notifications-title",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/notifications', 'shrub-rpc'\n    (notifications, rpc) ->\n\n      directive = {}\n\n      directive.candidateKeys = [\n        'queueName'\n      ]\n\n      directive.link = (scope) ->\n\n        _ = require 'lodash'\n\n        scope.notAlreadyRead = -> _.filter(\n          scope.queue.notifications()\n          (notification) -> not notification.markedAsRead\n        )  Mark all notifications as read.          scope.markAllRead = ->\n          notAlreadyRead = @notAlreadyRead()  Early out if there's nothing to do.            return if notAlreadyRead.length is 0  Mark notifications as read, and tell the server.            scope.queue.markAsRead ids = _.map(\n            notAlreadyRead, (notification) -> notification.id\n          )\n\n          rpc.call(\n            'shrub-ui/notifications/markAsRead'\n            ids: ids\n            markedAsRead: true\n\n          )\n\n      directive.scope = true\n\n      directive.template = '''\n\n<a\n  class=\"mark-all-read\"\n  data-ng-click=\"markAllRead()\"\n  data-ng-show=\"notAlreadyRead().length > 0\"\n>Mark all read</a>\n\n<p\n  class=\"title\"\n>Notifications</p>\n\n'''\n\n      directive\n\n  ]",
            "title": "UI - Notifications title"
        },
        {
            "location": "/source/packages/shrub-ui/client/test-unit/",
            "text": "describe 'md', ->\n\n  markdown = null\n\n  beforeEach ->\n\n    inject (shrubUiMarkdownFilter) -> markdown = shrubUiMarkdownFilter\n\n  it 'should be able to parse markdown into HTML', ->\n\n    expect(markdown('Oh, *hello*')).toEqual('<p>Oh, <em>hello</em></p>\\n');\n\n  it 'should sanitize HTML by default', ->\n\n    expect(markdown('Oh, <div>hello</div>')).toEqual('<p>Oh, &lt;div&gt;hello&lt;/div&gt;</p>\\n');\n\n  it 'should allow unsanitized HTML, if requested', ->\n\n    expect(markdown('Oh, <div>hello</div>', false)).toEqual('<p>Oh, <div>hello</div></p>\\n');\n\ndescribe 'messages', ->\n\n  messages = null\n\n  beforeEach ->\n\n    inject [\n      'shrub-ui/messages'\n      (_messages_) -> messages = _messages_\n    ]\n\n  it 'should allow adding and removing messages', ->\n\n    messages.add text: 'Testing'\n    expect(messages.top().text).toBe 'Testing'\n    expect(messages.count()).toBe 1\n\n    messages.removeTop()\n    expect(messages.top()).toBe undefined\n    expect(messages.count()).toBe 0\n\n  it 'should accept message batches from the socket', ->\n\n    inject [\n      '$timeout', 'shrub-socket'\n      ($timeout, socket) ->\n\n        socket.stimulateOn(\n          'shrub-ui/messages'\n          messages: [\n            text: 'Testing'\n          ,\n            text: 'Testing'\n          ,\n            text: 'Testing'\n          ,\n            text: 'Testing'\n          ]\n        )\n\n        $timeout.flush()\n\n        expect(messages.count()).toBe 4\n    ]\n\ndescribe 'title', ->\n\n  windowTitle = null\n\n  beforeEach ->\n\n    inject [\n      'shrub-ui/window-title'\n      (_windowTitle_) -> windowTitle = _windowTitle_\n    ]\n\n  it 'should set window title to page title [separator] site title by default when the page title is set', ->\n\n    windowTitle.setPage 'Home'\n\n    expect(windowTitle.get()).toBe \"#{\n      windowTitle.page()\n    }#{\n      windowTitle.separator()\n    }#{\n      windowTitle.site()\n    }\"\n\n  it 'should allow page title to be set without altering the window title', ->\n\n    windowTitle.setPage 'Home', false\n\n    expect(windowTitle.get()).not.toContain 'Home'",
            "title": "test-unit.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/",
            "text": "UI - Window title\n\n\nManage the window and page titles.\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularController\n\n\n  registrar.registerHook 'shrubAngularController', -> [\n    'shrub-ui/window-title'\n    class WindowTitleController\n\n      constructor: (@windowTitle) ->\n\n      link: (scope, element) ->\n        self = this\n\n        scope.$watch(\n          -> self.windowTitle.get()\n          -> element.text self.windowTitle.get()\n        )\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n\n    ->\n\n      directive = {}\n\n      directive.bindToController = true\n\n      directive.scope = {}\n\n      directive\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularAppRun\n\n\n  registrar.registerHook 'shrubAngularAppRun', -> [\n    '$rootScope', 'shrub-ui/window-title'\n    ($rootScope, windowTitle) ->\n\n\n\n\nSet the site name into the window title.\n\n\n      windowTitle.setSite config.get 'packageConfig:shrub-core:siteName'\n\n      $rootScope.$on '$routeChangeSuccess', (event, route) ->\n\n        windowTitle.setPage route.$$route?.title ? ''\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularService\n\n\n  registrar.registerHook 'shrubAngularService', -> [\n    '$interval'\n    ($interval) ->\n\n      service = {}\n\n      _page = ''\n\n\n\n\nwindowTitle.page\n\n\nGet the page title.\n\n\n      service.page = -> _page\n\n\n\n\nwindowTitle.setPage\n\n\n\n\n\n\n(String) \npage\n - The page title.\n\n\n\n\n\n\n(Boolean) \nsetWindow\n - Update the window title.\n\n\n\n\n\n\nSet the page title.\n\n\n      service.setPage = (page, setWindow = true) ->\n\n        _page = page\n        service.set [_page, _site].join _separator if setWindow\n\n      _separator = ' \u00b7 '\n\n\n\n\nwindowTitle.separator\n\n\nGet the token that separates the window and page titles.\n\n\n      service.separator = -> _separator\n\n\n\n\nwindowTitle.setSeparator\n\n\n\n\n(String) \nseparator\n - The separator.\n\n\n\n\nSet the token that separates the window and page titles.\n\n\n      service.setSeparator = (separator) -> _separator = separator\n\n      _site = ''\n\n\n\n\nwindowTitle.site\n\n\nGet the site name.\n\n\n      service.site = -> _site\n\n\n\n\nwindowTitle.setSite\n\n\n\n\n(String) \nsite\n - The site name.\n\n\n\n\nSet the site name.\n\n\n      service.setSite = (site) -> _site = site\n\n      _window = ''\n\n\n\n\nwindowTitle.get\n\n\nGet the window title.\n\n\n      service.get = -> _windowTitleWrapper _window\n\n\n\n\nwindowTitle.set\n\n\n\n\n(String) \nwindow\n - The window title.\n\n\n\n\nSet the window title.\n\n\n      service.set = (window) -> _window = window\n\n\n\n\nIf you want to make the window/tab title flash for attention, use this\nAPI.\n\n\n      _flashUpWrapper = (text) -> \"\u00af\u00af\u00af#{text.toUpperCase()}\u00af\u00af\u00af\"\n      _flashDownWrapper = (text) -> \"___#{text}___\"\n      _windowTitleWrapper = angular.identity\n\n      flashInProgress = null\n\n\n\n\nwindowTitle.startFlashing\n\n\nStart flashing the window title.\n\n\n      service.startFlashing = ->\n        return if flashInProgress?\n\n        flashInProgress = $interval(\n          ->\n\n            if _windowWrapper is _flashUpWrapper\n              _windowWrapper = _flashDownWrapper\n            else\n              _windowWrapper = _flashUpWrapper\n\n          600\n        )\n\n\n\n\nwindowTitle.stopFlashing\n\n\nStop flashing the window title.\n\n\n      service.stopFlashing = ->\n\n        $interval.cancel flashInProgress if flashInProgress?\n        flashInProgress = null\n\n        _windowWrapper = angular.identity\n\n\n\n\nThe wrappers below handle rendering the window title and flash states.\nThe wrappers are passed in a single argument, the title text. The\nwrapper function returns another string, which is the text after\nwhatever wrapping you'd like to do.\n\n\nwindowTitle.flashDownWrapper\n\n\nGet the transformation function for the 'down' flash.\n\n\n      service.flashDownWrapper = -> _flashDownWrapper\n\n\n\n\nwindowTitle.setFlashDownWrapper\n\n\n\n\n(Function) \nflashDownWrapper\n - Transformation function. Takes the\nwindow\n\n\n\n\ntitle as argument and returns a transformed window title. \nSet the\ntransformation function for the 'down' flash.\n\n\n      service.setFlashDownWrapper = (flashDownWrapper) ->\n        _flashDownWrapper = flashDownWrapper\n\n\n\n\nwindowTitle.flashUpWrapper\n\n\nGet the transformation function for the 'up' flash.\n\n\n      service.flashUpWrapper = -> _flashUpWrapper\n\n\n\n\nwindowTitle.setFlashUpWrapper\n\n\n\n\n(Function) \nflashUpWrapper\n - Transformation function. Takes the\nwindow\n\n\n\n\ntitle as argument and returns a transformed window title. \nSet the\ntransformation function for the 'up' flash.\n\n\n      service.setFlashUpWrapper = (flashUpWrapper) ->\n        _flashUpWrapper = flashUpWrapper\n\n      service\n\n  ]",
            "title": "window-title.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#ui-window-title",
            "text": "Manage the window and page titles.  config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularController    registrar.registerHook 'shrubAngularController', -> [\n    'shrub-ui/window-title'\n    class WindowTitleController\n\n      constructor: (@windowTitle) ->\n\n      link: (scope, element) ->\n        self = this\n\n        scope.$watch(\n          -> self.windowTitle.get()\n          -> element.text self.windowTitle.get()\n        )\n\n  ]  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n\n    ->\n\n      directive = {}\n\n      directive.bindToController = true\n\n      directive.scope = {}\n\n      directive\n\n  ]  Implements hook  shrubAngularAppRun    registrar.registerHook 'shrubAngularAppRun', -> [\n    '$rootScope', 'shrub-ui/window-title'\n    ($rootScope, windowTitle) ->  Set the site name into the window title.        windowTitle.setSite config.get 'packageConfig:shrub-core:siteName'\n\n      $rootScope.$on '$routeChangeSuccess', (event, route) ->\n\n        windowTitle.setPage route.$$route?.title ? ''\n\n  ]  Implements hook  shrubAngularService    registrar.registerHook 'shrubAngularService', -> [\n    '$interval'\n    ($interval) ->\n\n      service = {}\n\n      _page = ''",
            "title": "UI - Window title"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitlepage",
            "text": "Get the page title.        service.page = -> _page",
            "title": "windowTitle.page"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitlesetpage",
            "text": "(String)  page  - The page title.    (Boolean)  setWindow  - Update the window title.    Set the page title.        service.setPage = (page, setWindow = true) ->\n\n        _page = page\n        service.set [_page, _site].join _separator if setWindow\n\n      _separator = ' \u00b7 '",
            "title": "windowTitle.setPage"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitleseparator",
            "text": "Get the token that separates the window and page titles.        service.separator = -> _separator",
            "title": "windowTitle.separator"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitlesetseparator",
            "text": "(String)  separator  - The separator.   Set the token that separates the window and page titles.        service.setSeparator = (separator) -> _separator = separator\n\n      _site = ''",
            "title": "windowTitle.setSeparator"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitlesite",
            "text": "Get the site name.        service.site = -> _site",
            "title": "windowTitle.site"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitlesetsite",
            "text": "(String)  site  - The site name.   Set the site name.        service.setSite = (site) -> _site = site\n\n      _window = ''",
            "title": "windowTitle.setSite"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitleget",
            "text": "Get the window title.        service.get = -> _windowTitleWrapper _window",
            "title": "windowTitle.get"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitleset",
            "text": "(String)  window  - The window title.   Set the window title.        service.set = (window) -> _window = window  If you want to make the window/tab title flash for attention, use this\nAPI.        _flashUpWrapper = (text) -> \"\u00af\u00af\u00af#{text.toUpperCase()}\u00af\u00af\u00af\"\n      _flashDownWrapper = (text) -> \"___#{text}___\"\n      _windowTitleWrapper = angular.identity\n\n      flashInProgress = null",
            "title": "windowTitle.set"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitlestartflashing",
            "text": "Start flashing the window title.        service.startFlashing = ->\n        return if flashInProgress?\n\n        flashInProgress = $interval(\n          ->\n\n            if _windowWrapper is _flashUpWrapper\n              _windowWrapper = _flashDownWrapper\n            else\n              _windowWrapper = _flashUpWrapper\n\n          600\n        )",
            "title": "windowTitle.startFlashing"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitlestopflashing",
            "text": "Stop flashing the window title.        service.stopFlashing = ->\n\n        $interval.cancel flashInProgress if flashInProgress?\n        flashInProgress = null\n\n        _windowWrapper = angular.identity  The wrappers below handle rendering the window title and flash states.\nThe wrappers are passed in a single argument, the title text. The\nwrapper function returns another string, which is the text after\nwhatever wrapping you'd like to do.",
            "title": "windowTitle.stopFlashing"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitleflashdownwrapper",
            "text": "Get the transformation function for the 'down' flash.        service.flashDownWrapper = -> _flashDownWrapper",
            "title": "windowTitle.flashDownWrapper"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitlesetflashdownwrapper",
            "text": "(Function)  flashDownWrapper  - Transformation function. Takes the\nwindow   title as argument and returns a transformed window title.  Set the\ntransformation function for the 'down' flash.        service.setFlashDownWrapper = (flashDownWrapper) ->\n        _flashDownWrapper = flashDownWrapper",
            "title": "windowTitle.setFlashDownWrapper"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitleflashupwrapper",
            "text": "Get the transformation function for the 'up' flash.        service.flashUpWrapper = -> _flashUpWrapper",
            "title": "windowTitle.flashUpWrapper"
        },
        {
            "location": "/source/packages/shrub-ui/client/window-title/#windowtitlesetflashupwrapper",
            "text": "(Function)  flashUpWrapper  - Transformation function. Takes the\nwindow   title as argument and returns a transformed window title.  Set the\ntransformation function for the 'up' flash.        service.setFlashUpWrapper = (flashUpWrapper) ->\n        _flashUpWrapper = flashUpWrapper\n\n      service\n\n  ]",
            "title": "windowTitle.setFlashUpWrapper"
        },
        {
            "location": "/source/packages/shrub-ui/",
            "text": "User Interface\n\n\nerrors = require 'errors'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubConfigClient\n\n\n  registrar.registerHook 'shrubConfigClient', (req) ->\n    config = {}\n\n    if req.session?\n\n      errorMessages = req.session.errorMessages ? []\n      delete req.session.errorMessages\n      config.errorMessages = errorMessages\n\n    return config\n\n  registrar.recur [\n    'notifications'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/#user-interface",
            "text": "errors = require 'errors'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubConfigClient    registrar.registerHook 'shrubConfigClient', (req) ->\n    config = {}\n\n    if req.session?\n\n      errorMessages = req.session.errorMessages ? []\n      delete req.session.errorMessages\n      config.errorMessages = errorMessages\n\n    return config\n\n  registrar.recur [\n    'notifications'\n  ]",
            "title": "User Interface"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/",
            "text": "UI - Notifications\n\n\nPromise = null\n\norm = null\n\nnotificationQueues = {}\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    Promise = require 'bluebird'\n\n    orm = require 'shrub-orm'\n\n\n\n\nImplements hook \nshrubCoreBootstrapMiddleware\n\n\n  registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    pkgman = require 'pkgman'\n\n    label: 'Register notification queues'\n    middleware: [\n\n      (next) ->\n\n\n\n\nInvoke hook \nshrubUiNotificationQueues\n\n\n        for path, queues of pkgman.invoke 'shrubUiNotificationQueues'\n          for name, queue of queues\n            notificationQueues[pkgman.normalizePath name] = queue\n\n        next()\n\n    ]\n\n\n\n\nBroadcast a notification event.\n\n\n  broadcastNotificationsEvent = (req, args) ->\n\n    {manager: socketManager} = require 'shrub-socket'\n\n    {data, event, includeSelf, notifications} = args\n    data ?= {}\n\n\n\n\nBroadcast for each queue.\n\n\n    queueMap = {}\n    for notification in notifications\n      queueMap[notification.queue] ?= []\n      queueMap[notification.queue].push notification.id\n\n    for queueName, ids of queueMap\n      queue = notificationQueues[queueName]\n      channel = queue.channelFromRequest req\n\n      data.ids = ids\n      data.queue = queueName\n\n      if includeSelf\n        socketManager().broadcast channel, event, data\n      else\n        req.socket.broadcast.to(channel).emit event, data\n\n\n\n\nImplements hook \nshrubOrmCollections\n\n\n  registrar.registerHook 'shrubOrmCollections', ->\n\n\n\n\nNotification\n\n\n    Notification =\n\n      attributes:\n\n\n\n\nNotification#acknowledged\n\n\nHas the notification been acknowledged?\n\n\n        acknowledged:\n          type: 'boolean'\n          defaultsTo: false\n\n\n\n\nNotification#markedAsRead\n\n\nHas the notification been read?\n\n\n        markedAsRead:\n          type: 'boolean'\n          defaultsTo: false\n\n\n\n\nNotification#mayRemove\n\n\nMay this notification be removed?\n\n\n        mayRemove:\n          type: 'boolean'\n          defaultsTo: true\n\n\n\n\nNotification#channel\n\n\nWhich channel owns this notification? Built by the queue.\n\n\n        channel: 'string'\n\n\n\n\nNotification#path\n\n\nTo where does this notification link?\n\n\n        path: 'string'\n\n\n\n\nNotification#queue\n\n\nTo which queue does this notification belong?\n\n\n        queue:\n          type: 'string'\n          notEmpty: true\n\n\n\n\nNotification#variables\n\n\nVariables, can be any type.\n\n\n        variables: 'json'\n\n\n\n\nNotification#createFromRequest\n\n\n\n\n\n\n(http.IncomingMessage) \nreq\n - The request object.\n\n\n\n\n\n\n(String) \nqueueName\n - The name of the queue.\n\n\n\n\n\n\n(Object) \nvariables\n - Arbitrary data. Defaults to \n{}\n.\n\n\n\n\n\n\n(String) \npath\n - Path this notification links to. Defaults to\n\n\n\n\n\n\n'javascript:void(0)'\n.\n\n\n\n\n(Boolean) \nmayRemove\n - May this notification be removed from the\nqueue by\n\n\n\n\nthe user? Defaults to \ntrue\n. \nCreate a notification from a request\nobject.\n\n\n      createFromRequest: (req, queueName, variables, path, mayRemove) ->\n\n\n\n\nCheck that the queue is valid.\n\n\n        unless queue = notificationQueues[queueName]\n          return Promise.reject new Error(\n            \"Notification queue `#{queue}' doesn't exist.\"\n          )\n\n\n\n\nDefaults.\n\n\n        mayRemove ?= true\n        path ?= 'javascript:void(0)'\n        variables ?= {}\n\n\n\n\nGet the channel from the request.\n\n\n        return unless (channel = queue.channelFromRequest req)?\n\n\n\n\nCreate the notification.\n\n\n        @create(\n          mayRemove: mayRemove\n          channel: channel\n          path: path\n          queue: queueName\n          variables: variables\n\n        ).then (notification) ->\n          return unless req.socket?\n\n\n\n\nBroadcast to others.\n\n\n          notification.redactFor(req.user).then (notification) ->\n            broadcastNotificationsEvent(\n              req\n              data: notifications: [notification]\n              event: 'shrub-ui/notifications'\n              includeSelf: true\n              notifications: [notification]\n            )\n\n\n\n\nNotification#queueFromRequest\n\n\n\n\n(http.IncomingMessage) \nreq\n - The request object.\n\n\n\n\nGet a queue's notifications from a request.\n\n\n      queueFromRequest: (req) ->\n\n\n\n\nEmpty queue if none was defined.\n\n\n        unless (queue = notificationQueues[req.body.queue])?\n          return Promise.resolve []\n\n        unless (channel = queue.channelFromRequest req)?\n          return Promise.resolve []\n\n\n\n\nReturn the 20 newest notifications from the queue for the request's\nchannel, skipping as many records as requested.\n\n\n        query = @find()\n        query = query.where(channel: channel)\n        query = query.where(queue: req.body.queue)\n        query = query.skip(req.body.skip ? 0)\n        query = query.limit(20)\n        query.sort('createdAt DESC')\n\n\n\n\nRedact the notifications before sending them over the wire.\n\n\n        query.then (notifications) ->\n          Promise.all(\n            notifications.map (notification) ->\n              notification.redactFor req.user\n          )\n\n\n\n\nRemove unnecessary details.\n\n\n      redactors: [(redactFor) ->\n        self = this\n\n        delete self.channel\n        delete self.updatedAt\n\n      ]\n\n    'shrub-ui-notification': Notification\n\n\n\n\nImplements hook \nshrubConfigClient\n\n\n  registrar.registerHook 'shrubConfigClient', (req) ->\n\n\n\n\nMake sure ORM is up (it won't be when grunt is running).\n\n\n    return unless Notification = orm?.collection 'shrub-ui-notification'\n\n\n\n\nGet all the notification queues.\n\n\n    promiseKeys = []\n    promises = for key, queue of notificationQueues\n      promiseKeys.push key\n\n      (req.body ?= {}).queue = key\n      Notification.queueFromRequest req\n\n\n\n\nLoad any queues into the config.\n\n\n    Promise.all(promises).then (notificationsList) ->\n      queuesConfig = null\n\n      for notifications, index in notificationsList\n        continue if notifications.length is 0\n\n\n\n\nReverse the notifications because the client will prepend new\nnotifications, not append.\n\n\n        queuesConfig ?= {}\n        queuesConfig[promiseKeys[index]] = notifications.reverse()\n\n      queuesConfig\n\n\n\n\nEnsure that the requested notification is owned by the request.\n\n\n  ensureNotificationsOwnedByRequest = (req, res, next) ->\n\n    Notification = orm.collection 'shrub-ui-notification'\n    Notification.findById(req.body.ids).then((notifications) ->\n\n      for notification in notifications\n        return next new Error(\n          \"Notification queue `#{notification.queue}' doesn't exist.\"\n        ) unless queue = notificationQueues[notification.queue]\n\n        return next new Error(\n          \"You don't own those notifications.\"\n        ) unless notification.channel is queue.channelFromRequest req\n\n      req.notifications = notifications\n      next()\n\n    ).catch next\n\n\n\n\nImplements hook \nshrubRpcRoutes\n\n\n  registrar.registerHook 'shrubRpcRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-ui/notifications/acknowledged'\n\n      middleware: [\n\n\n\n\nEnsure that the queue exists.\n\n\n        (req, res, next) ->\n          return next new Error(\n            \"Notification queue `#{req.body.queue}' doesn't exist.\"\n          ) unless queue = notificationQueues[req.body.queue]\n\n          req.queue = queue\n          next()\n\n        (req, res, next) ->\n\n\n\n\nMark all notifications in a queue owned by the request as\nacknowledged.\n\n\n          Notification = orm.collection 'shrub-ui-notification'\n          query = Notification.find()\n          query = query.where(channel: req.queue.channelFromRequest req)\n          query = query.where(queue: req.body.queue)\n          query.then((notifications) ->\n\n\n\n\nBroadcast to others.\n\n\n            broadcastNotificationsEvent(\n              req\n              event: 'shrub-ui/notifications/acknowledged'\n              notifications: notifications\n            )\n\n            Promise.all(\n              for notification in notifications\n                notification.acknowledged = true\n                notification.save()\n            )\n\n          ).then(-> res.end()).catch next\n\n      ]\n\n    routes.push\n\n      path: 'shrub-ui/notifications/markAsRead'\n\n      middleware: [\n\n        ensureNotificationsOwnedByRequest\n\n        (req, res, next) ->\n\n\n\n\nBroadcast to others.\n\n\n          broadcastNotificationsEvent(\n            req\n            data: markedAsRead: req.body.markedAsRead\n            event: 'shrub-ui/notifications/markAsRead'\n            notifications: req.notifications\n          )\n\n          Promise.all(\n            for notification in req.notifications\n              notification.markedAsRead = req.body.markedAsRead\n              notification.save()\n\n          ).then(-> res.end()).catch next\n\n      ]\n\n    routes.push\n\n      path: 'shrub-ui/notifications/remove'\n\n      middleware: [\n\n        ensureNotificationsOwnedByRequest\n\n\n\n\nEnsure that the requested notifications may be removed.\n\n\n        (req, res, next) ->\n\n          for notification in req.notifications\n            return next new Error(\n              'Those notifications may not be removed.'\n            ) unless notification.mayRemove\n\n          next()\n\n        (req, res, next) ->\n\n\n\n\nBroadcast to others.\n\n\n          broadcastNotificationsEvent(\n            req\n            event: 'shrub-ui/notifications/remove'\n            notifications: req.notifications\n          )\n\n          Promise.all(\n            for notification in req.notifications\n              notification.destroy()\n\n          ).then(-> res.end()).catch next\n\n      ]\n\n    routes.push\n\n      path: 'shrub-ui/notifications'\n\n      middleware: (req, res, next) ->\n\n        Notification = orm.collection 'shrub-ui-notification'\n        Notification.queueFromRequest(req).then((notifications) ->\n\n          res.end notifications\n\n        ).catch next\n\n    return routes",
            "title": "notifications.coffee"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#ui-notifications",
            "text": "Promise = null\n\norm = null\n\nnotificationQueues = {}\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    Promise = require 'bluebird'\n\n    orm = require 'shrub-orm'  Implements hook  shrubCoreBootstrapMiddleware    registrar.registerHook 'shrubCoreBootstrapMiddleware', ->\n\n    pkgman = require 'pkgman'\n\n    label: 'Register notification queues'\n    middleware: [\n\n      (next) ->  Invoke hook  shrubUiNotificationQueues          for path, queues of pkgman.invoke 'shrubUiNotificationQueues'\n          for name, queue of queues\n            notificationQueues[pkgman.normalizePath name] = queue\n\n        next()\n\n    ]  Broadcast a notification event.    broadcastNotificationsEvent = (req, args) ->\n\n    {manager: socketManager} = require 'shrub-socket'\n\n    {data, event, includeSelf, notifications} = args\n    data ?= {}  Broadcast for each queue.      queueMap = {}\n    for notification in notifications\n      queueMap[notification.queue] ?= []\n      queueMap[notification.queue].push notification.id\n\n    for queueName, ids of queueMap\n      queue = notificationQueues[queueName]\n      channel = queue.channelFromRequest req\n\n      data.ids = ids\n      data.queue = queueName\n\n      if includeSelf\n        socketManager().broadcast channel, event, data\n      else\n        req.socket.broadcast.to(channel).emit event, data  Implements hook  shrubOrmCollections    registrar.registerHook 'shrubOrmCollections', ->",
            "title": "UI - Notifications"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notification",
            "text": "Notification =\n\n      attributes:",
            "title": "Notification"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notificationacknowledged",
            "text": "Has the notification been acknowledged?          acknowledged:\n          type: 'boolean'\n          defaultsTo: false",
            "title": "Notification#acknowledged"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notificationmarkedasread",
            "text": "Has the notification been read?          markedAsRead:\n          type: 'boolean'\n          defaultsTo: false",
            "title": "Notification#markedAsRead"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notificationmayremove",
            "text": "May this notification be removed?          mayRemove:\n          type: 'boolean'\n          defaultsTo: true",
            "title": "Notification#mayRemove"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notificationchannel",
            "text": "Which channel owns this notification? Built by the queue.          channel: 'string'",
            "title": "Notification#channel"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notificationpath",
            "text": "To where does this notification link?          path: 'string'",
            "title": "Notification#path"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notificationqueue",
            "text": "To which queue does this notification belong?          queue:\n          type: 'string'\n          notEmpty: true",
            "title": "Notification#queue"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notificationvariables",
            "text": "Variables, can be any type.          variables: 'json'",
            "title": "Notification#variables"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notificationcreatefromrequest",
            "text": "(http.IncomingMessage)  req  - The request object.    (String)  queueName  - The name of the queue.    (Object)  variables  - Arbitrary data. Defaults to  {} .    (String)  path  - Path this notification links to. Defaults to    'javascript:void(0)' .   (Boolean)  mayRemove  - May this notification be removed from the\nqueue by   the user? Defaults to  true .  Create a notification from a request\nobject.        createFromRequest: (req, queueName, variables, path, mayRemove) ->  Check that the queue is valid.          unless queue = notificationQueues[queueName]\n          return Promise.reject new Error(\n            \"Notification queue `#{queue}' doesn't exist.\"\n          )  Defaults.          mayRemove ?= true\n        path ?= 'javascript:void(0)'\n        variables ?= {}  Get the channel from the request.          return unless (channel = queue.channelFromRequest req)?  Create the notification.          @create(\n          mayRemove: mayRemove\n          channel: channel\n          path: path\n          queue: queueName\n          variables: variables\n\n        ).then (notification) ->\n          return unless req.socket?  Broadcast to others.            notification.redactFor(req.user).then (notification) ->\n            broadcastNotificationsEvent(\n              req\n              data: notifications: [notification]\n              event: 'shrub-ui/notifications'\n              includeSelf: true\n              notifications: [notification]\n            )",
            "title": "Notification#createFromRequest"
        },
        {
            "location": "/source/packages/shrub-ui/notifications/#notificationqueuefromrequest",
            "text": "(http.IncomingMessage)  req  - The request object.   Get a queue's notifications from a request.        queueFromRequest: (req) ->  Empty queue if none was defined.          unless (queue = notificationQueues[req.body.queue])?\n          return Promise.resolve []\n\n        unless (channel = queue.channelFromRequest req)?\n          return Promise.resolve []  Return the 20 newest notifications from the queue for the request's\nchannel, skipping as many records as requested.          query = @find()\n        query = query.where(channel: channel)\n        query = query.where(queue: req.body.queue)\n        query = query.skip(req.body.skip ? 0)\n        query = query.limit(20)\n        query.sort('createdAt DESC')  Redact the notifications before sending them over the wire.          query.then (notifications) ->\n          Promise.all(\n            notifications.map (notification) ->\n              notification.redactFor req.user\n          )  Remove unnecessary details.        redactors: [(redactFor) ->\n        self = this\n\n        delete self.channel\n        delete self.updatedAt\n\n      ]\n\n    'shrub-ui-notification': Notification  Implements hook  shrubConfigClient    registrar.registerHook 'shrubConfigClient', (req) ->  Make sure ORM is up (it won't be when grunt is running).      return unless Notification = orm?.collection 'shrub-ui-notification'  Get all the notification queues.      promiseKeys = []\n    promises = for key, queue of notificationQueues\n      promiseKeys.push key\n\n      (req.body ?= {}).queue = key\n      Notification.queueFromRequest req  Load any queues into the config.      Promise.all(promises).then (notificationsList) ->\n      queuesConfig = null\n\n      for notifications, index in notificationsList\n        continue if notifications.length is 0  Reverse the notifications because the client will prepend new\nnotifications, not append.          queuesConfig ?= {}\n        queuesConfig[promiseKeys[index]] = notifications.reverse()\n\n      queuesConfig  Ensure that the requested notification is owned by the request.    ensureNotificationsOwnedByRequest = (req, res, next) ->\n\n    Notification = orm.collection 'shrub-ui-notification'\n    Notification.findById(req.body.ids).then((notifications) ->\n\n      for notification in notifications\n        return next new Error(\n          \"Notification queue `#{notification.queue}' doesn't exist.\"\n        ) unless queue = notificationQueues[notification.queue]\n\n        return next new Error(\n          \"You don't own those notifications.\"\n        ) unless notification.channel is queue.channelFromRequest req\n\n      req.notifications = notifications\n      next()\n\n    ).catch next  Implements hook  shrubRpcRoutes    registrar.registerHook 'shrubRpcRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-ui/notifications/acknowledged'\n\n      middleware: [  Ensure that the queue exists.          (req, res, next) ->\n          return next new Error(\n            \"Notification queue `#{req.body.queue}' doesn't exist.\"\n          ) unless queue = notificationQueues[req.body.queue]\n\n          req.queue = queue\n          next()\n\n        (req, res, next) ->  Mark all notifications in a queue owned by the request as\nacknowledged.            Notification = orm.collection 'shrub-ui-notification'\n          query = Notification.find()\n          query = query.where(channel: req.queue.channelFromRequest req)\n          query = query.where(queue: req.body.queue)\n          query.then((notifications) ->  Broadcast to others.              broadcastNotificationsEvent(\n              req\n              event: 'shrub-ui/notifications/acknowledged'\n              notifications: notifications\n            )\n\n            Promise.all(\n              for notification in notifications\n                notification.acknowledged = true\n                notification.save()\n            )\n\n          ).then(-> res.end()).catch next\n\n      ]\n\n    routes.push\n\n      path: 'shrub-ui/notifications/markAsRead'\n\n      middleware: [\n\n        ensureNotificationsOwnedByRequest\n\n        (req, res, next) ->  Broadcast to others.            broadcastNotificationsEvent(\n            req\n            data: markedAsRead: req.body.markedAsRead\n            event: 'shrub-ui/notifications/markAsRead'\n            notifications: req.notifications\n          )\n\n          Promise.all(\n            for notification in req.notifications\n              notification.markedAsRead = req.body.markedAsRead\n              notification.save()\n\n          ).then(-> res.end()).catch next\n\n      ]\n\n    routes.push\n\n      path: 'shrub-ui/notifications/remove'\n\n      middleware: [\n\n        ensureNotificationsOwnedByRequest  Ensure that the requested notifications may be removed.          (req, res, next) ->\n\n          for notification in req.notifications\n            return next new Error(\n              'Those notifications may not be removed.'\n            ) unless notification.mayRemove\n\n          next()\n\n        (req, res, next) ->  Broadcast to others.            broadcastNotificationsEvent(\n            req\n            event: 'shrub-ui/notifications/remove'\n            notifications: req.notifications\n          )\n\n          Promise.all(\n            for notification in req.notifications\n              notification.destroy()\n\n          ).then(-> res.end()).catch next\n\n      ]\n\n    routes.push\n\n      path: 'shrub-ui/notifications'\n\n      middleware: (req, res, next) ->\n\n        Notification = orm.collection 'shrub-ui-notification'\n        Notification.queueFromRequest(req).then((notifications) ->\n\n          res.end notifications\n\n        ).catch next\n\n    return routes",
            "title": "Notification#queueFromRequest"
        },
        {
            "location": "/source/packages/shrub-user-local/client/email/forgot/",
            "text": "User - Forgot password email\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/window-title'\n    (windowTitle) ->\n\n      directive = {}\n\n      directive.link = (scope) ->\n\n        windowTitle.setPage 'Forgot password'\n\n        scope.siteName = config.get 'packageConfig:shrub-core:siteName'\n\n      directive.scope = true\n\n      directive.template = '''\n\n<p>\n  Hello, <span\n    data-ng-bind=\"user.name\"\n  ></span>!\n</p>\n\n<p>\n  You (or someone posing as you) issued a password recovery request just now.\n</p>\n\n<p>\n  You may <a\n    data-ng-href=\"{{loginUrl}}\"\n  >visit the one-time login link for your account</a> at <a\n    data-ng-bind=\"loginUrl\"\n    data-ng-href=\"{{loginUrl}}\"\n  ></a> to reset your password!\n</p>\n\n<p>\n  Regards,\n</p>\n\n<p>\n  <a\n    data-ng-bind=\"siteName\"\n    data-ng-href=\"{{siteUrl}}\"\n  ></a>\n</p>\n\n<p>\u2014</p>\n\n<p class=\"muted\">\n  <small>\n    If you received this email by mistake, feel free to ignore it. Have a lovely day!\n  </small>\n</p>\n\n<p class=\"muted\">\n  <small>\n    This is an automatically generated email; <strong\n    >if you reply it may not be read by anyone.</strong>\n  </small>\n</p>\n\n'''\n\n      directive\n\n  ]",
            "title": "forgot.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/client/email/forgot/#user-forgot-password-email",
            "text": "config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/window-title'\n    (windowTitle) ->\n\n      directive = {}\n\n      directive.link = (scope) ->\n\n        windowTitle.setPage 'Forgot password'\n\n        scope.siteName = config.get 'packageConfig:shrub-core:siteName'\n\n      directive.scope = true\n\n      directive.template = '''\n\n<p>\n  Hello, <span\n    data-ng-bind=\"user.name\"\n  ></span>!\n</p>\n\n<p>\n  You (or someone posing as you) issued a password recovery request just now.\n</p>\n\n<p>\n  You may <a\n    data-ng-href=\"{{loginUrl}}\"\n  >visit the one-time login link for your account</a> at <a\n    data-ng-bind=\"loginUrl\"\n    data-ng-href=\"{{loginUrl}}\"\n  ></a> to reset your password!\n</p>\n\n<p>\n  Regards,\n</p>\n\n<p>\n  <a\n    data-ng-bind=\"siteName\"\n    data-ng-href=\"{{siteUrl}}\"\n  ></a>\n</p>\n\n<p>\u2014</p>\n\n<p class=\"muted\">\n  <small>\n    If you received this email by mistake, feel free to ignore it. Have a lovely day!\n  </small>\n</p>\n\n<p class=\"muted\">\n  <small>\n    This is an automatically generated email; <strong\n    >if you reply it may not be read by anyone.</strong>\n  </small>\n</p>\n\n'''\n\n      directive\n\n  ]",
            "title": "User - Forgot password email"
        },
        {
            "location": "/source/packages/shrub-user-local/client/email/",
            "text": "User - email\n\n\nexports.pkgmanRegister = (registrar) ->\n\n  registrar.recur [\n    'forgot', 'register'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/client/email/#user-email",
            "text": "exports.pkgmanRegister = (registrar) ->\n\n  registrar.recur [\n    'forgot', 'register'\n  ]",
            "title": "User - email"
        },
        {
            "location": "/source/packages/shrub-user-local/client/email/register/",
            "text": "User - Register email\n\n\nconfig = require 'config'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/window-title'\n    (windowTitle) ->\n\n      directive = {}\n\n      directive.link = (scope) ->\n\n        windowTitle.setPage 'Registration details'\n\n        scope.siteName = config.get 'packageConfig:shrub-core:siteName'\n\n      directive.scope = true\n\n      directive.template = '''\n\n<p>\n  Hello, <span\n    data-ng-bind=\"user.name\"\n  ></span>!\n</p>\n\n<p>\n  You (or someone using your email address) registered an account with us just now.\n</p>\n\n<p>\n  You may <a\n    data-ng-href=\"{{loginUrl}}\"\n  >visit the login link for your account</a> at <a\n    data-ng-bind=\"loginUrl\"\n    data-ng-href=\"{{loginUrl}}\"\n  >\n  </a> to set your password!\n</p>\n\n<p>\n  Regards,\n</p>\n\n<p>\n  <a\n    data-ng-bind=\"siteName\"\n    data-ng-href=\"{{siteUrl}}\"\n  ></a>\n</p>\n\n<p>\u2014</p>\n\n<p class=\"muted\">\n  <small>\n    If you received this email by mistake, feel free to ignore it. Have a lovely day!\n  </small>\n</p>\n\n<p class=\"muted\">\n  <small>\n    This is an automatically generated email; <strong\n    >if you reply it may not be read by anyone.</strong>\n  </small>\n</p>\n\n'''\n\n      directive\n\n  ]",
            "title": "register.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/client/email/register/#user-register-email",
            "text": "config = require 'config'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularDirective    registrar.registerHook 'shrubAngularDirective', -> [\n    'shrub-ui/window-title'\n    (windowTitle) ->\n\n      directive = {}\n\n      directive.link = (scope) ->\n\n        windowTitle.setPage 'Registration details'\n\n        scope.siteName = config.get 'packageConfig:shrub-core:siteName'\n\n      directive.scope = true\n\n      directive.template = '''\n\n<p>\n  Hello, <span\n    data-ng-bind=\"user.name\"\n  ></span>!\n</p>\n\n<p>\n  You (or someone using your email address) registered an account with us just now.\n</p>\n\n<p>\n  You may <a\n    data-ng-href=\"{{loginUrl}}\"\n  >visit the login link for your account</a> at <a\n    data-ng-bind=\"loginUrl\"\n    data-ng-href=\"{{loginUrl}}\"\n  >\n  </a> to set your password!\n</p>\n\n<p>\n  Regards,\n</p>\n\n<p>\n  <a\n    data-ng-bind=\"siteName\"\n    data-ng-href=\"{{siteUrl}}\"\n  ></a>\n</p>\n\n<p>\u2014</p>\n\n<p class=\"muted\">\n  <small>\n    If you received this email by mistake, feel free to ignore it. Have a lovely day!\n  </small>\n</p>\n\n<p class=\"muted\">\n  <small>\n    This is an automatically generated email; <strong\n    >if you reply it may not be read by anyone.</strong>\n  </small>\n</p>\n\n'''\n\n      directive\n\n  ]",
            "title": "User - Register email"
        },
        {
            "location": "/source/packages/shrub-user-local/client/forgot/",
            "text": "User - Forgot password\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularRoutes\n\n\n  registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/local/forgot'\n      title: 'Forgot password'\n\n      controller: [\n        '$location', '$scope', 'shrub-ui/messages', 'shrub-rpc', 'shrub-user'\n        ($location, $scope, messages, rpc, user) ->\n          return $location.path '/' if user.isLoggedIn()\n\n          $scope.form =\n\n            key: 'shrub-user-local-forgot'\n\n            submits: [\n\n              rpc.formSubmitHandler 'shrub-user/local/forgot', (error, result) ->\n                return if error?\n\n                messages.add(\n                  text: 'A reset link will be emailed.'\n                )\n\n                $location.path '/'\n\n            ]\n\n            fields:\n\n              usernameOrEmail:\n                type: 'text'\n                label: 'Username or Email'\n                required: true\n\n              submit:\n                type: 'submit'\n                value: 'Email reset link'\n\n      ]\n\n      template: '''\n\n<div\n  data-shrub-form\n  data-form=\"form\"\n></div>\n\n'''\n\n    return routes",
            "title": "forgot.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/client/forgot/#user-forgot-password",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularRoutes    registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/local/forgot'\n      title: 'Forgot password'\n\n      controller: [\n        '$location', '$scope', 'shrub-ui/messages', 'shrub-rpc', 'shrub-user'\n        ($location, $scope, messages, rpc, user) ->\n          return $location.path '/' if user.isLoggedIn()\n\n          $scope.form =\n\n            key: 'shrub-user-local-forgot'\n\n            submits: [\n\n              rpc.formSubmitHandler 'shrub-user/local/forgot', (error, result) ->\n                return if error?\n\n                messages.add(\n                  text: 'A reset link will be emailed.'\n                )\n\n                $location.path '/'\n\n            ]\n\n            fields:\n\n              usernameOrEmail:\n                type: 'text'\n                label: 'Username or Email'\n                required: true\n\n              submit:\n                type: 'submit'\n                value: 'Email reset link'\n\n      ]\n\n      template: '''\n\n<div\n  data-shrub-form\n  data-form=\"form\"\n></div>\n\n'''\n\n    return routes",
            "title": "User - Forgot password"
        },
        {
            "location": "/source/packages/shrub-user-local/client/",
            "text": "{TransmittableError} = require 'errors'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubTransmittableErrors\n\n\n  registrar.registerHook 'shrubTransmittableErrors', exports.shrubTransmittableErrors\n\n\n\n\nImplements hook \nshrubUserLoginStrategies\n\n\n  registrar.registerHook 'shrubUserLoginStrategies', ->\n\n    exports.shrubUserLoginStrategies()\n\n  registrar.recur [\n    'email', 'forgot', 'register', 'reset'\n  ]\n\nexports.shrubUserLoginStrategies = ->\n\n  methodLabel: 'Local'\n\n  fields:\n\n    username:\n      type: 'text'\n      label: 'Username'\n      required: true\n\n    password:\n      type: 'password'\n      label: 'Password'\n      required: true\n\n    submit:\n      type: 'submit'\n      value: 'Sign in'\n\n    forgot:\n      type: 'markup'\n      value: '<a class=\"forgot\" href=\"/user/local/forgot\">Forgot your password?</a>'\n\nexports.shrubOrmCollections = ->\n\n  UserLocal =\n\n    attributes:\n\n\n\n\nEmail address.\n\n\n      email:\n        type: 'string'\n        index: true\n\n\n\n\nName.\n\n\n      name:\n        type: 'string'\n        size: 24\n        maxLength: 24\n\n  'shrub-user-local': UserLocal\n\n\n\n\nTransmittable login error.\n\n\nclass LoginError extends TransmittableError\n\n  errorType: 'shrub-user-local-login'\n  template: 'No such username/password.'\n\nexports.shrubTransmittableErrors = -> [\n  LoginError\n]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/client/register/",
            "text": "User - Register\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularRoutes\n\n\n  registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/local/register'\n      title: 'Sign up'\n\n      controller: [\n        '$location', '$scope', 'shrub-ui/messages', 'shrub-rpc', 'shrub-user'\n        ($location, $scope, messages, rpc, user) ->\n          return $location.path '/' if user.isLoggedIn()\n\n          $scope.form =\n\n            key: 'shrub-user-local-register'\n\n            submits: [\n\n              rpc.formSubmitHandler 'shrub-user/local/register', (error, result) ->\n                return if error?\n\n                messages.add(\n                  text: 'An email has been sent with account registration details. Please check your email.'\n                )\n\n                $location.path '/'\n\n            ]\n\n            fields:\n\n              username:\n                type: 'text'\n                label: 'Username'\n                required: true\n\n              email:\n                type: 'email'\n                label: 'Email'\n                required: true\n\n              submit:\n                type: 'submit'\n                value: 'Sign up'\n\n      ]\n\n      template: '''\n\n<div\n  data-shrub-form\n  data-form=\"form\"\n></div>\n\n'''\n\n    return routes",
            "title": "register.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/client/register/#user-register",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularRoutes    registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/local/register'\n      title: 'Sign up'\n\n      controller: [\n        '$location', '$scope', 'shrub-ui/messages', 'shrub-rpc', 'shrub-user'\n        ($location, $scope, messages, rpc, user) ->\n          return $location.path '/' if user.isLoggedIn()\n\n          $scope.form =\n\n            key: 'shrub-user-local-register'\n\n            submits: [\n\n              rpc.formSubmitHandler 'shrub-user/local/register', (error, result) ->\n                return if error?\n\n                messages.add(\n                  text: 'An email has been sent with account registration details. Please check your email.'\n                )\n\n                $location.path '/'\n\n            ]\n\n            fields:\n\n              username:\n                type: 'text'\n                label: 'Username'\n                required: true\n\n              email:\n                type: 'email'\n                label: 'Email'\n                required: true\n\n              submit:\n                type: 'submit'\n                value: 'Sign up'\n\n      ]\n\n      template: '''\n\n<div\n  data-shrub-form\n  data-form=\"form\"\n></div>\n\n'''\n\n    return routes",
            "title": "User - Register"
        },
        {
            "location": "/source/packages/shrub-user-local/client/reset/",
            "text": "User - Reset password\n\n\nerrors = require 'errors'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularRoutes\n\n\n  registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/local/reset/:token'\n      title: 'Reset your password'\n\n      controller: [\n        '$location', '$routeParams', '$scope', 'shrub-ui/messages', 'shrub-rpc'\n        ($location, $routeParams, $scope, messages, rpc) ->\n\n          $scope.form =\n\n            key: 'shrub-user-local-reset'\n\n            submits: [\n\n              rpc.formSubmitHandler 'shrub-user/local/reset', (error, result) ->\n                return if error?\n\n                messages.add(\n                  text: 'You may now log in with your new password.'\n                )\n\n                $location.path '/user/login'\n\n            ]\n\n            fields:\n\n              password:\n                type: 'password'\n                label: 'New password'\n                required: true\n\n              token:\n                type: 'hidden'\n                value: $routeParams.token\n\n              submit:\n                type: 'submit'\n                value: 'Reset password'\n\n      ]\n\n      template: '''\n\n<div\n  data-shrub-form\n  data-form=\"form\"\n></div>\n\n'''\n\n    return routes",
            "title": "reset.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/client/reset/#user-reset-password",
            "text": "errors = require 'errors'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularRoutes    registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/local/reset/:token'\n      title: 'Reset your password'\n\n      controller: [\n        '$location', '$routeParams', '$scope', 'shrub-ui/messages', 'shrub-rpc'\n        ($location, $routeParams, $scope, messages, rpc) ->\n\n          $scope.form =\n\n            key: 'shrub-user-local-reset'\n\n            submits: [\n\n              rpc.formSubmitHandler 'shrub-user/local/reset', (error, result) ->\n                return if error?\n\n                messages.add(\n                  text: 'You may now log in with your new password.'\n                )\n\n                $location.path '/user/login'\n\n            ]\n\n            fields:\n\n              password:\n                type: 'password'\n                label: 'New password'\n                required: true\n\n              token:\n                type: 'hidden'\n                value: $routeParams.token\n\n              submit:\n                type: 'submit'\n                value: 'Reset password'\n\n      ]\n\n      template: '''\n\n<div\n  data-shrub-form\n  data-form=\"form\"\n></div>\n\n'''\n\n    return routes",
            "title": "User - Reset password"
        },
        {
            "location": "/source/packages/shrub-user-local/client/test-e2e/",
            "text": "describe 'user', ->\n\n  it 'should show a password reset page, but only if a token is provided', ->\n\n    browser.get '/user/local/reset'\n    expect(shrub.count '.shrub-user-local-reset').toBe 0\n\n    browser.get '/user/local/reset/token'\n    expect(shrub.count '.shrub-user-local-reset').toBe 1",
            "title": "test-e2e.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/client/test-unit/",
            "text": "describe 'user', ->\n\n  user = null\n\n  beforeEach ->\n\n    inject [\n      'shrub-user'\n      (_user_) -> user = _user_\n    ]\n\n  it 'should provide an anonymous user by default', ->\n\n    expect(user.instance().id?).toBe false\n\n  it 'should log in a user through RPC', ->\n\n    inject [\n      '$rootScope', '$timeout', 'shrub-socket'\n      ($rootScope, $timeout, socket) ->\n\n        socket.catchEmit 'shrub-rpc', ({path, data}, fn) ->\n          return unless 'shrub-user/login' is path\n\n          fn result: id: 1, name: 'cha0s'\n\n        user.login(\n          method: 'shrub-user-local'\n          username: 'cha0s'\n          password: 'password'\n        )\n\n        $timeout.flush()\n\n        expect(user.isLoggedIn()).toBe true\n\n    ]\n\n  it 'should log out a user through RPC', ->\n\n    inject [\n      '$rootScope', '$timeout', 'shrub-socket'\n      ($rootScope, $timeout, socket) ->\n\n        socket.catchEmit 'shrub-rpc', ({path, data}, fn) ->\n          return unless 'shrub-user/login' is path\n\n          fn result: id: 1, name: 'cha0s'\n\n        socket.catchEmit 'shrub-rpc', ({path, data}, fn) ->\n          return unless 'shrub-user/logout' is path\n\n          fn result: null\n\n        (user.login 'local', 'cha0s', 'password').then -> user.logout()\n\n        $timeout.flush()\n\n        expect(user.isLoggedIn()).toBe false\n\n    ]",
            "title": "test-unit.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/forgot/",
            "text": "User - Forgot password\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubRpcRoutes\n\n\n  registrar.registerHook 'shrubRpcRoutes', ->\n\n    Promise = require 'bluebird'\n\n    config = require 'config'\n\n    nodemailer = require 'shrub-nodemailer'\n    orm = require 'shrub-orm'\n\n    crypto = require 'server/crypto'\n\n    {Limiter, LimiterMiddleware} = require 'shrub-limiter'\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-user/local/forgot'\n\n      middleware: [\n\n        'shrub-http-express/session'\n        'shrub-villiany'\n\n        new LimiterMiddleware(\n          threshold: Limiter.threshold(1).every(30).seconds()\n        )\n\n        (req, res, next) ->\n\n\n\n\nCancel promise flow if the user doesn't exist.\n\n\n          class NoSuchUser extends Error\n            constructor: (@message) ->\n\n\n\n\nLook up the user.\n\n\n          Promise.resolve().then(->\n\n\n\n\nSearch for username or encrypted email.\n\n\n            if -1 is req.body.usernameOrEmail.indexOf '@'\n\n              iname: req.body.usernameOrEmail.toLowerCase()\n\n            else\n\n              crypto.encrypt(\n                req.body.usernameOrEmail.toLowerCase()\n\n              ).then (encryptedEmail) -> email: encryptedEmail\n\n          ).then((filter) ->\n\n\n\n\nFind the local user.\n\n\n            orm.collection('shrub-user-local').findOne filter\n\n          ).then((@localUser) ->\n            throw new NoSuchUser unless @localUser?\n\n\n\n\nGenerate a one-time login token.\n\n\n            crypto.randomBytes 24\n\n          ).then((token) ->\n\n            @localUser.resetPasswordToken = token.toString 'hex'\n\n\n\n\nDecrypt the user's email address.\n\n\n            crypto.decrypt @localUser.email\n\n          ).then((email) ->\n\n\n\n\nSend an email to the user's email with a one-time login link.\n\n\n            siteHostname = config.get 'packageConfig:shrub-core:siteHostname'\n            siteUrl = \"http://#{siteHostname}\"\n\n            scope =\n\n              email: email\n\n\n\n\nTODO: HTTPS\n\n\n              loginUrl: \"#{siteUrl}/user/reset/#{localUser.resetPasswordToken}\"\n\n              siteUrl: siteUrl\n\n              user: @localUser\n\n            nodemailer.sendMail(\n              'shrub-user-local-email-forgot'\n            ,\n              to: email\n              subject: 'Password recovery request'\n            ,\n              scope\n            )\n\n            @localUser.save()\n\n          ).then(-> res.end()).catch(NoSuchUser, -> res.end()).catch next\n\n      ]\n\n    return routes",
            "title": "forgot.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/forgot/#user-forgot-password",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubRpcRoutes    registrar.registerHook 'shrubRpcRoutes', ->\n\n    Promise = require 'bluebird'\n\n    config = require 'config'\n\n    nodemailer = require 'shrub-nodemailer'\n    orm = require 'shrub-orm'\n\n    crypto = require 'server/crypto'\n\n    {Limiter, LimiterMiddleware} = require 'shrub-limiter'\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-user/local/forgot'\n\n      middleware: [\n\n        'shrub-http-express/session'\n        'shrub-villiany'\n\n        new LimiterMiddleware(\n          threshold: Limiter.threshold(1).every(30).seconds()\n        )\n\n        (req, res, next) ->  Cancel promise flow if the user doesn't exist.            class NoSuchUser extends Error\n            constructor: (@message) ->  Look up the user.            Promise.resolve().then(->  Search for username or encrypted email.              if -1 is req.body.usernameOrEmail.indexOf '@'\n\n              iname: req.body.usernameOrEmail.toLowerCase()\n\n            else\n\n              crypto.encrypt(\n                req.body.usernameOrEmail.toLowerCase()\n\n              ).then (encryptedEmail) -> email: encryptedEmail\n\n          ).then((filter) ->  Find the local user.              orm.collection('shrub-user-local').findOne filter\n\n          ).then((@localUser) ->\n            throw new NoSuchUser unless @localUser?  Generate a one-time login token.              crypto.randomBytes 24\n\n          ).then((token) ->\n\n            @localUser.resetPasswordToken = token.toString 'hex'  Decrypt the user's email address.              crypto.decrypt @localUser.email\n\n          ).then((email) ->  Send an email to the user's email with a one-time login link.              siteHostname = config.get 'packageConfig:shrub-core:siteHostname'\n            siteUrl = \"http://#{siteHostname}\"\n\n            scope =\n\n              email: email  TODO: HTTPS                loginUrl: \"#{siteUrl}/user/reset/#{localUser.resetPasswordToken}\"\n\n              siteUrl: siteUrl\n\n              user: @localUser\n\n            nodemailer.sendMail(\n              'shrub-user-local-email-forgot'\n            ,\n              to: email\n              subject: 'Password recovery request'\n            ,\n              scope\n            )\n\n            @localUser.save()\n\n          ).then(-> res.end()).catch(NoSuchUser, -> res.end()).catch next\n\n      ]\n\n    return routes",
            "title": "User - Forgot password"
        },
        {
            "location": "/source/packages/shrub-user-local/",
            "text": "Local user authentication.\n\n\norm = null\nPromise = null\n\nclientModule = require './client'\n\n\n\n\nORM collection and passport strategy for local authentication.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    orm = require 'shrub-orm'\n    Promise = require 'bluebird'\n\n\n\n\nImplements hook \nshrubUserLoginStrategies\n\n\n  registrar.registerHook 'shrubUserLoginStrategies', ->\n    strategy = clientModule.shrubUserLoginStrategies()\n\n    LocalStrategy = require('passport-local').Strategy\n    UserLocal = orm.collection 'shrub-user-local'\n\n\n\n\nImplement a local passport strategy.\n\n\n    options = passReqToCallback: true\n\n    verifyCallback = (req, username, password, done) ->\n\n      crypto = require 'server/crypto'\n      errors = require 'errors'\n\n\n\n\nFind a local user and compare the hashed password.\n\n\n      Promise.cast(\n        UserLocal.findOne iname: username\n      ).bind({}).then((@localUser) ->\n\n\n\n\nNot found? Generic login error.\n\n\n        throw errors.instantiate 'shrub-user-local-login' unless @localUser\n\n\n\n\nTODO: Any way to automate this?\n\n\n        @localUser.model = 'shrub-user-local'\n\n\n\n\nHash the input password for comparison.\n\n\n        crypto.hasher(\n          plaintext: password\n          salt: new Buffer @localUser.salt, 'hex'\n        )\n\n      ).then((hashed) ->\n\n\n\n\nHash mismatch (wrong password)? Generic login error.\n\n\n        throw errors.instantiate(\n          'shrub-user-local-login'\n        ) if @localUser.passwordHash isnt hashed.key.toString 'hex'\n\n\n\n\nReturn the local user instance.\n\n\n        return @localUser\n\n      ).nodeify done\n\n\n\n\nImplement a \nPassport\n login strategy.\n\n\n    passportStrategy = new LocalStrategy options, verifyCallback\n    passportStrategy.name = 'shrub-user-local'\n    strategy.passportStrategy = passportStrategy\n\n    return strategy\n\n\n\n\nImplements hook \nshrubUserRedactors\n\n\n  registrar.registerHook 'shrubUserRedactors', ->\n\n    'shrub-user-local': [\n\n      (object, user) ->\n\n        redacted =\n          model: object.model\n          createdAt: object.createdAt\n          updatedAt: object.updatedAt\n          name: object.name\n\n\n\n\nDifferent user means full email redaction.\n\n\n        return redacted if user.id isnt object.user\n\n\n\n\nDecrypt the e-mail if redacting for the same user.\n\n\n        require('server/crypto').decrypt(object.email).then (email) ->\n          redacted.email = email\n          return redacted\n\n    ]\n\n\n\n\nImplements hook \nshrubOrmCollections\n\n\n  registrar.registerHook 'shrubOrmCollections', ->\n\n    crypto = require 'server/crypto'\n\n\n\n\nInvoke the client hook implementation.\n\n\n    collections = clientModule.shrubOrmCollections()\n\n    {\n      'shrub-user-local': UserLocal\n    } = collections\n\n\n\n\nStore case-insensitive name.\n\n\n    autoIname = (values, cb) ->\n      values.iname = values.name.toLowerCase()\n      cb()\n\n    UserLocal.beforeCreate = autoIname\n    UserLocal.beforeUpdate = autoIname\n\n\n\n\nCase-insensitive name.\n\n\n    UserLocal.attributes.iname =\n      type: 'string'\n      size: 24\n      index: true\n\n\n\n\nHash of the plaintext password.\n\n\n    UserLocal.attributes.passwordHash =\n      type: 'string'\n\n\n\n\nA token which can be used to reset the user's password (once).\n\n\n    UserLocal.attributes.resetPasswordToken =\n      type: 'string'\n      size: 48\n      index: true\n\n\n\n\nA 512-bit salt used to cryptographically hash the user's password.\n\n\n    UserLocal.attributes.salt =\n      type: 'string'\n      size: 128\n\n\n\n\nUserLocal#associatedUser\n\n\nTODO: This should be in a superclass.\n\n\nGet the user (if any) associated with this instance.\n\n\n    UserLocal.attributes.associatedUser = ->\n      {\n        'shrub-user-instance': UserInstance\n        'shrub-user': User\n      } = orm.collections()\n\n      UserInstance.findOne(\n        model: 'shrub-user-local'\n        modelId: @id\n      ).then (userInstance) -> User.findOnePopulated id: userInstance?.user\n\n\n\n\nUserLocal.register\n\n\n\n\n\n\n(string) \nname\n - Name of the new user.\n\n\n\n\n\n\n(string) \nemail\n - Email address of the new user.\n\n\n\n\n\n\n(string) \npassword\n - The new user's password.\n\n\n\n\n\n\nRegister a user in the system.\n\n\n    UserLocal.register = (name, email, password) ->\n\n      @create(name: name).then((localUser) ->\n\n\n\n\nEncrypt the email.\n\n\n        crypto.encrypt(email.toLowerCase()).then((encryptedEmail) ->\n\n          localUser.email = encryptedEmail\n\n\n\n\nSet the password encryption details.\n\n\n          crypto.hasher plaintext: password\n\n        ).then((hashed) ->\n\n          localUser.plaintext = hashed.plaintext\n          localUser.salt = hashed.salt.toString 'hex'\n          localUser.passwordHash = hashed.key.toString 'hex'\n\n\n\n\nGenerate a one-time login token.\n\n\n          crypto.randomBytes 24\n\n        ).then((token) ->\n\n          localUser.resetPasswordToken = token.toString 'hex'\n          localUser.save()\n\n        ).then -> return localUser\n      )\n\n    collections\n\n\n\n\nImplements hook \nshrubTransmittableErrors\n\n\n  registrar.registerHook 'shrubTransmittableErrors', clientModule.shrubTransmittableErrors\n\n  registrar.recur [\n    'forgot', 'register', 'reset'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/#userlocalassociateduser",
            "text": "TODO: This should be in a superclass.  Get the user (if any) associated with this instance.      UserLocal.attributes.associatedUser = ->\n      {\n        'shrub-user-instance': UserInstance\n        'shrub-user': User\n      } = orm.collections()\n\n      UserInstance.findOne(\n        model: 'shrub-user-local'\n        modelId: @id\n      ).then (userInstance) -> User.findOnePopulated id: userInstance?.user",
            "title": "UserLocal#associatedUser"
        },
        {
            "location": "/source/packages/shrub-user-local/#userlocalregister",
            "text": "(string)  name  - Name of the new user.    (string)  email  - Email address of the new user.    (string)  password  - The new user's password.    Register a user in the system.      UserLocal.register = (name, email, password) ->\n\n      @create(name: name).then((localUser) ->  Encrypt the email.          crypto.encrypt(email.toLowerCase()).then((encryptedEmail) ->\n\n          localUser.email = encryptedEmail  Set the password encryption details.            crypto.hasher plaintext: password\n\n        ).then((hashed) ->\n\n          localUser.plaintext = hashed.plaintext\n          localUser.salt = hashed.salt.toString 'hex'\n          localUser.passwordHash = hashed.key.toString 'hex'  Generate a one-time login token.            crypto.randomBytes 24\n\n        ).then((token) ->\n\n          localUser.resetPasswordToken = token.toString 'hex'\n          localUser.save()\n\n        ).then -> return localUser\n      )\n\n    collections  Implements hook  shrubTransmittableErrors    registrar.registerHook 'shrubTransmittableErrors', clientModule.shrubTransmittableErrors\n\n  registrar.recur [\n    'forgot', 'register', 'reset'\n  ]",
            "title": "UserLocal.register"
        },
        {
            "location": "/source/packages/shrub-user-local/register/",
            "text": "User - Registration\n\n\norm = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    orm = require 'shrub-orm'\n\n\n\n\nImplements hook \nshrubRpcRoutes\n\n\n  registrar.registerHook 'shrubRpcRoutes', ->\n\n    config = require 'config'\n\n    nodemailer = require 'shrub-nodemailer'\n\n    {Limiter, LimiterMiddleware} = require 'shrub-limiter'\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-user/local/register'\n\n      middleware: [\n\n        'shrub-http-express/session'\n        'shrub-villiany'\n\n        new LimiterMiddleware(\n          message: 'You are trying to register too much.'\n          threshold: Limiter.threshold(5).every(2).minutes()\n        )\n\n        (req, res, next) ->\n\n          {body} = req\n          {email, password, username} = body\n\n          {\n            'shrub-ui-notification': Notification\n            'shrub-user-local': UserLocal\n          } = orm.collections()\n\n\n\n\nRegister a new user.\n\n\n          UserLocal.register(username, email, password).then((localUser) ->\n\n\n\n\nSend an email to the new user's email with a one-time login\nlink.\n\n\n            siteHostname = config.get 'packageConfig:shrub-core:siteHostname'\n            siteUrl = \"http://#{siteHostname}\"\n\n            scope =\n\n              email: email\n\n\n\n\nTODO: HTTPS\n\n\n              loginUrl: \"#{siteUrl}/user/reset/#{user.resetPasswordToken}\"\n\n              siteUrl: siteUrl\n\n              user: localUser\n\n            Notification.createFromRequest(\n              req, 'shrubExampleGeneral'\n              type: 'register'\n              name: localUser.name\n              email: email\n            ).done()\n\n            nodemailer.sendMail(\n              'shrub-user-local-email-register'\n            ,\n              to: email\n              subject: 'Registration details'\n            ,\n              scope\n            ).done()\n\n            return\n\n          ).then(-> res.end()).catch next\n      ]\n\n    return routes\n\n\n\n\nImplements hook \nshrubReplContext\n\n\n    registrar.registerHook 'shrubReplContext', (context) ->\n      orm = require 'shrub-orm'\n      User = orm.collection 'shrub-user'\n      context.registerUser = -> User.register arguments...",
            "title": "register.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/register/#user-registration",
            "text": "orm = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    orm = require 'shrub-orm'  Implements hook  shrubRpcRoutes    registrar.registerHook 'shrubRpcRoutes', ->\n\n    config = require 'config'\n\n    nodemailer = require 'shrub-nodemailer'\n\n    {Limiter, LimiterMiddleware} = require 'shrub-limiter'\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-user/local/register'\n\n      middleware: [\n\n        'shrub-http-express/session'\n        'shrub-villiany'\n\n        new LimiterMiddleware(\n          message: 'You are trying to register too much.'\n          threshold: Limiter.threshold(5).every(2).minutes()\n        )\n\n        (req, res, next) ->\n\n          {body} = req\n          {email, password, username} = body\n\n          {\n            'shrub-ui-notification': Notification\n            'shrub-user-local': UserLocal\n          } = orm.collections()  Register a new user.            UserLocal.register(username, email, password).then((localUser) ->  Send an email to the new user's email with a one-time login\nlink.              siteHostname = config.get 'packageConfig:shrub-core:siteHostname'\n            siteUrl = \"http://#{siteHostname}\"\n\n            scope =\n\n              email: email  TODO: HTTPS                loginUrl: \"#{siteUrl}/user/reset/#{user.resetPasswordToken}\"\n\n              siteUrl: siteUrl\n\n              user: localUser\n\n            Notification.createFromRequest(\n              req, 'shrubExampleGeneral'\n              type: 'register'\n              name: localUser.name\n              email: email\n            ).done()\n\n            nodemailer.sendMail(\n              'shrub-user-local-email-register'\n            ,\n              to: email\n              subject: 'Registration details'\n            ,\n              scope\n            ).done()\n\n            return\n\n          ).then(-> res.end()).catch next\n      ]\n\n    return routes  Implements hook  shrubReplContext      registrar.registerHook 'shrubReplContext', (context) ->\n      orm = require 'shrub-orm'\n      User = orm.collection 'shrub-user'\n      context.registerUser = -> User.register arguments...",
            "title": "User - Registration"
        },
        {
            "location": "/source/packages/shrub-user-local/reset/",
            "text": "User - Password reset\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubRpcRoutes\n\n\n  registrar.registerHook 'shrubRpcRoutes', ->\n\n    crypto = require 'server/crypto'\n\n    Promise = require 'bluebird'\n\n    {Limiter, LimiterMiddleware} = require 'shrub-limiter'\n    orm = require 'shrub-orm'\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-user/local/reset'\n\n      middleware: [\n\n        'shrub-http-express/session'\n        'shrub-villiany'\n\n        new LimiterMiddleware(\n          threshold: Limiter.threshold(1).every(5).minutes()\n        )\n\n        (req, res, next) ->\n\n          User =\n\n\n\n\nCancel promise flow if the user doesn't exist.\n\n\n          class NoSuchUser extends Error\n            constructor: (@message) ->\n\n\n\n\nLook up the user.\n\n\n          Promise.cast(\n            orm.collection('shrub-user-local').findOne(\n              resetPasswordToken: req.body.token\n            )\n          ).bind({}).then((@localUser) ->\n            throw new NoSuchUser unless @localUser?\n\n\n\n\nRecalculate the password hashing details.\n\n\n            crypto.hasher plaintext: req.body.password\n\n          ).then((hashed) ->\n\n            @localUser.passwordHash = hashed.key.toString 'hex'\n            @localUser.salt = hashed.salt.toString 'hex'\n            @localUser.resetPasswordToken = null\n\n            @localUser.save()\n\n          ).then(-> res.end()).catch(NoSuchUser, -> res.end()).catch next\n      ]\n\n    return routes",
            "title": "reset.coffee"
        },
        {
            "location": "/source/packages/shrub-user-local/reset/#user-password-reset",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubRpcRoutes    registrar.registerHook 'shrubRpcRoutes', ->\n\n    crypto = require 'server/crypto'\n\n    Promise = require 'bluebird'\n\n    {Limiter, LimiterMiddleware} = require 'shrub-limiter'\n    orm = require 'shrub-orm'\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-user/local/reset'\n\n      middleware: [\n\n        'shrub-http-express/session'\n        'shrub-villiany'\n\n        new LimiterMiddleware(\n          threshold: Limiter.threshold(1).every(5).minutes()\n        )\n\n        (req, res, next) ->\n\n          User =  Cancel promise flow if the user doesn't exist.            class NoSuchUser extends Error\n            constructor: (@message) ->  Look up the user.            Promise.cast(\n            orm.collection('shrub-user-local').findOne(\n              resetPasswordToken: req.body.token\n            )\n          ).bind({}).then((@localUser) ->\n            throw new NoSuchUser unless @localUser?  Recalculate the password hashing details.              crypto.hasher plaintext: req.body.password\n\n          ).then((hashed) ->\n\n            @localUser.passwordHash = hashed.key.toString 'hex'\n            @localUser.salt = hashed.salt.toString 'hex'\n            @localUser.resetPasswordToken = null\n\n            @localUser.save()\n\n          ).then(-> res.end()).catch(NoSuchUser, -> res.end()).catch next\n      ]\n\n    return routes",
            "title": "User - Password reset"
        },
        {
            "location": "/source/packages/shrub-user-reddit/client/",
            "text": "exports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubUserLoginStrategies\n\n\n  registrar.registerHook 'shrubUserLoginStrategies', ->\n\n    exports.shrubUserLoginStrategies()\n\nexports.shrubUserLoginStrategies = ->\n\n  methodLabel: 'Reddit'\n\n  fields:\n\n    forgot:\n      type: 'markup'\n      value: '<a target=\"_self\" class=\"btn btn-default\" href=\"/user/reddit/auth\">Authenticate with reddit</a>'\n\nexports.shrubOrmCollections = ->\n\n  UserReddit =\n\n    attributes:\n\n\n\n\nreddit ID.\n\n\n      redditId:\n        type: 'string'\n        required: true\n\n\n\n\nreddit username.\n\n\n      name:\n        type: 'string'\n        required: true\n\n\n\n\nOAuth2 access token.\n\n\n      accessToken:\n        type: 'longtext'\n\n\n\n\nOAuth2 refresh token.\n\n\n      refreshToken:\n        type: 'longtext'\n\n  'shrub-user-reddit': UserReddit",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-user-reddit/",
            "text": "reddit user authentication.\n\n\n\n\n\nAuthorize using a reddit account.\n\n\nconfig = require 'config'\nerrors = require 'errors'\n\norm = null\npassport = null\nPromise = null\n\nclientModule = require './client'\n\n\n\n\nORM collection and passport strategy for local authentication.\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n    siteHostname = config.get 'packageConfig:shrub-core:siteHostname'\n\n\n\n\nSee: \npassport-reddit\n for\nmore information about which configuration options are available.\n\n\n    constructionOptions:\n\n\n\n\nThe path that the client gets sent back to from reddit authorization.\n\n\n      callbackURL: \"http://#{siteHostname}/user/reddit/auth/callback\"\n\n\n\n\nPublic client ID.\n\n\n      clientID: 'REDDIT_CLIENT_ID'\n\n\n\n\nClient secret.\n\n\n      clientSecret: 'REDDIT_CLIENT_SECRET'\n\n\n\n\nAdjust scope configuration (by default, identity is provided).\n\n\n      scope: []\n\n    authorizationOptions:\n\n\n\n\nHow long the authorization should persist.\n\n\n      duration: 'temporary'\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    orm = require 'shrub-orm'\n    passport = require 'passport'\n    Promise = require 'bluebird'\n\n\n\n\nImplements hook \nshrubUserLoginStrategies\n\n\n  registrar.registerHook 'shrubUserLoginStrategies', ->\n    strategy = clientModule.shrubUserLoginStrategies()\n\n    RedditStrategy = require('passport-reddit').Strategy\n    UserReddit = orm.collection 'shrub-user-reddit'\n\n\n\n\nImplement a reddit passport strategy.\n\n\n    options = config.get(\n      'packageConfig:shrub-user-reddit:constructionOptions'\n    )\n    options.passReqToCallback = true\n\n\n\n\nVerification callback: find or create a reddit user instance and pass\nit along.\n\n\n    verifyCallback = (req, accessToken, refreshToken, profile, done) ->\n\n      UserReddit.findOrCreate(\n\n        redditId: profile.id\n      ,\n        redditId: profile.id\n        name: profile.name\n        accessToken: accessToken\n        refreshToken: refreshToken\n\n      ).then((instance) ->\n\n        instance.model = 'shrub-user-reddit'\n        return instance\n\n      ).nodeify done\n\n\n\n\nImplement a \nreddit Passport\n\nlogin strategy.\n\n\n    passportStrategy = new RedditStrategy options, verifyCallback\n    passportStrategy.name = 'shrub-user-reddit'\n    strategy.passportStrategy = passportStrategy\n\n    return strategy\n\n\n\n\nImplements hook \nshrubHttpRoutes\n\n\n  registrar.registerHook 'shrubHttpRoutes', (http) ->\n    routes = []\n\n    crypto = require 'server/crypto'\n\n\n\n\nProvide the reddit authorization entry point.\n\n\n    routes.push\n      path: '/user/reddit/auth'\n      receiver: (req, res, next) ->\n\n\n\n\nGenerate a random string to send as the 'state' token, so we can\nverify we were the source of this authentication request.\n\n\n        crypto.randomBytes(32).then (bytes) ->\n\n          options = config.get(\n            'packageConfig:shrub-user-reddit:authorizationOptions'\n          )\n          options.state = req.session.state = bytes.toString 'hex'\n\n          req.authorize(\n            'shrub-user-reddit', options, res\n          ).nodeify next\n\n\n\n\nProvide the reddit authorization callback.\n\n\n    routes.push\n      path: '/user/reddit/auth/callback'\n      receiver: (req, res, next) ->\n\n        if req.query.state isnt req.session.state\n          error = new Error(\n            \"Your reddit session state didn't match on the callback\"\n          )\n          error.code = 403\n          return next error\n\n        promise = req.authorize(\n          'shrub-user-reddit', res\n        )\n\n        require('shrub-user/login').loginWithInstance(\n          promise, req\n        ).then(-> next()).catch (error) ->\n\n\n\n\nIn case of an authorization error, we want to send it to the\nclient; it's not a server error.\n\n\n          (req.session.errorMessages ?= []).push errors.serialize error\n          return res.redirect '/'\n\n    return routes\n\n\n\n\nImplements hook \nshrubUserRedactors\n\n\n  registrar.registerHook 'shrubUserRedactors', ->\n\n    'shrub-user-reddit': [\n\n      (object, user) ->\n\n        redacted = name: object.name\n        return redacted\n\n    ]\n\n\n\n\nImplements hook \nshrubOrmCollections\n\n\n  registrar.registerHook 'shrubOrmCollections', ->\n\n    crypto = require 'server/crypto'\n\n\n\n\nInvoke the client hook implementation.\n\n\n    collections = clientModule.shrubOrmCollections()\n\n    {\n      'shrub-user-reddit': UserReddit\n    } = collections\n\n\n\n\nUserReddit#associatedUser\n\n\nTODO: This should be in a superclass.\n\n\nGet the user (if any) associated with this instance.\n\n\n    UserReddit.attributes.associatedUser = ->\n      {\n        'shrub-user-instance': UserInstance\n        'shrub-user': User\n      } = orm.collections()\n\n      UserInstance.findOne(\n        model: 'shrub-user-reddit'\n        modelId: @id\n      ).then (userInstance) -> User.findOnePopulated id: userInstance?.user\n\n    collections",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-user-reddit/#userredditassociateduser",
            "text": "TODO: This should be in a superclass.  Get the user (if any) associated with this instance.      UserReddit.attributes.associatedUser = ->\n      {\n        'shrub-user-instance': UserInstance\n        'shrub-user': User\n      } = orm.collections()\n\n      UserInstance.findOne(\n        model: 'shrub-user-reddit'\n        modelId: @id\n      ).then (userInstance) -> User.findOnePopulated id: userInstance?.user\n\n    collections",
            "title": "UserReddit#associatedUser"
        },
        {
            "location": "/source/packages/shrub-user/client/",
            "text": "User\n\n\nUser operations, model, etc.\n\n\n{TransmittableError} = require 'errors'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubOrmCollections\n\n\n  registrar.registerHook 'shrubOrmCollections', exports.shrubOrmCollections\n\n\n\n\nImplements hook \nshrubOrmCollectionsAlter\n\n\n  registrar.registerHook 'shrubOrmCollectionsAlter', exports.shrubOrmCollectionsAlter\n\n\n\n\nImplements hook \nshrubAngularDirective\n\n\n  registrar.registerHook 'actions', 'shrubAngularDirective', -> [\n    'shrub-user'\n    (user) ->\n\n      directive = {}\n\n      directive.link = (scope) ->\n\n        scope.user = user\n\n        scope.username = -> user.instance()?.instances?[0]?.name or 'Anonymous'\n\n      directive.scope = {}\n\n      directive.template = '''\n\n<span class=\"user\">\n  <span\n    class=\"username\"\n    data-ng-bind=\"username()\"\n  ></span>\n\n  <span\n    class=\"actions\"\n    data-ng-if=\"!user.isLoggedIn()\"\n  >\n    [<a href=\"/user/login\">Log in</a> \u00b7 <a href=\"/user/register\">Register</a>]\n  </span>\n\n  <span\n    class=\"actions\"\n    data-ng-if=\"user.isLoggedIn()\"\n  >\n    [<a href=\"/user/logout\">Log out</a>]\n  </span>\n\n</span>\n\n'''\n\n      return directive\n\n  ]\n\n\n\n\nImplements hook \nshrubAngularService\n\n\n  registrar.registerHook 'shrubAngularService', -> [\n    'shrub-orm', 'shrub-rpc', 'shrub-socket'\n    (orm, rpc, socket) ->\n\n      config = require 'config'\n\n      User = orm.collection 'shrub-user'\n\n      service = {}\n\n      _instance = {}\n      _instance[k] = v for k, v of User.instantiate(\n        config.get 'packageConfig:shrub-user'\n      )\n\n\n\n\nLog a user out if we get a socket call.\n\n\n      logout = ->\n\n        blank = User.instantiate()\n        delete _instance[k] for k of _instance\n        _instance[k] = v for k, v of blank\n\n        return\n\n      socket.on 'shrub-user/logout', logout\n\n\n\n\nuser.isLoggedIn\n\n\nWhether the current application user is logged in.\n\n\n      service.isLoggedIn = -> _instance.id?\n\n\n\n\nuser.login\n\n\nLog in with strategy values.\n\n\n      service.login = (values) ->\n\n        rpc.call('shrub-user/login', values).then (O) ->\n          _instance[k] = v for k, v of O\n          return\n\n\n\n\nuser.logout\n\n\nLog out.\n\n\n      service.logout = ->\n\n        rpc.call(\n          'shrub-user/logout'\n\n        ).then logout\n\n\n\n\nuser.instance\n\n\nRetrieve the user instance.\n\n\n      service.instance = -> _instance\n\n      return service\n\n  ]\n\n\n\n\nImplements hook \nshrubTransmittableErrors\n\n\n  registrar.registerHook 'shrubTransmittableErrors', exports.shrubTransmittableErrors\n\n  registrar.recur [\n    'login', 'logout'\n  ]\n\nexports.shrubOrmCollections = ->\n\n\n\n\nTODO: Finish these docs.\n\n\n  Group =\n\n    associations: [\n      alias: 'permissions'\n    ]\n\n    attributes:\n\n      name:\n        type: 'string'\n        size: 24\n        maxLength: 24\n\n      permissions:\n        collection: 'shrub-group-permission'\n        via: 'group'\n\n  GroupPermission =\n\n    attributes:\n\n      permission: 'string'\n\n      group: model: 'shrub-group'\n\n  User =\n\n    associations: [\n      alias: 'groups'\n    ,\n      alias: 'instances'\n    ,\n      alias: 'permissions'\n    ]\n\n    attributes:\n\n\n\n\nGroups this user belongs to.\n\n\n      groups:\n        collection: 'shrub-user-group'\n        via: 'user'\n\n\n\n\nUser instances.\n\n\n      instances:\n        collection: 'shrub-user-instance'\n        via: 'user'\n\n\n\n\nGroups this user belongs to.\n\n\n      permissions:\n        collection: 'shrub-user-permission'\n        via: 'user'\n\n\n\n\nCheck whether a user has a permission.\n\n\n      hasPermission: (permission) ->\n\n\n\n\nSuperuser?\n\n\n        return true if @id is 1\n\n\n\n\nCheck group permissions.\n\n\n        for {permissions} in @groups\n          return true if ~permissions.indexOf permission\n\n\n\n\nCheck inline permissions.\n\n\n        return ~@permissions.indexOf permission\n\n  UserGroup =\n\n    attributes:\n\n      group: model: 'shrub-group'\n\n      user: model: 'shrub-user'\n\n  UserInstance =\n\n    attributes:\n\n      model:\n        type: 'string'\n        size: '24'\n\n      modelId:\n        type: 'integer'\n\n      user: model: 'shrub-user'\n\n  UserPermission =\n\n    attributes:\n\n      permission: 'string'\n\n      user: model: 'shrub-user'\n\n  'shrub-group': Group\n  'shrub-group-permission': GroupPermission\n  'shrub-user': User\n  'shrub-user-group': UserGroup\n  'shrub-user-instance': UserInstance\n  'shrub-user-permission': UserPermission\n\n\n\n\nTransmittable login conflict error.\n\n\nclass LoginConflictError extends TransmittableError\n\n  errorType: 'shrub-user-login-conflict'\n  template: 'That account already belongs to another user. First log out and then log in with that account.'\n\n\n\n\nTransmittable redundant login error.\n\n\nclass RedundantLoginError extends TransmittableError\n\n  errorType: 'shrub-user-login-redundant'\n  template: 'You are already logged in with that account.'\n\nexports.shrubTransmittableErrors = -> [\n  LoginConflictError\n  RedundantLoginError\n]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-user/client/#user",
            "text": "User operations, model, etc.  {TransmittableError} = require 'errors'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubOrmCollections    registrar.registerHook 'shrubOrmCollections', exports.shrubOrmCollections  Implements hook  shrubOrmCollectionsAlter    registrar.registerHook 'shrubOrmCollectionsAlter', exports.shrubOrmCollectionsAlter  Implements hook  shrubAngularDirective    registrar.registerHook 'actions', 'shrubAngularDirective', -> [\n    'shrub-user'\n    (user) ->\n\n      directive = {}\n\n      directive.link = (scope) ->\n\n        scope.user = user\n\n        scope.username = -> user.instance()?.instances?[0]?.name or 'Anonymous'\n\n      directive.scope = {}\n\n      directive.template = '''\n\n<span class=\"user\">\n  <span\n    class=\"username\"\n    data-ng-bind=\"username()\"\n  ></span>\n\n  <span\n    class=\"actions\"\n    data-ng-if=\"!user.isLoggedIn()\"\n  >\n    [<a href=\"/user/login\">Log in</a> \u00b7 <a href=\"/user/register\">Register</a>]\n  </span>\n\n  <span\n    class=\"actions\"\n    data-ng-if=\"user.isLoggedIn()\"\n  >\n    [<a href=\"/user/logout\">Log out</a>]\n  </span>\n\n</span>\n\n'''\n\n      return directive\n\n  ]  Implements hook  shrubAngularService    registrar.registerHook 'shrubAngularService', -> [\n    'shrub-orm', 'shrub-rpc', 'shrub-socket'\n    (orm, rpc, socket) ->\n\n      config = require 'config'\n\n      User = orm.collection 'shrub-user'\n\n      service = {}\n\n      _instance = {}\n      _instance[k] = v for k, v of User.instantiate(\n        config.get 'packageConfig:shrub-user'\n      )  Log a user out if we get a socket call.        logout = ->\n\n        blank = User.instantiate()\n        delete _instance[k] for k of _instance\n        _instance[k] = v for k, v of blank\n\n        return\n\n      socket.on 'shrub-user/logout', logout",
            "title": "User"
        },
        {
            "location": "/source/packages/shrub-user/client/#userisloggedin",
            "text": "Whether the current application user is logged in.        service.isLoggedIn = -> _instance.id?",
            "title": "user.isLoggedIn"
        },
        {
            "location": "/source/packages/shrub-user/client/#userlogin",
            "text": "Log in with strategy values.        service.login = (values) ->\n\n        rpc.call('shrub-user/login', values).then (O) ->\n          _instance[k] = v for k, v of O\n          return",
            "title": "user.login"
        },
        {
            "location": "/source/packages/shrub-user/client/#userlogout",
            "text": "Log out.        service.logout = ->\n\n        rpc.call(\n          'shrub-user/logout'\n\n        ).then logout",
            "title": "user.logout"
        },
        {
            "location": "/source/packages/shrub-user/client/#userinstance",
            "text": "Retrieve the user instance.        service.instance = -> _instance\n\n      return service\n\n  ]  Implements hook  shrubTransmittableErrors    registrar.registerHook 'shrubTransmittableErrors', exports.shrubTransmittableErrors\n\n  registrar.recur [\n    'login', 'logout'\n  ]\n\nexports.shrubOrmCollections = ->  TODO: Finish these docs.    Group =\n\n    associations: [\n      alias: 'permissions'\n    ]\n\n    attributes:\n\n      name:\n        type: 'string'\n        size: 24\n        maxLength: 24\n\n      permissions:\n        collection: 'shrub-group-permission'\n        via: 'group'\n\n  GroupPermission =\n\n    attributes:\n\n      permission: 'string'\n\n      group: model: 'shrub-group'\n\n  User =\n\n    associations: [\n      alias: 'groups'\n    ,\n      alias: 'instances'\n    ,\n      alias: 'permissions'\n    ]\n\n    attributes:  Groups this user belongs to.        groups:\n        collection: 'shrub-user-group'\n        via: 'user'  User instances.        instances:\n        collection: 'shrub-user-instance'\n        via: 'user'  Groups this user belongs to.        permissions:\n        collection: 'shrub-user-permission'\n        via: 'user'  Check whether a user has a permission.        hasPermission: (permission) ->  Superuser?          return true if @id is 1  Check group permissions.          for {permissions} in @groups\n          return true if ~permissions.indexOf permission  Check inline permissions.          return ~@permissions.indexOf permission\n\n  UserGroup =\n\n    attributes:\n\n      group: model: 'shrub-group'\n\n      user: model: 'shrub-user'\n\n  UserInstance =\n\n    attributes:\n\n      model:\n        type: 'string'\n        size: '24'\n\n      modelId:\n        type: 'integer'\n\n      user: model: 'shrub-user'\n\n  UserPermission =\n\n    attributes:\n\n      permission: 'string'\n\n      user: model: 'shrub-user'\n\n  'shrub-group': Group\n  'shrub-group-permission': GroupPermission\n  'shrub-user': User\n  'shrub-user-group': UserGroup\n  'shrub-user-instance': UserInstance\n  'shrub-user-permission': UserPermission  Transmittable login conflict error.  class LoginConflictError extends TransmittableError\n\n  errorType: 'shrub-user-login-conflict'\n  template: 'That account already belongs to another user. First log out and then log in with that account.'  Transmittable redundant login error.  class RedundantLoginError extends TransmittableError\n\n  errorType: 'shrub-user-login-redundant'\n  template: 'You are already logged in with that account.'\n\nexports.shrubTransmittableErrors = -> [\n  LoginConflictError\n  RedundantLoginError\n]",
            "title": "user.instance"
        },
        {
            "location": "/source/packages/shrub-user/client/login/",
            "text": "User login\n\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularRoutes\n\n\n  registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/login'\n      title: 'Sign in'\n\n      controller: [\n        '$location', '$scope', 'shrub-ui/messages', 'shrub-user'\n        ($location, $scope, messages, user) ->\n\n\n\n\nInvoke hook \nshrubUserLoginStrategies\n\n\n          strategies = pkgman.invoke 'shrubUserLoginStrategies'\n\n\n\n\nInvoke hook \nshrubUserLoginStrategiesAlter\n\n\n          pkgman.invoke 'shrubUserLoginStrategiesAlter', strategies\n\n\n\n\nCount the active strategies.\n\n\n          strategiesCount = pkgman.packagesImplementing(\n            'shrubUserLoginStrategies'\n          ).length\n\n\n\n\nBuild the login form.\n\n\n          $scope.form =\n\n            key: 'shrub-user-login'\n\n            submits: [\n\n              (values) ->\n\n\n\n\nExtract the values from the active strategy's fieldgroup.\n\n\n                methodValues = values[values.method]\n\n\n\n\nManually inject the method into the strategy values.\n\n\n                methodValues.method = values.method\n\n\n\n\nAttempt the login.\n\n\n                user.login(methodValues).then ->\n\n\n\n\nNotify user.\n\n\n                  messages.add(\n                    class: 'alert-success'\n                    text: 'Logged in successfully.'\n                  )\n\n\n\n\nRedirect to root.\n\n\n                  $location.path '/'\n\n            ]\n\n\n\n\nNo strategies? Bail.\n\n\n          return $location.path '/' if strategiesCount is 0\n\n\n\n\nDRY\n\n\n          fields = $scope.form.fields = {}\n\n\n\n\nIf there's only one strategy active, simply inject the \nmethod\n\ninto the form as a hidden field.\n\n\n          if strategiesCount is 1\n\n            method = packageName for packageName, strategy of strategies\n\n            fields.method =\n              type: 'hidden'\n              value: method\n\n\n\n\nIf there's more than one method, use a dropdown to select the\nlogin strategy.\n\n\n          else\n\n            fields.method =\n              type: 'select'\n              label: 'Method'\n              options: 'key as value for (key , value) in field.methodOptions'\n\n\n\n\nBuild the options list.\n\n\n            fields.method.methodOptions = {}\n            for packageName, {methodLabel} of strategies\n\n\n\n\nStart the select with the first value, otherwise Angular\nwill inject a blank element.\n\n\n              fields.method.value = packageName unless fields.method.value?\n\n\n\n\nUse the strategy labels.\n\n\n              fields.method.methodOptions[packageName] = methodLabel\n\n\n\n\nInject a fieldgroup for every login strategy.\n\n\n          for packageName, strategy of strategies\n            do (packageName) -> fields[packageName] =\n              type: 'group'\n              collapse: false\n              isVisible: ->\n                console.log fields.method.value\n                fields.method.value is packageName\n              fields: strategy.fields\n\n\n      ]\n\n      template: '''\n\n<div\n  data-shrub-form\n  data-form=\"form\"\n></div>\n\n'''\n\n    return routes",
            "title": "login.coffee"
        },
        {
            "location": "/source/packages/shrub-user/client/login/#user-login",
            "text": "config = require 'config'\npkgman = require 'pkgman'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularRoutes    registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/login'\n      title: 'Sign in'\n\n      controller: [\n        '$location', '$scope', 'shrub-ui/messages', 'shrub-user'\n        ($location, $scope, messages, user) ->  Invoke hook  shrubUserLoginStrategies            strategies = pkgman.invoke 'shrubUserLoginStrategies'  Invoke hook  shrubUserLoginStrategiesAlter            pkgman.invoke 'shrubUserLoginStrategiesAlter', strategies  Count the active strategies.            strategiesCount = pkgman.packagesImplementing(\n            'shrubUserLoginStrategies'\n          ).length  Build the login form.            $scope.form =\n\n            key: 'shrub-user-login'\n\n            submits: [\n\n              (values) ->  Extract the values from the active strategy's fieldgroup.                  methodValues = values[values.method]  Manually inject the method into the strategy values.                  methodValues.method = values.method  Attempt the login.                  user.login(methodValues).then ->  Notify user.                    messages.add(\n                    class: 'alert-success'\n                    text: 'Logged in successfully.'\n                  )  Redirect to root.                    $location.path '/'\n\n            ]  No strategies? Bail.            return $location.path '/' if strategiesCount is 0  DRY            fields = $scope.form.fields = {}  If there's only one strategy active, simply inject the  method \ninto the form as a hidden field.            if strategiesCount is 1\n\n            method = packageName for packageName, strategy of strategies\n\n            fields.method =\n              type: 'hidden'\n              value: method  If there's more than one method, use a dropdown to select the\nlogin strategy.            else\n\n            fields.method =\n              type: 'select'\n              label: 'Method'\n              options: 'key as value for (key , value) in field.methodOptions'  Build the options list.              fields.method.methodOptions = {}\n            for packageName, {methodLabel} of strategies  Start the select with the first value, otherwise Angular\nwill inject a blank element.                fields.method.value = packageName unless fields.method.value?  Use the strategy labels.                fields.method.methodOptions[packageName] = methodLabel  Inject a fieldgroup for every login strategy.            for packageName, strategy of strategies\n            do (packageName) -> fields[packageName] =\n              type: 'group'\n              collapse: false\n              isVisible: ->\n                console.log fields.method.value\n                fields.method.value is packageName\n              fields: strategy.fields\n\n\n      ]\n\n      template: '''\n\n<div\n  data-shrub-form\n  data-form=\"form\"\n></div>\n\n'''\n\n    return routes",
            "title": "User login"
        },
        {
            "location": "/source/packages/shrub-user/client/logout/",
            "text": "User logout\n\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubAngularRoutes\n\n\n  registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/logout'\n\n      controller: [\n        '$location', 'shrub-user'\n        ($location, user) ->\n          return $location.path '/' unless user.isLoggedIn()\n\n          user.logout().then -> $location.path '/'\n\n      ]\n\n    return routes",
            "title": "logout.coffee"
        },
        {
            "location": "/source/packages/shrub-user/client/logout/#user-logout",
            "text": "exports.pkgmanRegister = (registrar) ->  Implements hook  shrubAngularRoutes    registrar.registerHook 'shrubAngularRoutes', ->\n\n    routes = []\n\n    routes.push\n\n      path: 'user/logout'\n\n      controller: [\n        '$location', 'shrub-user'\n        ($location, user) ->\n          return $location.path '/' unless user.isLoggedIn()\n\n          user.logout().then -> $location.path '/'\n\n      ]\n\n    return routes",
            "title": "User logout"
        },
        {
            "location": "/source/packages/shrub-user/",
            "text": "User\n\n\n\n\n\nUser operations.\n\n\nPromise = null\n\n{Middleware} = require 'middleware'\n\norm = null\n\nclientModule = require './client'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    Promise = require 'bluebird'\n\n    orm = require 'shrub-orm'\n\n\n\n\nImplements hook \nshrubConfigClient\n\n\n  registrar.registerHook 'shrubConfigClient', (req) ->\n\n\n\n\nSend a redacted version of the request user.\n\n\n    req.user.redactObject 'shrub-user', req.user if req.user?\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n    beforeLoginMiddleware: [\n      'shrub-user'\n    ]\n\n    afterLoginMiddleware: [\n    ]\n\n    beforeLogoutMiddleware: [\n      'shrub-user'\n    ]\n\n    afterLogoutMiddleware: [\n    ]\n\n\n\n\nImplements hook \nshrubUserRedactors\n\n\n  registrar.registerHook 'shrubUserRedactors', ->\n\n    'shrub-user': [\n      (object, user) ->\n\n        redacted =\n          id: object.id\n\n\n\n\nTODO: Include/merge permissions.\n\n\n        for group in object.groups\n\n          (redacted.groups ?= []).push group.name\n\n\n\n\nRedact instances.\n\n\n        return Promise.all(\n\n          for instance in object.instances\n            user.redactObject instance.model, instance\n\n        ).then (instances) ->\n\n          redacted.instances = instances\n\n          return redacted\n\n    ]\n\n\n\n\nImplements hook \nshrubAuditFingerprint\n\n\n  registrar.registerHook 'shrubAuditFingerprint', (req) ->\n\n\n\n\nUser (ID).\n\n\n    user: if req?.user?.id? then req.user.id\n\n\n\n\nImplements hook \nshrubOrmCollections\n\n\n  registrar.registerHook 'shrubOrmCollections', ->\n\n\n\n\nInvoke the client hook implementation.\n\n\n    collections = clientModule.shrubOrmCollections()\n\n    {\n      'shrub-group': Group\n      'shrub-group-permission': GroupPermission\n      'shrub-user': User\n      'shrub-user-group': UserGroup\n      'shrub-user-permission': UserPermission\n    } = collections\n\n\n\n\nStore case-insensitive name.\n\n\n    autoIname = (values, cb) ->\n      values.iname = values.name.toLowerCase()\n      cb()\n\n    Group.beforeCreate = autoIname\n    Group.beforeUpdate = autoIname\n\n\n\n\nCase-insensitive name.\n\n\n    Group.attributes.iname =\n      type: 'string'\n      size: 24\n      index: true\n\n\n\n\nDisable the default createdAt/updatedAt attributes.\n\n\n    Group.autoCreatedAt = false\n    Group.autoUpdatedAt = false\n\n\n\n\nDisable the default createdAt/updatedAt attributes.\n\n\n    GroupPermission.autoCreatedAt = false\n    GroupPermission.autoUpdatedAt = false\n\n\n\n\nUser.findOnePopulated\n\n\n\n\n(object) \nwhere\n - Query conditions.\n\n\n\n\nFind a user in the system and fully populate it.\n\n\n    User.findOnePopulated = (where) ->\n      @findOne(where).populateAll().then (user) -> user?.populateAll()\n\n\n\n\nUser#populateAll\n\n\nFully populate a user.\n\n\n    User.attributes.populateAll = ->\n      self = this\n\n\n\n\nPopulate permissions.\n\n\n      @permissions = @permissions.map ({permission}) -> permission\n\n\n\n\nLoad and populate groups.\n\n\n      Group_ = orm.collection 'shrub-group'\n\n      groupsPromise = Promise.all(\n\n        Group_.findOne(id: group).populateAll() for {group}, index in @groups\n\n      ).then (groups) -> self.groups[index] = group for group, index in groups\n\n\n\n\nLoad and populate user instances.\n\n\n      instancesPromise = Promise.all(\n\n        for instance, index in @instances\n          Model = orm.collection instance.model\n          Model.findOne id: instance.modelId\n\n      ).then (models) ->\n\n        for model, index in models\n          model.user = self.id\n          model.model = self.instances[index].model\n          self.instances[index] = model\n\n      Promise.all([\n        groupsPromise\n        instancesPromise\n      ]).then -> self\n\n    redactors = null\n\n\n\n\nUser#redactObject\n\n\n\n\n\n\n(string) \ntype\n - The type of object to redact.\n\n\n\n\n\n\n(object) \nobject\n - The object to redact.\n\n\n\n\n\n\nRedact an object based on a user's permission.\n\n\n    User.attributes.redactObject = (type, object) ->\n      self = this\n\n      pkgman = require 'pkgman'\n\n\n\n\nCollect redactors.\n\n\nTODO: Caching.\n\n\n      unless redactors?\n        redactors = {}\n\n\n\n\nInvoke hook \nshrubUserRedactors\n\n\n        for redactorTypes in pkgman.invokeFlat 'shrubUserRedactors'\n          for type_, redactors_ of redactorTypes\n            (redactors[type_] ?= []).push redactors_...\n\n\n\n\nNo redactors? Just promise the original object.\n\n\n      return Promise.resolve object if redactors[type].length is 0\n\n\n\n\nWalk down the list of redactors promising and returning them serially.\n\n\n      promise = Promise.resolve object\n      for redactor in redactors[type]\n        promise = do (redactor) -> promise.then (redacted) ->\n          Promise.cast redactor object, self\n\n      return promise\n\n\n\n\nUser#toJSON\n\n\nRender the user as a POD object.\n\n\n    User.attributes.toJSON = ->\n      O = @toObject()\n\n      O.groups = @groups\n      O.permissions = @permissions\n      O.instances = @instances\n\n      O\n\n\n\n\nDisable the default createdAt/updatedAt attributes.\n\n\n    UserGroup.autoCreatedAt = false\n    UserGroup.autoUpdatedAt = false\n\n\n\n\nUserGroup#populateAll\n\n\nFully populate a user group.\n\n\n    UserGroup.attributes.populateAll = ->\n      self = this\n\n      Group_ = orm.collection 'shrub-group'\n      Group_.findOne(id: self.group).populateAll().then (group_) ->\n        self.group = group_\n\n        return self\n\n\n\n\nDisable the default createdAt/updatedAt attributes.\n\n\n    UserPermission.autoCreatedAt = false\n    UserPermission.autoUpdatedAt = false\n\n    collections\n\n\n\n\nImplements hook \nshrubTransmittableErrors\n\n\n  registrar.registerHook 'shrubTransmittableErrors', clientModule.shrubTransmittableErrors\n\n\n\n\nImplements hook \nshrubUserBeforeLoginMiddleware\n\n\n  registrar.registerHook 'shrubUserBeforeLoginMiddleware', ->\n\n    label: 'Join user channel'\n    middleware: [\n      (req, next) ->\n        return next() unless req.socket.join?\n        req.socket.join \"user/#{req.loggingInUser.id}\", next\n    ]\n\n\n\n\nImplements hook \nshrubUserBeforeLogoutMiddleware\n\n\n  registrar.registerHook 'shrubUserBeforeLogoutMiddleware', ->\n\n    label: 'Tell client to log out, and leave the user channel'\n    middleware: [\n\n      (req, next) ->\n        return next() unless req.socket.emit?\n\n\n\n\nTell client to log out.\n\n\n        req.socket.emit 'shrub-user/logout'\n        next()\n\n      (req, next) ->\n        return next() unless req.socket.leave?\n\n\n\n\nLeave the user channel.\n\n\n        if req.user.id?\n          req.socket.leave \"user/#{req.loggingOutUser.id}\", next\n        else\n          next()\n\n    ]\n\n  registrar.recur [\n    'login'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-user/#user",
            "text": "User operations.  Promise = null\n\n{Middleware} = require 'middleware'\n\norm = null\n\nclientModule = require './client'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    Promise = require 'bluebird'\n\n    orm = require 'shrub-orm'  Implements hook  shrubConfigClient    registrar.registerHook 'shrubConfigClient', (req) ->  Send a redacted version of the request user.      req.user.redactObject 'shrub-user', req.user if req.user?  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->\n\n    beforeLoginMiddleware: [\n      'shrub-user'\n    ]\n\n    afterLoginMiddleware: [\n    ]\n\n    beforeLogoutMiddleware: [\n      'shrub-user'\n    ]\n\n    afterLogoutMiddleware: [\n    ]  Implements hook  shrubUserRedactors    registrar.registerHook 'shrubUserRedactors', ->\n\n    'shrub-user': [\n      (object, user) ->\n\n        redacted =\n          id: object.id  TODO: Include/merge permissions.          for group in object.groups\n\n          (redacted.groups ?= []).push group.name  Redact instances.          return Promise.all(\n\n          for instance in object.instances\n            user.redactObject instance.model, instance\n\n        ).then (instances) ->\n\n          redacted.instances = instances\n\n          return redacted\n\n    ]  Implements hook  shrubAuditFingerprint    registrar.registerHook 'shrubAuditFingerprint', (req) ->  User (ID).      user: if req?.user?.id? then req.user.id  Implements hook  shrubOrmCollections    registrar.registerHook 'shrubOrmCollections', ->  Invoke the client hook implementation.      collections = clientModule.shrubOrmCollections()\n\n    {\n      'shrub-group': Group\n      'shrub-group-permission': GroupPermission\n      'shrub-user': User\n      'shrub-user-group': UserGroup\n      'shrub-user-permission': UserPermission\n    } = collections  Store case-insensitive name.      autoIname = (values, cb) ->\n      values.iname = values.name.toLowerCase()\n      cb()\n\n    Group.beforeCreate = autoIname\n    Group.beforeUpdate = autoIname  Case-insensitive name.      Group.attributes.iname =\n      type: 'string'\n      size: 24\n      index: true  Disable the default createdAt/updatedAt attributes.      Group.autoCreatedAt = false\n    Group.autoUpdatedAt = false  Disable the default createdAt/updatedAt attributes.      GroupPermission.autoCreatedAt = false\n    GroupPermission.autoUpdatedAt = false",
            "title": "User"
        },
        {
            "location": "/source/packages/shrub-user/#userfindonepopulated",
            "text": "(object)  where  - Query conditions.   Find a user in the system and fully populate it.      User.findOnePopulated = (where) ->\n      @findOne(where).populateAll().then (user) -> user?.populateAll()",
            "title": "User.findOnePopulated"
        },
        {
            "location": "/source/packages/shrub-user/#userpopulateall",
            "text": "Fully populate a user.      User.attributes.populateAll = ->\n      self = this  Populate permissions.        @permissions = @permissions.map ({permission}) -> permission  Load and populate groups.        Group_ = orm.collection 'shrub-group'\n\n      groupsPromise = Promise.all(\n\n        Group_.findOne(id: group).populateAll() for {group}, index in @groups\n\n      ).then (groups) -> self.groups[index] = group for group, index in groups  Load and populate user instances.        instancesPromise = Promise.all(\n\n        for instance, index in @instances\n          Model = orm.collection instance.model\n          Model.findOne id: instance.modelId\n\n      ).then (models) ->\n\n        for model, index in models\n          model.user = self.id\n          model.model = self.instances[index].model\n          self.instances[index] = model\n\n      Promise.all([\n        groupsPromise\n        instancesPromise\n      ]).then -> self\n\n    redactors = null",
            "title": "User#populateAll"
        },
        {
            "location": "/source/packages/shrub-user/#userredactobject",
            "text": "(string)  type  - The type of object to redact.    (object)  object  - The object to redact.    Redact an object based on a user's permission.      User.attributes.redactObject = (type, object) ->\n      self = this\n\n      pkgman = require 'pkgman'  Collect redactors.  TODO: Caching.        unless redactors?\n        redactors = {}  Invoke hook  shrubUserRedactors          for redactorTypes in pkgman.invokeFlat 'shrubUserRedactors'\n          for type_, redactors_ of redactorTypes\n            (redactors[type_] ?= []).push redactors_...  No redactors? Just promise the original object.        return Promise.resolve object if redactors[type].length is 0  Walk down the list of redactors promising and returning them serially.        promise = Promise.resolve object\n      for redactor in redactors[type]\n        promise = do (redactor) -> promise.then (redacted) ->\n          Promise.cast redactor object, self\n\n      return promise",
            "title": "User#redactObject"
        },
        {
            "location": "/source/packages/shrub-user/#usertojson",
            "text": "Render the user as a POD object.      User.attributes.toJSON = ->\n      O = @toObject()\n\n      O.groups = @groups\n      O.permissions = @permissions\n      O.instances = @instances\n\n      O  Disable the default createdAt/updatedAt attributes.      UserGroup.autoCreatedAt = false\n    UserGroup.autoUpdatedAt = false",
            "title": "User#toJSON"
        },
        {
            "location": "/source/packages/shrub-user/#usergrouppopulateall",
            "text": "Fully populate a user group.      UserGroup.attributes.populateAll = ->\n      self = this\n\n      Group_ = orm.collection 'shrub-group'\n      Group_.findOne(id: self.group).populateAll().then (group_) ->\n        self.group = group_\n\n        return self  Disable the default createdAt/updatedAt attributes.      UserPermission.autoCreatedAt = false\n    UserPermission.autoUpdatedAt = false\n\n    collections  Implements hook  shrubTransmittableErrors    registrar.registerHook 'shrubTransmittableErrors', clientModule.shrubTransmittableErrors  Implements hook  shrubUserBeforeLoginMiddleware    registrar.registerHook 'shrubUserBeforeLoginMiddleware', ->\n\n    label: 'Join user channel'\n    middleware: [\n      (req, next) ->\n        return next() unless req.socket.join?\n        req.socket.join \"user/#{req.loggingInUser.id}\", next\n    ]  Implements hook  shrubUserBeforeLogoutMiddleware    registrar.registerHook 'shrubUserBeforeLogoutMiddleware', ->\n\n    label: 'Tell client to log out, and leave the user channel'\n    middleware: [\n\n      (req, next) ->\n        return next() unless req.socket.emit?  Tell client to log out.          req.socket.emit 'shrub-user/logout'\n        next()\n\n      (req, next) ->\n        return next() unless req.socket.leave?  Leave the user channel.          if req.user.id?\n          req.socket.leave \"user/#{req.loggingOutUser.id}\", next\n        else\n          next()\n\n    ]\n\n  registrar.recur [\n    'login'\n  ]",
            "title": "UserGroup#populateAll"
        },
        {
            "location": "/source/packages/shrub-user/login/",
            "text": "errors = require 'errors'\n\norm = null\nPromise = null\n\nclientModule = require './client/login'\nuserPackage = require './index'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    orm = require 'shrub-orm'\n    Promise = require 'bluebird'\n\n\n\n\nImplements hook \nshrubRpcRoutes\n\n\n  registrar.registerHook 'shrubRpcRoutes', ->\n\n    {Limiter, LimiterMiddleware} = require 'shrub-limiter'\n\n    routes = []\n\n    routes.push\n\n      path: 'shrub-user/login'\n\n      middleware: [\n\n        'shrub-http-express/session'\n        'shrub-villiany'\n\n        'shrub-passport'\n\n        new LimiterMiddleware(\n          message: 'You are logging in too much.'\n          threshold: Limiter.threshold(3).every(30).seconds()\n        )\n\n        (req, res, next) ->\n\n\n\n\nAuthorize a user instance.\n\n\n          promise = req.authorize(\n            req.body.method, res\n          )\n\n          exports.loginWithInstance(promise, req).then((user) ->\n\n\n\n\nRedact the user for sending over the wire.\n\n\n            user.redactObject 'shrub-user', user\n\n\n\n\nEnd the request, sending the redacted user.\n\n\n          ).then((redactedUser) -> res.end redactedUser).catch next\n\n\n      ]\n\n    return routes\n\nexports.loginWithInstance = (promise, req) ->\n\n  promise.then((instance, info) ->\n\n\n\n\nGet any associated user.\n\n\n    instance.associatedUser()\n\n  ).then((associatedUser) ->\n\n    if associatedUser?\n\n      if req.user?\n\n\n\n\nIf the user is already logged in and the instance has an\nassociated user, they're either already logged in with\nthe instance, or the instance belongs to another user. Throw\na relevant error either way.\n\n\n        if req.user.id is associatedUser.id\n\n          throw errors.instantiate('shrub-user-login-redundant')\n\n        else\n\n          throw errors.instantiate('shrub-user-login-conflict')\n\n\n\n\nIf the user isn't already logged in, just return the user\nassociated with the instance.\n\n\n      else\n\n        return associatedUser\n\n    else\n\n\n\n\nIf the instance isn't already associated with a user, either\ntarget the logged-in user, or if the user isn't already\nlogged in, target a new user.\n\n\n      promise = if req.user?\n\n        Promise.resolve req.user\n\n      else\n\n        orm.collection('shrub-user').create()\n\n\n\n\nAssociate the instance with the user targeted just above.\n\n\n      promise.then (user) ->\n\n        user.instances.add(\n          model: instance.model\n          modelId: instance.id\n        )\n\n        user.save().then -> return user\n\n\n\n\nLog in the user if not already logged in.\n\n\n  ).then (user) ->\n\n    req.logIn user unless req.user?\n    return user",
            "title": "login.coffee"
        },
        {
            "location": "/source/packages/shrub-villiany/",
            "text": "Villiany\n\n\nWatch for and punish bad behavior.\n\n\ni8n = null\nPromise = null\n\nconfig = require 'config'\n\norm = null\n\n{AuthorizationFailure} = require 'shrub-socket/manager'\n\nFingerprint = require 'fingerprint'\nlogger = null\nvillianyLimiter = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \nshrubCorePreBootstrap\n\n\n  registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    i8n = require 'inflection'\n    Promise = require 'bluebird'\n\n    logging = require 'logging'\n\n    orm = require 'shrub-orm'\n\n    logger = logging.create file: filename: 'logs/villiany.log'\n\n    {Limiter} = require 'shrub-limiter'\n\n    {\n      thresholdScore\n      thresholdMs\n    } = config.get 'packageConfig:shrub-villiany:ban'\n\n    villianyLimiter = new Limiter(\n      'villiany'\n      Limiter.threshold(thresholdScore).every(thresholdMs).milliseconds()\n    )\n\n\n\n\nImplements hook \nshrubOrmCollections\n\n\n  registrar.registerHook 'shrubOrmCollections', ->\n\n    Fingerprint = require 'fingerprint'\n\n\n\n\nBans.\n\n\n    Ban = attributes: expires: 'dateTime'\n\n\n\n\nThe structure of a ban is dictated by the fingerprint structure.\n\n\n    Fingerprint.keys().forEach (key) ->\n      Ban.attributes[key] =\n        index: true\n        type: 'string'\n\n\n\n\nGenerate a test for whether each fingerprint key has been banned. e.g.\n\nsession\n -> \nisSessionBanned\n\n\n      Ban[i8n.camelize \"is_#{key}_banned\", true] = (value) ->\n        method = i8n.camelize \"find_by_#{key}\", true\n        Promise.cast(this[method] value).bind({}).then((@bans) ->\n          return false if @bans.length is 0\n\n\n\n\nDestroy all expired bans.\n\n\n          expired = @bans.filter (ban) ->\n            ban.expires.getTime() <= Date.now()\n          Promise.all expired.map (ban) -> ban.destroy()\n\n        ).then (expired) ->\n\n          _ = require 'lodash'\n\n\n\n\nMore bans than those that expired?\n\n\n          isBanned: @bans.length > expired.length\n\n\n\n\nBan ttl.\n\n\n          ttl: Math.round (_.difference(@bans, expired).reduce(\n            (l, r) ->\n\n              if l > r.expires.getTime()\n                l\n              else\n                r.expires.getTime()\n\n            -Infinity\n\n\n\n\nIt's a timestamp, and it's in ms.\n\n\n          ) - Date.now()) / 1000\n\n\n\n\nCreate a ban from a fingerprint.\n\n\n    Ban.createFromFingerprint = (fingerprint, expires) ->\n\n      unless expires?\n        settings = config.get 'packageConfig:shrub-villiany:ban'\n        expires = parseInt settings.thresholdMs\n\n      data = expires: new Date Date.now() + expires\n      data[key] = value for key, value of fingerprint\n      @create data\n\n    'shrub-ban': Ban\n\n\n\n\nImplements hook \nshrubHttpMiddleware\n\n\n  registrar.registerHook 'shrubHttpMiddleware', ->\n\n    label: 'Provide villiany management'\n    middleware: [\n\n      (req, res, next) ->\n\n        req.on 'shrubVillianyKick', (subject, ttl) ->\n\n          res.status 401\n          res.end buildBanMessage subject, ttl\n\n        next()\n\n      enforcementMiddleware\n\n    ]\n\n\n\n\nImplements hook \nshrubConfigServer\n\n\n  registrar.registerHook 'shrubConfigServer', ->\n\n    ban:\n\n\n\n\nVilliany threshold score.\n\n\n      thresholdScore: 1000\n\n\n\n\n10 minute villiany threshold window by default.\n\n\n      thresholdMs: 1000 * 60 * 10\n\n\n\n\nImplements hook \nshrubSocketConnectionMiddleware\n\n\n  registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Provide villiany management'\n    middleware: socketMiddleware()\n\n\n\n\nImplements hook \nshrubRpcRoutesAlter\n\n\n  registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    {spliceRouteMiddleware} = require 'shrub-rpc'\n\n    for path, route of routes\n      spliceRouteMiddleware route, 'shrub-villiany', socketMiddleware()\n\n    return\n\n\n\n\nImplements hook \nshrubVillianyReport\n\n\nCatch villiany reports.\n\n\n  registrar.registerHook 'shrubVillianyReport', (req, score, type, excluded = []) ->\n\n    Ban = orm.collection 'shrub-ban'\n\n\n\n\nTerminate the chain if not a villian.\n\n\n    class NotAVillian extends Error\n      constructor: (@message) ->\n\n    fingerprint = new Fingerprint req\n    inlineKeys = fingerprint.inlineKeys excluded\n\n    villianyLimiter.accrueAndCheckThreshold(\n      inlineKeys, score\n\n    ).then((isVillian) ->\n\n\n\n\nLog this transgression.\n\n\n      fingerprint = fingerprint.get excluded\n\n      message = \"Logged villiany score #{\n        score\n      } for #{\n        type\n      }, fingerprint: #{\n        JSON.stringify fingerprint\n      }\"\n      message += ', which resulted in a ban.' if isVillian\n      logger[if isVillian then 'error' else 'warn'] message\n\n      throw new NotAVillian unless isVillian\n\n\n\n\nBan.\n\n\n      Ban.createFromFingerprint fingerprint\n\n    ).then(->\n\n\n\n\nKick.\n\n\n      req.emit 'shrubVillianyKick', villianyLimiter.ttl inlineKeys\n\n    ).then(-> true).catch NotAVillian, -> false\n\n\n\n\nEnforce bans.\n\n\nenforcementMiddleware = (req, res, next) ->\n\n  Ban = orm.collection 'shrub-ban'\n\n\n\n\nTerminate the request if a ban is enforced.\n\n\n  class RequestBanned extends Error\n    constructor: (@message, @key, @ttl) ->\n\n  fingerprint = new Fingerprint req\n  banPromises = for key, value of fingerprint.get()\n    do (key, value) ->\n      method = i8n.camelize \"is_#{key}_banned\", true\n      Ban[method](value).then ({isBanned, ttl}) ->\n        throw new RequestBanned '', key, ttl if isBanned\n\n  Promise.all(banPromises).then(-> next()).catch(\n\n\n\n\nRequestBanned error just means we should emit.\n\n\n    RequestBanned, ({key, ttl}) -> req.emit 'shrubVillianyKick', key, ttl\n  ).catch (error) -> next error\n\n\n\n\nBuild a nice message for the villian.\n\n\nbuildBanMessage = (subject, ttl) ->\n\n  moment = require 'moment'\n\n  message = if subject?\n    \"Your #{subject} is banned.\"\n  else\n    'You are banned.'\n\n  message += \" The ban will be lifted #{\n    moment().add(ttl, 'seconds').fromNow()\n  }.\" if ttl?\n\n  message\n\n\n\n\nMiddleware for sockets.\n\n\nsocketMiddleware = -> [\n\n  (req, res, next) ->\n\n    req.on 'shrubVillianyKick', (subject, ttl) ->\n\n      throw new AuthorizationFailure unless req.socket?\n\n      req.socket.emit 'core.reload'\n\n    next()\n\n  enforcementMiddleware\n\n]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/shrub-villiany/#villiany",
            "text": "Watch for and punish bad behavior.  i8n = null\nPromise = null\n\nconfig = require 'config'\n\norm = null\n\n{AuthorizationFailure} = require 'shrub-socket/manager'\n\nFingerprint = require 'fingerprint'\nlogger = null\nvillianyLimiter = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  shrubCorePreBootstrap    registrar.registerHook 'shrubCorePreBootstrap', ->\n\n    i8n = require 'inflection'\n    Promise = require 'bluebird'\n\n    logging = require 'logging'\n\n    orm = require 'shrub-orm'\n\n    logger = logging.create file: filename: 'logs/villiany.log'\n\n    {Limiter} = require 'shrub-limiter'\n\n    {\n      thresholdScore\n      thresholdMs\n    } = config.get 'packageConfig:shrub-villiany:ban'\n\n    villianyLimiter = new Limiter(\n      'villiany'\n      Limiter.threshold(thresholdScore).every(thresholdMs).milliseconds()\n    )  Implements hook  shrubOrmCollections    registrar.registerHook 'shrubOrmCollections', ->\n\n    Fingerprint = require 'fingerprint'  Bans.      Ban = attributes: expires: 'dateTime'  The structure of a ban is dictated by the fingerprint structure.      Fingerprint.keys().forEach (key) ->\n      Ban.attributes[key] =\n        index: true\n        type: 'string'  Generate a test for whether each fingerprint key has been banned. e.g. session  ->  isSessionBanned        Ban[i8n.camelize \"is_#{key}_banned\", true] = (value) ->\n        method = i8n.camelize \"find_by_#{key}\", true\n        Promise.cast(this[method] value).bind({}).then((@bans) ->\n          return false if @bans.length is 0  Destroy all expired bans.            expired = @bans.filter (ban) ->\n            ban.expires.getTime() <= Date.now()\n          Promise.all expired.map (ban) -> ban.destroy()\n\n        ).then (expired) ->\n\n          _ = require 'lodash'  More bans than those that expired?            isBanned: @bans.length > expired.length  Ban ttl.            ttl: Math.round (_.difference(@bans, expired).reduce(\n            (l, r) ->\n\n              if l > r.expires.getTime()\n                l\n              else\n                r.expires.getTime()\n\n            -Infinity  It's a timestamp, and it's in ms.            ) - Date.now()) / 1000  Create a ban from a fingerprint.      Ban.createFromFingerprint = (fingerprint, expires) ->\n\n      unless expires?\n        settings = config.get 'packageConfig:shrub-villiany:ban'\n        expires = parseInt settings.thresholdMs\n\n      data = expires: new Date Date.now() + expires\n      data[key] = value for key, value of fingerprint\n      @create data\n\n    'shrub-ban': Ban  Implements hook  shrubHttpMiddleware    registrar.registerHook 'shrubHttpMiddleware', ->\n\n    label: 'Provide villiany management'\n    middleware: [\n\n      (req, res, next) ->\n\n        req.on 'shrubVillianyKick', (subject, ttl) ->\n\n          res.status 401\n          res.end buildBanMessage subject, ttl\n\n        next()\n\n      enforcementMiddleware\n\n    ]  Implements hook  shrubConfigServer    registrar.registerHook 'shrubConfigServer', ->\n\n    ban:  Villiany threshold score.        thresholdScore: 1000  10 minute villiany threshold window by default.        thresholdMs: 1000 * 60 * 10  Implements hook  shrubSocketConnectionMiddleware    registrar.registerHook 'shrubSocketConnectionMiddleware', ->\n\n    label: 'Provide villiany management'\n    middleware: socketMiddleware()  Implements hook  shrubRpcRoutesAlter    registrar.registerHook 'shrubRpcRoutesAlter', (routes) ->\n\n    {spliceRouteMiddleware} = require 'shrub-rpc'\n\n    for path, route of routes\n      spliceRouteMiddleware route, 'shrub-villiany', socketMiddleware()\n\n    return  Implements hook  shrubVillianyReport  Catch villiany reports.    registrar.registerHook 'shrubVillianyReport', (req, score, type, excluded = []) ->\n\n    Ban = orm.collection 'shrub-ban'  Terminate the chain if not a villian.      class NotAVillian extends Error\n      constructor: (@message) ->\n\n    fingerprint = new Fingerprint req\n    inlineKeys = fingerprint.inlineKeys excluded\n\n    villianyLimiter.accrueAndCheckThreshold(\n      inlineKeys, score\n\n    ).then((isVillian) ->  Log this transgression.        fingerprint = fingerprint.get excluded\n\n      message = \"Logged villiany score #{\n        score\n      } for #{\n        type\n      }, fingerprint: #{\n        JSON.stringify fingerprint\n      }\"\n      message += ', which resulted in a ban.' if isVillian\n      logger[if isVillian then 'error' else 'warn'] message\n\n      throw new NotAVillian unless isVillian  Ban.        Ban.createFromFingerprint fingerprint\n\n    ).then(->  Kick.        req.emit 'shrubVillianyKick', villianyLimiter.ttl inlineKeys\n\n    ).then(-> true).catch NotAVillian, -> false  Enforce bans.  enforcementMiddleware = (req, res, next) ->\n\n  Ban = orm.collection 'shrub-ban'  Terminate the request if a ban is enforced.    class RequestBanned extends Error\n    constructor: (@message, @key, @ttl) ->\n\n  fingerprint = new Fingerprint req\n  banPromises = for key, value of fingerprint.get()\n    do (key, value) ->\n      method = i8n.camelize \"is_#{key}_banned\", true\n      Ban[method](value).then ({isBanned, ttl}) ->\n        throw new RequestBanned '', key, ttl if isBanned\n\n  Promise.all(banPromises).then(-> next()).catch(  RequestBanned error just means we should emit.      RequestBanned, ({key, ttl}) -> req.emit 'shrubVillianyKick', key, ttl\n  ).catch (error) -> next error  Build a nice message for the villian.  buildBanMessage = (subject, ttl) ->\n\n  moment = require 'moment'\n\n  message = if subject?\n    \"Your #{subject} is banned.\"\n  else\n    'You are banned.'\n\n  message += \" The ban will be lifted #{\n    moment().add(ttl, 'seconds').fromNow()\n  }.\" if ttl?\n\n  message  Middleware for sockets.  socketMiddleware = -> [\n\n  (req, res, next) ->\n\n    req.on 'shrubVillianyKick', (subject, ttl) ->\n\n      throw new AuthorizationFailure unless req.socket?\n\n      req.socket.emit 'core.reload'\n\n    next()\n\n  enforcementMiddleware\n\n]",
            "title": "Villiany"
        },
        {
            "location": "/source/server/",
            "text": "Server application entry point\n\n\nLoad the configuration, invoke the bootstrap hooks, and listen for signals\nand process exit.\n The core bootstrap phase injects environment into a\nforked copy of the application including require paths to allow core and\ncustom packages to be included without qualification.\n\n\n{fork} = require \"./server/bootstrap\"\nunless fork()\n\n  Promise = require 'bluebird'\n\n  debug = require('debug') 'shrub:server'\n  debugSilly = require('debug') 'shrub-silly:server'\n\n  config = require 'config'\n  errors = require 'errors'\n  middleware = require 'middleware'\n  pkgman = require 'pkgman'\n\n\n\n\nSet up exit hooks.\n\n\nInvoke hook \nshrubCoreProcessExit\n\n\n  process.on 'exit', -> pkgman.invoke 'shrubCoreProcessExit'\n\n  process.on 'SIGINT', -> process.exit()\n  process.on 'SIGTERM', -> process.exit()\n  process.on 'unhandledException', -> process.exit()\n\n\n\n\nLoad the configuration.\n\n\n  debug 'Loading config...'\n\n  config.load()\n  config.loadPackageSettings()\n\n  debug 'Config loaded.'\n\n\n\n\nInvoke hook \nshrubCorePreBootstrap\n\n\n  debugSilly 'Pre bootstrap phase...'\n  pkgman.invoke 'shrubCorePreBootstrap'\n  debugSilly 'Pre bootstrap phase completed.'\n\n\n\n\nInvoke hook \nshrubCoreBootstrapMiddleware\n\n\n  debugSilly 'Loading bootstrap middleware...'\n\n  bootstrapMiddleware = middleware.fromConfig(\n    'shrub-core:bootstrapMiddleware'\n  )\n\n  debugSilly 'Bootstrap middleware loaded.'\n\n\n\n\nDispatch the bootstrap middleware stack and log if everything is okay.\n\n\n  bootstrapMiddleware.dispatch (error) ->\n    return debug 'Bootstrap complete.' unless error?\n\n\n\n\nLog and throw any error. This will be caught by the unhandledException\nlistener below.\n\n\n    console.error errors.stack error\n    process.exit()",
            "title": "server.coffee"
        },
        {
            "location": "/source/server/#server-application-entry-point",
            "text": "Load the configuration, invoke the bootstrap hooks, and listen for signals\nand process exit.  The core bootstrap phase injects environment into a\nforked copy of the application including require paths to allow core and\ncustom packages to be included without qualification.  {fork} = require \"./server/bootstrap\"\nunless fork()\n\n  Promise = require 'bluebird'\n\n  debug = require('debug') 'shrub:server'\n  debugSilly = require('debug') 'shrub-silly:server'\n\n  config = require 'config'\n  errors = require 'errors'\n  middleware = require 'middleware'\n  pkgman = require 'pkgman'  Set up exit hooks.  Invoke hook  shrubCoreProcessExit    process.on 'exit', -> pkgman.invoke 'shrubCoreProcessExit'\n\n  process.on 'SIGINT', -> process.exit()\n  process.on 'SIGTERM', -> process.exit()\n  process.on 'unhandledException', -> process.exit()  Load the configuration.    debug 'Loading config...'\n\n  config.load()\n  config.loadPackageSettings()\n\n  debug 'Config loaded.'  Invoke hook  shrubCorePreBootstrap    debugSilly 'Pre bootstrap phase...'\n  pkgman.invoke 'shrubCorePreBootstrap'\n  debugSilly 'Pre bootstrap phase completed.'  Invoke hook  shrubCoreBootstrapMiddleware    debugSilly 'Loading bootstrap middleware...'\n\n  bootstrapMiddleware = middleware.fromConfig(\n    'shrub-core:bootstrapMiddleware'\n  )\n\n  debugSilly 'Bootstrap middleware loaded.'  Dispatch the bootstrap middleware stack and log if everything is okay.    bootstrapMiddleware.dispatch (error) ->\n    return debug 'Bootstrap complete.' unless error?  Log and throw any error. This will be caught by the unhandledException\nlistener below.      console.error errors.stack error\n    process.exit()",
            "title": "Server application entry point"
        },
        {
            "location": "/source/server/bootstrap/",
            "text": "Process bootstrap\n\n\nBootstrap the server application by forking to ensure require paths are set\nby default.\n\n\n{fork} = require 'child_process'\n\n\n\n\nboostrap.fork\n\n\nFork the process in order to inject require paths if necessary.\n\n\nexports.fork = ->\n\n\n\n\nIf we've already forked, our work is done.\n\n\n  return null if process.env.SHRUB_FORKED?\n\n\n\n\nEnsure we have default require paths.\n\n\n  SHRUB_REQUIRE_PATH = if process.env.SHRUB_REQUIRE_PATH?\n    process.env.SHRUB_REQUIRE_PATH\n  else\n    'custom:.:packages:server:client/modules'\n\n\n\n\nPass all arguments to the child process.\n\n\n  args = process.argv.slice 2\n\n\n\n\nPass the environment to the child process.\n\n\n  options = env: process.env\n\n\n\n\nIntegrate any NODE_PATH after the shrub require paths.\n\n\n  if process.env.NODE_PATH?\n    SHRUB_REQUIRE_PATH += \":#{process.env.NODE_PATH}\"\n\n\n\n\nInject shrub require paths as the new NODE_PATH, and signal that we've\nforked.\n\n\n  options.env.NODE_PATH = SHRUB_REQUIRE_PATH\n  options.env.SHRUB_FORKED = true\n\n\n\n\nFork it.\n\n\n  fork process.argv[1], args, options",
            "title": "bootstrap.coffee"
        },
        {
            "location": "/source/server/bootstrap/#process-bootstrap",
            "text": "Bootstrap the server application by forking to ensure require paths are set\nby default.  {fork} = require 'child_process'",
            "title": "Process bootstrap"
        },
        {
            "location": "/source/server/bootstrap/#boostrapfork",
            "text": "Fork the process in order to inject require paths if necessary.  exports.fork = ->  If we've already forked, our work is done.    return null if process.env.SHRUB_FORKED?  Ensure we have default require paths.    SHRUB_REQUIRE_PATH = if process.env.SHRUB_REQUIRE_PATH?\n    process.env.SHRUB_REQUIRE_PATH\n  else\n    'custom:.:packages:server:client/modules'  Pass all arguments to the child process.    args = process.argv.slice 2  Pass the environment to the child process.    options = env: process.env  Integrate any NODE_PATH after the shrub require paths.    if process.env.NODE_PATH?\n    SHRUB_REQUIRE_PATH += \":#{process.env.NODE_PATH}\"  Inject shrub require paths as the new NODE_PATH, and signal that we've\nforked.    options.env.NODE_PATH = SHRUB_REQUIRE_PATH\n  options.env.SHRUB_FORKED = true  Fork it.    fork process.argv[1], args, options",
            "title": "boostrap.fork"
        },
        {
            "location": "/source/server/config/",
            "text": "Server configuration\n\n\nManages server and package configuration.\n\n\ndebug = require('debug') 'shrub:config'\nnconf = require 'nconf'\nfs = require 'fs'\n\nyaml = require 'js-yaml'\n\npkgman = require 'pkgman'\n\n{Config} = require 'client/modules/config'\n\n\n\n\nconfig.get\n\n\n\n\n(string) \npath\n - The path whose value to get.\n\n\n\n\nGet a configuration value.\n\n\nexports.get = (path) -> nconf.get path\n\n\n\n\nconfig.has\n\n\n\n\n(string) \npath\n - The path to check.\n\n\n\n\nCheck if a configuration path exists.\n\n\nexports.has = (path) -> nconf.has path\n\n\n\n\nconfig.load\n\n\nLoad configuration from the settings file and set package defaults.\n\n\nexports.load = ->\n\n\n\n\nEnsure the configuration file exists.\n\n\n  unless fs.existsSync settingsFilename = './config/settings.yml'\n    throw new Error 'Settings file not found! You should copy config/default.settings.yml to config/settings.yml'\n\n  settings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\n  settings.path = \"#{__dirname}/..\"\n\n  nconf.argv().env().overrides settings\n\n  return\n\n\n\n\nconfig.loadPackageSettings\n\n\nLoad package settings as defaults in the configuration.\n\n\nexports.loadPackageSettings = ->\n\n\n\n\nRegister packages.\n\n\n  debug 'Registering packages...'\n\n  pkgman.registerPackageList nconf.get 'packageList'\n\n  debug 'Packages registered.'\n\n  packageConfig = new Config()\n  for path, value of pkgman.invoke 'shrubConfigServer'\n    packageConfig.set path.replace(/\\//g, ':'), value\n\n  nconf.defaults\n\n\n\n\nInvoke hook \nshrubConfigServer\n\n\n    packageConfig: packageConfig.toJSON()\n\n    path: \"#{__dirname}/..\"\n\n  return\n\n\n\n\nconfig.set\n\n\n\n\n(string) \npath\n - The path whose value to set.\n\n\n\n\nSet a configuration value.\n\n\nexports.set = (path, value) -> nconf.set path, value",
            "title": "config.coffee"
        },
        {
            "location": "/source/server/config/#server-configuration",
            "text": "Manages server and package configuration.  debug = require('debug') 'shrub:config'\nnconf = require 'nconf'\nfs = require 'fs'\n\nyaml = require 'js-yaml'\n\npkgman = require 'pkgman'\n\n{Config} = require 'client/modules/config'",
            "title": "Server configuration"
        },
        {
            "location": "/source/server/config/#configget",
            "text": "(string)  path  - The path whose value to get.   Get a configuration value.  exports.get = (path) -> nconf.get path",
            "title": "config.get"
        },
        {
            "location": "/source/server/config/#confighas",
            "text": "(string)  path  - The path to check.   Check if a configuration path exists.  exports.has = (path) -> nconf.has path",
            "title": "config.has"
        },
        {
            "location": "/source/server/config/#configload",
            "text": "Load configuration from the settings file and set package defaults.  exports.load = ->  Ensure the configuration file exists.    unless fs.existsSync settingsFilename = './config/settings.yml'\n    throw new Error 'Settings file not found! You should copy config/default.settings.yml to config/settings.yml'\n\n  settings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\n  settings.path = \"#{__dirname}/..\"\n\n  nconf.argv().env().overrides settings\n\n  return",
            "title": "config.load"
        },
        {
            "location": "/source/server/config/#configloadpackagesettings",
            "text": "Load package settings as defaults in the configuration.  exports.loadPackageSettings = ->  Register packages.    debug 'Registering packages...'\n\n  pkgman.registerPackageList nconf.get 'packageList'\n\n  debug 'Packages registered.'\n\n  packageConfig = new Config()\n  for path, value of pkgman.invoke 'shrubConfigServer'\n    packageConfig.set path.replace(/\\//g, ':'), value\n\n  nconf.defaults  Invoke hook  shrubConfigServer      packageConfig: packageConfig.toJSON()\n\n    path: \"#{__dirname}/..\"\n\n  return",
            "title": "config.loadPackageSettings"
        },
        {
            "location": "/source/server/config/#configset",
            "text": "(string)  path  - The path whose value to set.   Set a configuration value.  exports.set = (path, value) -> nconf.set path, value",
            "title": "config.set"
        },
        {
            "location": "/source/server/crypto/",
            "text": "Crypto\n\n\nCryptographic helper functions.\n\n\ncrypto = require 'crypto'\nconfig = require 'config'\nPromise = require 'bluebird'\n\n\n\n\ncrypto.encrypt\n\n\n\n\n\n\n(string) \nmessage\n - The message to encrypt.\n\n\n\n\n\n\n(optional string) \npassword\n - The password to use to encrypt the message.\n\n\n\n\n\n\nDefaults to the site's global crypto key. \nAES encrypt a message with a\npassword.\n\n\nexports.encrypt = (message, password) ->\n\n  new Promise (resolve, reject) ->\n\n    cipher = crypto.createCipher(\n      'aes256'\n      password ? config.get 'packageConfig:shrub-core:cryptoKey'\n    )\n\n    cipherText = []\n    cipherText.push cipher.update message, 'binary', 'hex'\n    cipherText.push cipher.final 'hex'\n    resolve cipherText.join ''\n\n\n\n\ncrypto.decrypt\n\n\n\n\n\n\n(string) \nmessage\n - The message to decrypt.\n\n\n\n\n\n\n(optional string) \npassword\n - The password to use to decrypt the message.\n\n\n\n\n\n\nDefaults to the site's global crypto key. \nAES decrypt a message with a\npassword.\n\n\nexports.decrypt = (message, password) ->\n\n  new Promise (resolve, reject) ->\n\n    decipher = crypto.createDecipher(\n      'aes256'\n      password ? config.get 'packageConfig:shrub-core:cryptoKey'\n    )\n    decipher.setAutoPadding false\n\n    decipherText = []\n    decipherText.push decipher.update message, 'hex', 'binary'\n    decipherText.push decipher.final 'binary'\n    decipherText = decipherText.join ''\n\n\n\n\nSlice off any padding.\n\n\n    if 16 >= code = decipherText.charCodeAt decipherText.length - 1\n      decipherText = decipherText.slice 0, -code\n\n    resolve decipherText\n\n\n\n\ncrypto.hasher\n\n\nCREDIT:\n\nhttps://gist.github.com/boronine/3548196\n\ncha0s promisify'd it and made it work with Buffer objects.\n\n\n\n\n\n\n(object) \noptions\n - The options to use. The options object may include\nthe following values:\n\n\n\n\n\n\ndigest\n: The cryptographic digest function to use to generate the\n  hash. Defaults to 'sha1'.\n\n\n\n\n\n\nplaintext\n: The plaintext password to hash and return as \nkey\n. If\n  none is provided, an 8-character random plaintext password will be\n  generated.\n\n\n\n\n\n\nsalt\n: The salt to hash the password with. If none is provided, a\n  512-bit salt will be generated.\n\n\n\n\n\n\niterations\n: The number of iterations to use for the PBKDF. Defaults\n  to 10000. \nNOTE:\n This \nmust\n be the same number when\n  generating and verifying hashes, otherwise verification will fail.\n\n\n\n\n\n\n\n\n\n\n\n\n\nCryptographic authentication functionality.\n\n\nexports.hasher = (options = {}) ->\n\n\n\n\nGenerate random 8-character base64 password if none provided\n\n\n  unless options.plaintext?\n\n    return exports.randomBytes(6).then((buffer) ->\n      options.plaintext = buffer.toString 'base64'\n      exports.hasher options\n    )\n\n\n\n\nGenerate random 512-bit salt if no salt provided\n\n\n  unless options.salt?\n\n    return exports.randomBytes(64).then((buffer) ->\n      options.salt = buffer\n      exports.hasher options\n    )\n\n  options.digest ?= 'sha1'\n  options.iterations ?= 10000\n\n  exports.pbkdf2(\n    options.plaintext, options.salt, options.iterations, 64, options.digest\n\n  ).then (key) ->\n    options.key = new Buffer key\n    options\n\n\n\n\nPromisify some useful node.js crypto functions.\n\n\nexports.pbkdf2 = Promise.promisify crypto.pbkdf2, crypto\nexports.randomBytes = Promise.promisify crypto.randomBytes, crypto",
            "title": "crypto.coffee"
        },
        {
            "location": "/source/server/crypto/#crypto",
            "text": "Cryptographic helper functions.  crypto = require 'crypto'\nconfig = require 'config'\nPromise = require 'bluebird'",
            "title": "Crypto"
        },
        {
            "location": "/source/server/crypto/#cryptoencrypt",
            "text": "(string)  message  - The message to encrypt.    (optional string)  password  - The password to use to encrypt the message.    Defaults to the site's global crypto key.  AES encrypt a message with a\npassword.  exports.encrypt = (message, password) ->\n\n  new Promise (resolve, reject) ->\n\n    cipher = crypto.createCipher(\n      'aes256'\n      password ? config.get 'packageConfig:shrub-core:cryptoKey'\n    )\n\n    cipherText = []\n    cipherText.push cipher.update message, 'binary', 'hex'\n    cipherText.push cipher.final 'hex'\n    resolve cipherText.join ''",
            "title": "crypto.encrypt"
        },
        {
            "location": "/source/server/crypto/#cryptodecrypt",
            "text": "(string)  message  - The message to decrypt.    (optional string)  password  - The password to use to decrypt the message.    Defaults to the site's global crypto key.  AES decrypt a message with a\npassword.  exports.decrypt = (message, password) ->\n\n  new Promise (resolve, reject) ->\n\n    decipher = crypto.createDecipher(\n      'aes256'\n      password ? config.get 'packageConfig:shrub-core:cryptoKey'\n    )\n    decipher.setAutoPadding false\n\n    decipherText = []\n    decipherText.push decipher.update message, 'hex', 'binary'\n    decipherText.push decipher.final 'binary'\n    decipherText = decipherText.join ''  Slice off any padding.      if 16 >= code = decipherText.charCodeAt decipherText.length - 1\n      decipherText = decipherText.slice 0, -code\n\n    resolve decipherText",
            "title": "crypto.decrypt"
        },
        {
            "location": "/source/server/crypto/#cryptohasher",
            "text": "CREDIT: https://gist.github.com/boronine/3548196 \ncha0s promisify'd it and made it work with Buffer objects.    (object)  options  - The options to use. The options object may include\nthe following values:    digest : The cryptographic digest function to use to generate the\n  hash. Defaults to 'sha1'.    plaintext : The plaintext password to hash and return as  key . If\n  none is provided, an 8-character random plaintext password will be\n  generated.    salt : The salt to hash the password with. If none is provided, a\n  512-bit salt will be generated.    iterations : The number of iterations to use for the PBKDF. Defaults\n  to 10000.  NOTE:  This  must  be the same number when\n  generating and verifying hashes, otherwise verification will fail.       Cryptographic authentication functionality.  exports.hasher = (options = {}) ->  Generate random 8-character base64 password if none provided    unless options.plaintext?\n\n    return exports.randomBytes(6).then((buffer) ->\n      options.plaintext = buffer.toString 'base64'\n      exports.hasher options\n    )  Generate random 512-bit salt if no salt provided    unless options.salt?\n\n    return exports.randomBytes(64).then((buffer) ->\n      options.salt = buffer\n      exports.hasher options\n    )\n\n  options.digest ?= 'sha1'\n  options.iterations ?= 10000\n\n  exports.pbkdf2(\n    options.plaintext, options.salt, options.iterations, 64, options.digest\n\n  ).then (key) ->\n    options.key = new Buffer key\n    options  Promisify some useful node.js crypto functions.  exports.pbkdf2 = Promise.promisify crypto.pbkdf2, crypto\nexports.randomBytes = Promise.promisify crypto.randomBytes, crypto",
            "title": "crypto.hasher"
        },
        {
            "location": "/source/server/crypto.spec/",
            "text": "crypto = require 'server/crypto'\nPromise = require 'bluebird'\n\ncryptoKey = 'This should be a sufficiently long encryption key. For testing.'\n\ndescribe 'crypto', ->\n\n  it 'can encrypt and decrypt information', ->\n\n    texts = []\n\n    for i in [0...100]\n\n      texts[i] = String.fromCharCode Math.floor Math.random() * 256\n      texts[i] += texts[i - 1] if i > 0\n\n    ciphertexts = []\n    ciphertextsPromise = null\n\n    runs ->\n\n      ciphertexts = for text in texts\n\n        crypto.encrypt text, cryptoKey\n\n      ciphertextsPromise = Promise.all ciphertexts\n\n    waitsFor -> ciphertextsPromise.isFulfilled()\n\n    deciphertexts = []\n    deciphertextsPromise = null\n\n    runs ->\n\n      ciphertexts = ciphertextsPromise.inspect().value()\n\n      deciphertexts = for ciphertext in ciphertexts\n\n        crypto.decrypt ciphertext, cryptoKey\n\n      deciphertextsPromise = Promise.all deciphertexts\n\n    waitsFor -> deciphertextsPromise.isFulfilled()\n\n    runs ->\n\n      deciphertexts = deciphertextsPromise.inspect().value()\n\n      for text, i in texts\n\n        expect(text).toBe deciphertexts[i]",
            "title": "crypto.spec.coffee"
        },
        {
            "location": "/source/server/fingerprint/",
            "text": "Fingerprint class\n\n\npkgman = require 'pkgman'\n\n\n\n\nGather and transform fingerprint data.\n\n\nmodule.exports = class Fingerprint\n\n\n\n\nconstructor\n\n\n\n\n(http.IncomingMessage) \n_req\n - The request.\n\n\n\n\nStore the request in the instance.\n\n\n  constructor: (@_req) ->\n\n\n\n\nFingerprint#get\n\n\nSee \nFingerprint.get\n\n\n  get: (excluded) -> Fingerprint.get @_req, excluded\n\n\n\n\nFingerprint#inlineKeys\n\n\nSee \nFingerprint.inlineKeys\n\n\n  inlineKeys: (excluded) -> Fingerprint.inlineKeys @_req, excluded\n\n\n\n\nFingerprint#keys\n\n\nSee \nFingerprint.keys\n\n\n  keys: (excluded) -> Fingerprint.keys @_req, excluded\n\n\n\n\nFingerprint#raw\n\n\nSee \nFingerprint.raw\n\n\n  raw: (excluded) -> Fingerprint.raw @_req, excluded\n\n\n\n\nFingerprint.get\n\n\n\n\n\n\n(http.IncomingMessage) \nreq\n - The request.\n\n\n\n\n\n\n(string array) \nexcluded\n - Keys to exclude from the result.\n\n\n\n\n\n\nGet the raw fingerprint and filter out null values.\n\n\n  @get: (req, excluded = []) ->\n    fingerprint = {}\n\n    for key, value of @raw req, excluded\n      continue unless value?\n      fingerprint[key] = value\n\n    fingerprint\n\n\n\n\nFingerprint.inlineKeys\n\n\n\n\n\n\n(http.IncomingMessage) \nreq\n - The request.\n\n\n\n\n\n\n(string array) \nexcluded\n - Keys to exclude from the result.\n\n\n\n\n\n\nGet the filtered fingerprint and map it to key/value pairs.\n\n\n  @inlineKeys: (req, excluded = []) ->\n    \"#{key}:#{value}\" for key, value of @get req, excluded\n\n\n\n\nFingerprint.keys\n\n\n\n\n\n\n(http.IncomingMessage) \nreq\n - The request.\n\n\n\n\n\n\n(string array) \nexcluded\n - Keys to exclude from the result.\n\n\n\n\n\n\nGet the keys from the raw fingerprint.\n\n\n  @keys: (req, excluded = []) -> Object.keys @raw req, excluded\n\n\n\n\nFingerprint.raw\n\n\n\n\n\n\n(http.IncomingMessage) \nreq\n - The request.\n\n\n\n\n\n\n(string array) \nexcluded\n - Keys to exclude from the result.\n\n\n\n\n\n\nGet the raw fingerprint.\n\n\n  @raw: (req, excluded = []) ->\n    raw = {}\n\n    _excluded = {}\n    _excluded[key] = true for key in excluded\n\n\n\n\nInvoke hook \nshrubAuditFingerprint\n\n\n    for keys in pkgman.invokeFlat 'shrubAuditFingerprint', req\n      for key, value of keys ? {}\n        continue if _excluded[key]\n        raw[key] = value\n\n    raw",
            "title": "fingerprint.coffee"
        },
        {
            "location": "/source/server/fingerprint/#fingerprint-class",
            "text": "pkgman = require 'pkgman'  Gather and transform fingerprint data.  module.exports = class Fingerprint",
            "title": "Fingerprint class"
        },
        {
            "location": "/source/server/fingerprint/#constructor",
            "text": "(http.IncomingMessage)  _req  - The request.   Store the request in the instance.    constructor: (@_req) ->",
            "title": "constructor"
        },
        {
            "location": "/source/server/fingerprint/#fingerprintget",
            "text": "See  Fingerprint.get    get: (excluded) -> Fingerprint.get @_req, excluded",
            "title": "Fingerprint#get"
        },
        {
            "location": "/source/server/fingerprint/#fingerprintinlinekeys",
            "text": "See  Fingerprint.inlineKeys    inlineKeys: (excluded) -> Fingerprint.inlineKeys @_req, excluded",
            "title": "Fingerprint#inlineKeys"
        },
        {
            "location": "/source/server/fingerprint/#fingerprintkeys",
            "text": "See  Fingerprint.keys    keys: (excluded) -> Fingerprint.keys @_req, excluded",
            "title": "Fingerprint#keys"
        },
        {
            "location": "/source/server/fingerprint/#fingerprintraw",
            "text": "See  Fingerprint.raw    raw: (excluded) -> Fingerprint.raw @_req, excluded",
            "title": "Fingerprint#raw"
        },
        {
            "location": "/source/server/fingerprint/#fingerprintget_1",
            "text": "(http.IncomingMessage)  req  - The request.    (string array)  excluded  - Keys to exclude from the result.    Get the raw fingerprint and filter out null values.    @get: (req, excluded = []) ->\n    fingerprint = {}\n\n    for key, value of @raw req, excluded\n      continue unless value?\n      fingerprint[key] = value\n\n    fingerprint",
            "title": "Fingerprint.get"
        },
        {
            "location": "/source/server/fingerprint/#fingerprintinlinekeys_1",
            "text": "(http.IncomingMessage)  req  - The request.    (string array)  excluded  - Keys to exclude from the result.    Get the filtered fingerprint and map it to key/value pairs.    @inlineKeys: (req, excluded = []) ->\n    \"#{key}:#{value}\" for key, value of @get req, excluded",
            "title": "Fingerprint.inlineKeys"
        },
        {
            "location": "/source/server/fingerprint/#fingerprintkeys_1",
            "text": "(http.IncomingMessage)  req  - The request.    (string array)  excluded  - Keys to exclude from the result.    Get the keys from the raw fingerprint.    @keys: (req, excluded = []) -> Object.keys @raw req, excluded",
            "title": "Fingerprint.keys"
        },
        {
            "location": "/source/server/fingerprint/#fingerprintraw_1",
            "text": "(http.IncomingMessage)  req  - The request.    (string array)  excluded  - Keys to exclude from the result.    Get the raw fingerprint.    @raw: (req, excluded = []) ->\n    raw = {}\n\n    _excluded = {}\n    _excluded[key] = true for key in excluded  Invoke hook  shrubAuditFingerprint      for keys in pkgman.invokeFlat 'shrubAuditFingerprint', req\n      for key, value of keys ? {}\n        continue if _excluded[key]\n        raw[key] = value\n\n    raw",
            "title": "Fingerprint.raw"
        },
        {
            "location": "/source/server/logging/",
            "text": "Server logging\n\n\nProvide a unified interface for logging messages.\n\n\n_ = require 'lodash'\n\nutil = require 'util'\n\nconfig = require 'config'\nerrors = require 'errors'\n\ndebug = require('debug') 'shrub:logger'\n\n\n\n\nlogging.create\n\n\n\n\n(string) \nfilename\n - The filename where the log will be written.\n\n\n\n\nCreate a new logger instance.\n\n\nexports.create = (options) ->\n\n  winston = require 'winston'\n  {Transport} = require 'winston/lib/winston/transports/transport'\n\n  class DebugTransport extends Transport\n\n    log: (level, msg, meta, callback) ->\n\n      output = \"#{level}: \"\n      if _.isString msg\n        output += msg\n      else if msg instanceof Error\n        output += errors.stack msg\n      else\n        output += util.inspect msg\n      debug output\n\n      @emit 'logged'\n      callback null, true\n\n  options ?= {}\n  options.transports ?= []\n\n  options.console ?= {}\n  options.console.level ?= if 'production' is config.get 'NODE_ENV'\n    'error'\n  else\n    'silly'\n  options.transports.push new DebugTransport options.console\n\n  options.file ?= {}\n  options.file.level ?= if 'production' is config.get 'NODE_ENV'\n    'error'\n  else\n    'silly'\n  if options.file.filename?\n    options.transports.push new winston.transports.File options.file\n\n  new winston.Logger transports: options.transports\n\n\n\n\nCreate a default logger, for convenience.\n\n\ndefaultLogger = exports.create file: filename: 'logs/shrub.log'\nexports.defaultLogger = defaultLogger",
            "title": "logging.coffee"
        },
        {
            "location": "/source/server/logging/#server-logging",
            "text": "Provide a unified interface for logging messages.  _ = require 'lodash'\n\nutil = require 'util'\n\nconfig = require 'config'\nerrors = require 'errors'\n\ndebug = require('debug') 'shrub:logger'",
            "title": "Server logging"
        },
        {
            "location": "/source/server/logging/#loggingcreate",
            "text": "(string)  filename  - The filename where the log will be written.   Create a new logger instance.  exports.create = (options) ->\n\n  winston = require 'winston'\n  {Transport} = require 'winston/lib/winston/transports/transport'\n\n  class DebugTransport extends Transport\n\n    log: (level, msg, meta, callback) ->\n\n      output = \"#{level}: \"\n      if _.isString msg\n        output += msg\n      else if msg instanceof Error\n        output += errors.stack msg\n      else\n        output += util.inspect msg\n      debug output\n\n      @emit 'logged'\n      callback null, true\n\n  options ?= {}\n  options.transports ?= []\n\n  options.console ?= {}\n  options.console.level ?= if 'production' is config.get 'NODE_ENV'\n    'error'\n  else\n    'silly'\n  options.transports.push new DebugTransport options.console\n\n  options.file ?= {}\n  options.file.level ?= if 'production' is config.get 'NODE_ENV'\n    'error'\n  else\n    'silly'\n  if options.file.filename?\n    options.transports.push new winston.transports.File options.file\n\n  new winston.Logger transports: options.transports  Create a default logger, for convenience.  defaultLogger = exports.create file: filename: 'logs/shrub.log'\nexports.defaultLogger = defaultLogger",
            "title": "logging.create"
        },
        {
            "location": "/source/server/sandboxes/",
            "text": "Sandboxes\n\n\nThis module provides a method for creating sandboxed DOMs (using\n\njsdom\n). It augments the DOM with a\nfunctional \nWebSocket\n using\n\nws\n, and generally makes spinning up\narbitrary DOM contexts a pleasant breeze.\n\n\nconfig = require 'config'\nPromise = require 'bluebird'\nWebSocket = require 'ws/lib/WebSocket'\n\nerrors = require 'errors'\nlogging = require 'logging'\n\n{jsdom} = require 'jsdom'\n\n\n\n\nHax: Fix document.domain since jsdom has a stub here.\n\n\n{HTMLDocument} = require 'jsdom/lib/jsdom/living'\nObject.defineProperties(\n  HTMLDocument.prototype\n  domain: get: -> 'localhost'\n)\n\n\n\n\nThis class is responsible for creating and cleaning up DOMs, and provides\nsome methods to inspect the state of the document.\n\n\nexports.Sandbox = class Sandbox\n\n\n\n\nconstructor\n\n\nSpin up a DOM.\n\n\n  constructor: ->\n\n    @_cleanupFunctions = []\n    @_window = null\n\n\n\n\nSandbox#close\n\n\nClose a DOM.\n\n\n  close: ->\n\n\n\n\nIf the window is already gone, nope out.\n\n\n    return Promise.resolve() unless @_window?\n\n\n\n\nRun all the registered cleanup functions.\n\n\n    Promise.all(\n      fn() for fn in @_cleanupFunctions\n\n\n\n\nSuppress cleanup errors.\n\n\n    ).catch(->\n\n\n\n\nActually close the window and null it out.\n\n\n    ).finally =>\n\n      @_window.close()\n      @_window = null\n\n\n\n\nSandbox#createDocument\n\n\n\n\n\n\n(string) \nhtml\n - The HTML document.\n\n\n\n\n\n\n(object) \noptions\n - An options object which may contain the following\n\n\n\n\n\n\nvalues:\n    * (string) \ncookie\n - Cookie string.\n    * (string) \ncookieDomain\n - The domain the cookie applies to.\n    * (string) \nurl\n - The canonical URL of the HTML document.\n\n\n\n\n\nCreate a DOM from an HTML document.\n\n\n  createDocument: (html, options = {}) ->\n\n\n\n\nSet up a DOM, forwarding our cookie.\n\n\n    document = jsdom(\n      html\n\n      cookie: options.cookie\n      cookieDomain: options.cookieDomain ? 'localhost'\n\n      url: options.url ? \"http://localhost:#{\n        config.get 'packageConfig:shrub-http:port'\n      }/\"\n    )\n    @_window = window = document.defaultView\n\n    @_window.addEventListener 'error', startupErrorHandler = (errorEvent) ->\n      (window.__shrubStartupErrors ?= []).push errorEvent.error\n\n\n\n\nCapture \"client\" console logs.\n\n\n    for level in ['info', 'log', 'debug', 'warn', 'error']\n      do (level) -> window.console[level] = (args...) ->\n\n\n\n\nMake errors as detailed as possible.\n\n\n        for arg, i in args\n          if arg instanceof Error\n            args[i] = errors.stack arg\n          else\n            arg\n\n        console[level] args...\n\n\n\n\nHack in WebSocket.\n\n\n    window.WebSocket = WebSocket\n\n    sandbox = this\n    new Promise (resolve, reject) ->\n\n\n\n\nWhen the window is loaded, we'll reject with any error, or resolve.\n\n\n      window.onload = ->\n\n        unless window.__shrubStartupErrors?\n          window.removeEventListener 'error', startupErrorHandler\n          return resolve sandbox\n\n\n\n\nJust emit the first error.\n\n\nTODO: How can we collapse multiple errors into one?\n\n\n        reject window.__shrubStartupErrors[0]\n\n\n\n\nSandbox#emitHtml\n\n\nEmit the document as HTML.\n\n\n  emitHtml: -> \"\"\"\n<!doctype html>\n\n\n\n\n@_window.document.innerHTML}\n\n\n\"\"\"\n\n\n\n\nSandbox#registerCleanupFunction\n\n\n\n\n(function) \nfn\n - The function to run when the sandbox is closing.\n\n\n\n\nRegister a function to run when the sandbox is closing.\n\n\n  registerCleanupFunction: (fn) -> @_cleanupFunctions.push fn\n\n\n\n\nSandbox#url\n\n\nThe current URL the sandbox is at.\n\n\n  url: -> @_window.location.href",
            "title": "sandboxes.coffee"
        },
        {
            "location": "/source/server/sandboxes/#sandboxes",
            "text": "This module provides a method for creating sandboxed DOMs (using jsdom ). It augments the DOM with a\nfunctional  WebSocket  using ws , and generally makes spinning up\narbitrary DOM contexts a pleasant breeze.  config = require 'config'\nPromise = require 'bluebird'\nWebSocket = require 'ws/lib/WebSocket'\n\nerrors = require 'errors'\nlogging = require 'logging'\n\n{jsdom} = require 'jsdom'  Hax: Fix document.domain since jsdom has a stub here.  {HTMLDocument} = require 'jsdom/lib/jsdom/living'\nObject.defineProperties(\n  HTMLDocument.prototype\n  domain: get: -> 'localhost'\n)  This class is responsible for creating and cleaning up DOMs, and provides\nsome methods to inspect the state of the document.  exports.Sandbox = class Sandbox",
            "title": "Sandboxes"
        },
        {
            "location": "/source/server/sandboxes/#constructor",
            "text": "Spin up a DOM.    constructor: ->\n\n    @_cleanupFunctions = []\n    @_window = null",
            "title": "constructor"
        },
        {
            "location": "/source/server/sandboxes/#sandboxclose",
            "text": "Close a DOM.    close: ->  If the window is already gone, nope out.      return Promise.resolve() unless @_window?  Run all the registered cleanup functions.      Promise.all(\n      fn() for fn in @_cleanupFunctions  Suppress cleanup errors.      ).catch(->  Actually close the window and null it out.      ).finally =>\n\n      @_window.close()\n      @_window = null",
            "title": "Sandbox#close"
        },
        {
            "location": "/source/server/sandboxes/#sandboxcreatedocument",
            "text": "(string)  html  - The HTML document.    (object)  options  - An options object which may contain the following    values:\n    * (string)  cookie  - Cookie string.\n    * (string)  cookieDomain  - The domain the cookie applies to.\n    * (string)  url  - The canonical URL of the HTML document.   Create a DOM from an HTML document.    createDocument: (html, options = {}) ->  Set up a DOM, forwarding our cookie.      document = jsdom(\n      html\n\n      cookie: options.cookie\n      cookieDomain: options.cookieDomain ? 'localhost'\n\n      url: options.url ? \"http://localhost:#{\n        config.get 'packageConfig:shrub-http:port'\n      }/\"\n    )\n    @_window = window = document.defaultView\n\n    @_window.addEventListener 'error', startupErrorHandler = (errorEvent) ->\n      (window.__shrubStartupErrors ?= []).push errorEvent.error  Capture \"client\" console logs.      for level in ['info', 'log', 'debug', 'warn', 'error']\n      do (level) -> window.console[level] = (args...) ->  Make errors as detailed as possible.          for arg, i in args\n          if arg instanceof Error\n            args[i] = errors.stack arg\n          else\n            arg\n\n        console[level] args...  Hack in WebSocket.      window.WebSocket = WebSocket\n\n    sandbox = this\n    new Promise (resolve, reject) ->  When the window is loaded, we'll reject with any error, or resolve.        window.onload = ->\n\n        unless window.__shrubStartupErrors?\n          window.removeEventListener 'error', startupErrorHandler\n          return resolve sandbox  Just emit the first error.  TODO: How can we collapse multiple errors into one?          reject window.__shrubStartupErrors[0]",
            "title": "Sandbox#createDocument"
        },
        {
            "location": "/source/server/sandboxes/#sandboxemithtml",
            "text": "Emit the document as HTML.    emitHtml: -> \"\"\"\n<!doctype html>  @_window.document.innerHTML}  \"\"\"",
            "title": "Sandbox#emitHtml"
        },
        {
            "location": "/source/server/sandboxes/#sandboxregistercleanupfunction",
            "text": "(function)  fn  - The function to run when the sandbox is closing.   Register a function to run when the sandbox is closing.    registerCleanupFunction: (fn) -> @_cleanupFunctions.push fn",
            "title": "Sandbox#registerCleanupFunction"
        },
        {
            "location": "/source/server/sandboxes/#sandboxurl",
            "text": "The current URL the sandbox is at.    url: -> @_window.location.href",
            "title": "Sandbox#url"
        }
    ]
}